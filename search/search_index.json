{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The free5GC (a Linux Foundation project) is an open-source project for 5th generation (5G) mobile core networks. The ultimate goal of this project is to implement the 5G core network (5GC) defined in 3GPP Release 15 (R15) and beyond.</p> <p>Currently, the major contributors are from National Yang Ming Chiao Tung University (NYCU).</p> <ul> <li>The source code of the latest version of free5GC can be downloaded from here.</li> <li>Information about TSC (Technical Steering Committee) can be found at free5gc/governance.</li> <li>Follow our LinkedIn page to get the news about free5GC.</li> <li>Please refer to our roadmap for the features of each release.</li> </ul> <p>Note</p> <p>Thank you very much for your interest in free5GC. The license of free5GC follows Apache 2.0. That is, anyone can use free5GC for commercial purposes for free.</p> <p>Note</p> <p>Please check out the Google Scholar page here for publications using free5GC.</p> <p>Note</p> <p>Want to contribute to free5GC? Check out our How to contribute page for more information.</p>"},{"location":"#20241112-free5gc-v344-released","title":"2024/11/12: free5GC v3.4.4 released!","text":"<p>The release of free5GC v3.4.4 includes several new features, including default profile values in the Webconsole, a search bar for profiles and subscribers, NEF support for Traffic Influence, and NAT-T support for N3IWUE in N3IWF. The N3IWF configuration file has been refactored. Bug fixes address SMF ULCL charging issues, AMF authentication procedures, UE RAT type determination, and a UDM SUCI profile B decrypt error, along with other issues reported on GitHub and the free5GC forum.</p> <p>[Features]</p> <ul> <li>Add Profile(default values) for create subscriber in Webconsole</li> <li>Add Webconsole Search Bar for Profiles and Subscribers</li> <li>Released NEF that supporting Traffic Influence</li> <li>N3IWF support NAT-T with N3IWUE</li> <li>Go-UPF with v0.9.3 GTP5G Version</li> <li>SMF support SDM Subscription and Unsubscription for UE Session #123</li> </ul> <p>[Refactor]</p> <ul> <li>N3IWF Refactor, including the configuration file #618</li> <li>SMF Refactor, using Go context to track UPF association state #122</li> </ul> <p>[Bugs]</p> <ul> <li>SMF ULCL Charging Bugs</li> <li>AMF authentication procedure and UE RAT type determination issues.</li> <li>UDM SUCI profile B decrypt error #41</li> <li>Fix some bug reports from\u00a0Issues\u00a0or\u00a0Forum</li> </ul> <p>Note</p> <p>The history of the version release can be found on the history page.</p>"},{"location":"#next-steps","title":"Next Step(s)","text":"<p>We remain committed to enhancing free5GC with new features, and we have a roadmap in place to support the following functionalities:</p> <ul> <li>Kubernetes deployment (quick installation)</li> <li>SBI R17 support</li> <li>Packet Rusher CI integration</li> <li>NR-DC</li> <li>Roaming</li> <li>5G LAN</li> </ul>"},{"location":"history/","title":"History","text":""},{"location":"history/#2024-roadmap","title":"2024 Roadmap","text":""},{"location":"history/#nov-12-2024-v344","title":"Nov 12, 2024: v3.4.4","text":"<p>The release of free5GC v3.4.4 includes several new features, including default profile values in the Webconsole, a search bar for profiles and subscribers, NEF support for Traffic Influence, and NAT-T support for N3IWUE in N3IWF. The N3IWF configuration file has been refactored. Bug fixes address SMF ULCL charging issues, AMF authentication procedures, UE RAT type determination, and a UDM SUCI profile B decrypt error, along with other issues reported on GitHub and the free5GC forum.</p> <p>[Features]</p> <ul> <li>Add Profile(default values) for create subscriber in Webconsole</li> <li>Add Webconsole Search Bar for Profiles and Subscribers</li> <li>Released NEF that supporting Traffic Influence</li> <li>N3IWF support NAT-T with N3IWUE</li> <li>Go-UPF with v0.9.3 GTP5G Version</li> <li>SMF support SDM Subscription and Unsubscription for UE Session #123</li> </ul> <p>[Refactor]</p> <ul> <li>N3IWF Refactor, including the configuration file #618</li> <li>SMF Refactor, using Go context to track UPF association state #122</li> </ul> <p>[Bugs]</p> <ul> <li>SMF ULCL Charging Bugs</li> <li>AMF authentication procedure and UE RAT type determination issues.</li> <li>UDM SUCI profile B decrypt error #41</li> <li>Fix some bug reports from\u00a0Issues\u00a0or\u00a0Forum</li> </ul>"},{"location":"history/#sep-5-2024-v343","title":"Sep 5, 2024: v3.4.3","text":"<p>The release of free5GC v3.4.3 includes several new features, such as new network function TNGF, support for an empty SD value in SNSSAI, and the ability to disable CGF in CHF. It also features a refactored Subscriber Modal Page in the Webconsole. Additionally, several bugs have been fixed, including issues with double registration with N3IWF and unauthorized UE context releases, along with other bug fixes reported via GitHub issues and the free5GC forum.</p> <p>[Features]</p> <ul> <li>Release TNGF &amp; TNGFUE</li> <li>Support empty SD value (SNSSAI)</li> <li>Support disable CGF in CHF</li> </ul> <p>[Refactor]</p> <ul> <li>Refactor Subscriber Modal Page in Webconsole</li> </ul> <p>[Bugs]</p> <ul> <li>Fix can't registration with N3IWF twice problems</li> <li>Fix UEs can be context released by a second UE without authentication (src: Issue)</li> <li>Fix some bug reports from Issues or Forum</li> </ul>"},{"location":"history/#july-3-2024-v342","title":"July 3, 2024: v3.4.2","text":"<p>The free5GC v3.4.2 includes a Go version update to 1.21 and refactoring all Network Functions. New features include setting static IPs for UEs and OAuth2 authentication for the webconsole, plus a ULCL example in free5gc-compose. Bug fixes and a new commit message check are also included.</p> <p>[Refactor]</p> <ul> <li>Go version bump to Go1.21</li> <li>Refactor NFs for preparation upgrading openapi to Release17</li> </ul> <p>[Features]</p> <ul> <li>Set Static-IP for UE in webconsole </li> <li>Webconsole acts as AF and uses OAuth2 authentication to get OAM service from NFs</li> <li>Add ULCL docker-compose example in free5gc-compose</li> <li>Session AMBR in Data Plane</li> <li>CHF on k8s</li> </ul> <p>[Bugs]</p> <ul> <li>Fix N3IWUE fails to ping when having flow rules(v1.0.1)</li> <li>Fix some bug reports from Issues or Forum</li> </ul> <p>[Chore]</p> <ul> <li>Apply Conventional Commit Message check in Pull Request</li> </ul>"},{"location":"history/#march-28-2024-v341","title":"March 28, 2024: v3.4.1","text":"<p>In free5GC v3.4.1, Convergent Charging on PDU Session will be fully supported! Users will see the data usage on the webconsole after the PDU Session is created (please note that: The charging method (Online/Offline) needs to be determined during the subscription creation).</p> <p></p> <p>If you're interested in the implementation details, please visit the CHF design document.</p>"},{"location":"history/#feb-16-2024-v340","title":"Feb 16, 2024: v3.4.0","text":"<p>We are delighted to unveil the release of free5GC v3.4.0! In this latest version, free5GC now boasts support for OAuth within the Service-Based Architecture (SBA), marking a significant advancement in its capabilities. Furthermore, we have diligently addressed several issues and bugs that were reported by the Open-Source community, ensuring a smoother and more reliable user experience.</p> <ul> <li>OAuth Support<ul> <li>NRF acts as authorization server</li> <li>All Services in AMF, SMF, NRF, PCF, UDR, UDM, AUSF, NSSF are supported to validate/request access token</li> </ul> </li> <li>Implicit De-registration<ul> <li>Use case: UE has registered on Old AMF and send registration request to new AMF<ul> <li>New AMF is able to get the UE context by asking the old AMF, and old AMF will do the implicit de-registration.</li> </ul> </li> </ul> </li> <li>Support NAS Reroute (Issue #413)</li> <li>Support NITZ (Network Identiy and Time Zone) in UE Configuration Update Command (Issue #113)</li> <li>Bugfix<ul> <li>Issue #421</li> <li>Issue #387</li> </ul> </li> <li>Release N3IWUE<ul> <li>Source code: https://github.com/free5gc/n3iwue</li> </ul> </li> </ul>"},{"location":"publication/","title":"Relavent Publications","text":""},{"location":"publication/#publications-using-free5gc","title":"Publications using free5GC","text":"<ul> <li>Google Scholar</li> <li>ACM Library</li> <li>IEEE Xplore</li> </ul>"},{"location":"videos/","title":"Other Videos","text":""},{"location":"videos/#other-videos-showing-free5gc","title":"Other videos showing free5GC","text":"<ol> <li> <p>Complete Free5GC Installation on Kubernetes Cluster (Step-by-Step), September 13, 2023</p> </li> <li> <p>Akraino Blueprints: Integrated Cloud Native Private Wireless, The Linux Foundation, October 11, 2021</p> </li> <li> <p>SD Core Techinar July 7 2021, Open Networking Foundation, July 13, 2021</p> </li> <li> <p>Aarna Networks MWC 2021 Demo, Aarna Networks Channel, June 27, 2021</p> </li> <li> <p>OpenStack Tacker Demo, Open Infrastructure Foundation, April 26, 2021</p> </li> <li> <p>OpenNess Tungsten Fabric free5GC demo, Aarna Networks Channel, February 16, 2021</p> </li> <li> <p>5G Core on Diamanti, Diamanti, Inc., February 3, 2021</p> </li> <li> <p>free5GC (5G Core) Orchestration on Kubernetes with Tungsten Fabric CNI and Testing, Aarna Networks Channel, December 2, 2020</p> </li> <li> <p>IoT LoRa (sensors and gateway in hardware), RAN in hardware (SDR) and software, and the free5GC, LABORA Research Group, July 3, 2020</p> </li> <li> <p>UE and eNodeB in Hardware (conventional cell phone + SDR) and free5GC: a pratical approach in 5G, LABORA Research Group, July 3, 2020</p> </li> <li> <p>OpenAirInterface and free5GC: a pratical approach in 5G networks, LABORA Research Group, June 29, 2020</p> </li> </ol>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blogs","title":"Blogs","text":""},{"location":"blog/#official","title":"Official","text":"<ul> <li>2024/12/30: 5G Network Slicing</li> <li>2024/12/24: Debug gtp5g kernel module using stacktrace and eBPF</li> <li>2024/12/04: Paging in 5G Network</li> <li>2024/12/03: Loxilb eBPF</li> <li>2024/11/27: NWDAF introduction</li> <li>2024/11/13: Mapping PCC Rules into Session Rules: Policy Application in 5G Networks</li> <li>2024/11/08: Modeling Digital Twins in 5G Networks: A Glimpse into the Future of Intelligent Network Management</li> <li>2024/09/18: How L25GC+ achieved the low-latency communication</li> <li>2024/06/28: Introduction to 5G-QoS</li> <li>2024/06/26: NTN Overview</li> <li>2024/05/21: Introduction to Onos</li> <li>2024/03/27: Introduction of IP Multimedia Subsystem Part 3</li> <li>2024/02/21: Effective Network Management for Cloud-Native 5G Networks with eBPF</li> <li>2024/01/19: Registration Procedures</li> <li>2024/01/10: PacketRusher: A new UE/gNB simulator and CP/UP load tester</li> <li>2024/01/03: UE-initiated PLR Measurement Procedure in PMFP Procedure</li> <li>2023/12/13: Article Sharing: Evaluating Dedicated Slices of Different Configurations in 5G Core</li> <li>2023/12/06: Introduction of IP Multimedia Subsystem Part 2</li> <li>2023/11/29: Basic concept of RCU: Read, Copy, Update</li> <li>2023/11/22: Nephio: a Cloud Native Network Automation Linux Foundation Project</li> <li>2023/11/15: free5GC OAuth2 Procedure</li> <li>2023/11/08: Introduction of IP Multimedia Subsystem Part 1</li> <li>2023/10/18: LTE Authentication Introduction: EPS-AKA'</li> <li>2023/10/4: Introduction of MPTCP</li> <li>2023/9/27: Support of Time Sensitive Communication and Time Synchronization in 5G system - Introduction (Rel-17)</li> <li>2023/9/20: Introduction of gtp5g and some kernel concepts</li> <li>2023/9/13: CHarging Function(CHF) Overview</li> <li>2023/9/6: The role of VNFD and NSD in 5G Network Slicing</li> <li>2023/8/30: Article Sharing: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</li> <li>2023/8/23: Web security: CSRF vulnerability in webconsole</li> <li>2023/8/16: Introduce Kubernetes and Deployment free5GC on Kubernetes with helm</li> <li>2023/8/9: Fuzz Testing in Go: Discovering Vulnerabilities and Analyzing a Real Case (CVE-2022-43677)</li> <li>2023/8/2: Authentication Mechanism in NRF: What Is OAuth?</li> <li>2023/7/26: How to deploy free5GC network slice on OpenStack</li> <li>2023/7/19: Network function UDM introduction</li> <li>2023/7/12: Time-Sensitive Networking over 5G system - Introduction (Rel-16)</li> <li>2023/7/5: Use network namespace to separate the 5GC and RAN simulator</li> <li>2023/6/21: 5G SCTP LoadBalancer Using LoxiLB Applying on free5GC</li> </ul>"},{"location":"blog/#external","title":"External","text":"<ul> <li>free5GC 5GC &amp; UERANSIM UE / RAN Sample Configuration - VPP-UPF with DPDK</li> <li>Deploy eBPF-based UPF with free5GC</li> <li>Introduce to 5GC (written in traditional chinese)</li> <li>Free5GC v3.4.3 source code study (written in simplified Chinese)</li> <li>Deploying 5G core network with Free5GC, Kubernetes and Helm</li> <li>Running Free5GC on Platform9 Managed Kubernetes</li> <li>Try iPhone connection with free5GC and real gNB(written in japanese)</li> </ul>"},{"location":"blog/20230705/1-free5gc-with-namespace/","title":"1 free5gc with namespace","text":""},{"location":"blog/20230705/1-free5gc-with-namespace/#use-network-namespace-to-separate-the-5g-core-5gc-and-ran-simulator","title":"Use network namespace to separate the 5G core (5GC) and RAN simulator","text":"<p>Note</p> <p>Author: Jimmy Chang Date: 2023/7/5</p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#overview","title":"Overview","text":"<p>This technique leverages namespace to run UERANSIM, an opensource 5G-UE and RAN(gNodeB) simulator, and connect to free5GC. UERANSIM follows the 3GPP specification for developing and can support multiple 5G core (5GC) including free5GC.</p> <p>Why are we using namespace? Well, you can follow ULCL and free5GC compose to set up the environment with VM and docker, but there are limitations for hardware\u2019s capability. With network namespace, you can have different and separate network instances of network interfaces and routing tables that operate independently.</p> <p>So, what is network namespace? Network namespace makes a copy of network stack with its own routing table, firewall and devices. A named network namespace is an object at <code>/var/run/netns/</code>. The file descriptor resulting from opening <code>/var/run/netns/</code> refers to the specified network namespace. Holding that file descriptor open keeps the network namespace alive.</p> <p>And how to make both namespaces communicating? A virtual Ethernet device (veth) pair provides the abstraction that can be used to create tunnels between network namespaces, and can be used to create bridge to a physical network device in another namespace. Veth pair also be used as standalone network devices. When the namespace freed, veth device which attatch to would be destroyed.</p> <p>The environment is as follow. Suppose you have already installed as well as set up free5GC and UERANSIM properly.</p> <ul> <li>free5GC v3.3.0</li> <li>UERANSIM v3.1.0</li> </ul> <p>Note</p> <p>Namespace free5GC represents host network namespace. And enp0s5 is an ethernet interface connectting to external.</p> <p></p> <pre><code>Each devices as follow\n| Device        | IP             |\n| ------------- | -------------  |\n| veth0         | 10.200.200.1   |\n| veth1         | 10.200.200.2   |\n| br-veth0      | none           |\n| br-veth1      | none           |\n| enp0s5        | 10.211.55.23   |\n\n\nUE information in UERANSIM as follow. Already\n| IMSI             | DNN           |\n| ---------------- | ------------- |\n| 208930000000003  | internet      |\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#configuration-file-of-free5gc-and-ueransim","title":"Configuration file of free5GC and UERANSIM","text":""},{"location":"blog/20230705/1-free5gc-with-namespace/#free5gc","title":"free5GC","text":"<ul> <li>free5gc/config/amfcfg.yaml</li> </ul> <p>Replace ngapIpList IP from <code>127.0.0.18</code> to <code>10.200.200.2</code>:</p> <p><pre><code>info:\n  version: 1.0.9\n  description: AMF initial local configuration\n\nconfiguration:\n  amfName: AMF # the name of this AMF\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n    - 10.200.200.2 # 127.0.0.18\n  ngapPort: 38412 # the SCTP port listened by NGAP\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.18 # IP used to register to NRF\n    bindingIPv4: 127.0.0.18  # IP used to bind the service\n    port: 8000 # port used to bind the service\n    tls: # the local path of TLS key\n      pem: cert/amf.pem # AMF TLS Certificate\n      key: cert/amf.key # AMF TLS Private key\n  serviceNameList: # the SBI services provided by this AMF, refer to TS 29.518\n    - namf-comm # Namf_Communication service\n    - namf-evts # Namf_EventExposure service\n    - namf-mt   # Namf_MT service\n    - namf-loc  # Namf_Location service\n    - namf-oam  # OAM service\n  servedGuamiList: # Guami (Globally Unique AMF ID) list supported by this AMF\n    # &lt;GUAMI&gt; = &lt;MCC&gt;&lt;MNC&gt;&lt;AMF ID&gt;\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      amfId: cafe00 # AMF identifier (3 bytes hex string, range: 000000~FFFFFF)\n  supportTaiList:  # the TAI (Tracking Area Identifier) list supported by this AMF\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      tac: 000001 # Tracking Area Code (3 bytes hex string, range: 000000~FFFFFF)\n  plmnSupportList: # the PLMNs (Public land mobile network) list supported by this AMF\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      snssaiList: # the S-NSSAI (Single Network Slice Selection Assistance Information) list supported by this AMF\n        - sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n          sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n        - sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n          sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n  supportDnnList:  # the DNN (Data Network Name) list supported by this AMF\n    - internet\n  nrfUri: http://127.0.0.10:8000 # a valid URI of NRF\n  security:  # NAS security parameters\n    integrityOrder: # the priority of integrity algorithms\n      - NIA2\n      # - NIA0\n    cipheringOrder: # the priority of ciphering algorithms\n      - NEA0\n      # - NEA2\n  networkName:  # the name of this core network\n    full: free5GC\n    short: free\n  ngapIE: # Optional NGAP IEs\n    mobilityRestrictionList: # Mobility Restriction List IE, refer to TS 38.413\n      enable: true # append this IE in related message or not\n    maskedIMEISV: # Masked IMEISV IE, refer to TS 38.413\n      enable: true # append this IE in related message or not\n    redirectionVoiceFallback: # Redirection Voice Fallback IE, refer to TS 38.413\n      enable: false # append this IE in related message or not\n  nasIE: # Optional NAS IEs\n    networkFeatureSupport5GS: # 5gs Network Feature Support IE, refer to TS 24.501\n      enable: true # append this IE in Registration accept or not\n      length: 1 # IE content length (uinteger, range: 1~3)\n      imsVoPS: 0 # IMS voice over PS session indicator (uinteger, range: 0~1)\n      emc: 0 # Emergency service support indicator for 3GPP access (uinteger, range: 0~3)\n      emf: 0 # Emergency service fallback indicator for 3GPP access (uinteger, range: 0~3)\n      iwkN26: 0 # Interworking without N26 interface indicator (uinteger, range: 0~1)\n      mpsi: 0 # MPS indicator (uinteger, range: 0~1)\n      emcN3: 0 # Emergency service support indicator for Non-3GPP access (uinteger, range: 0~1)\n      mcsi: 0 # MCS indicator (uinteger, range: 0~1)\n  t3502Value: 720  # timer value (seconds) at UE side\n  t3512Value: 3600 # timer value (seconds) at UE side\n  non3gppDeregTimerValue: 3240 # timer value (seconds) at UE side\n  # retransmission timer for paging message\n  t3513:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Deregistration Request message\n  t3522:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Registration Accept message\n  t3550:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Authentication Request/Security Mode Command message\n  t3560:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Notification message\n  t3565:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Identity Request message\n  t3570:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  locality: area1 # Name of the location where a set of AMF, SMF, PCF and UPFs are located\n  sctp: # set the sctp server setting &lt;optinal&gt;, once this field is set, please also add maxInputStream, maxOsStream, maxAttempts, maxInitTimeOut\n    numOstreams: 3 # the maximum out streams of each sctp connection\n    maxInstreams: 5 # the maximum in streams of each sctp connection\n    maxAttempts: 2 # the maximum attempts of each sctp connection\n    maxInitTimeout: 2 # the maximum init timeout of each sctp connection\n  defaultUECtxReq: false # the default value of UE Context Request to decide when triggering Initial Context Setup procedure\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> - free5gc/config/smfcfg.yaml</p> <p>Replace userplaneInformation / upNodes / UPF / interfaces / endpoints from <code>127.0.0.8</code> to <code>10.200.200.2</code>:</p> <p><pre><code>info:\n  version: 1.0.7\n  description: SMF initial local configuration\n\nconfiguration:\n  smfName: SMF # the name of this SMF\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.2 # IP used to register to NRF\n    bindingIPv4: 127.0.0.2 # IP used to bind the service\n    port: 8000 # Port used to bind the service\n    tls: # the local path of TLS key\n      key: cert/smf.key # SMF TLS Certificate\n      pem: cert/smf.pem # SMF TLS Private key\n  serviceNameList: # the SBI services provided by this SMF, refer to TS 29.502\n    - nsmf-pdusession # Nsmf_PDUSession service\n    - nsmf-event-exposure # Nsmf_EventExposure service\n    - nsmf-oam # OAM service\n  snssaiInfos: # the S-NSSAI (Single Network Slice Selection Assistance Information) list supported by this AMF\n    - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n        sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n        sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n      dnnInfos: # DNN information list\n        - dnn: internet # Data Network Name\n          dns: # the IP address of DNS\n            ipv4: 8.8.8.8\n            ipv6: 2001:4860:4860::8888\n    - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n        sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n        sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n      dnnInfos: # DNN information list\n        - dnn: internet # Data Network Name\n          dns: # the IP address of DNS\n            ipv4: 8.8.8.8\n            ipv6: 2001:4860:4860::8888\n  plmnList: # the list of PLMN IDs that this SMF belongs to (optional, remove this key when unnecessary)\n    - mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n      mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n  locality: area1 # Name of the location where a set of AMF, SMF, PCF and UPFs are located\n  pfcp: # the IP address of N4 interface on this SMF (PFCP)\n    # addr config is deprecated in smf config v1.0.3, please use the following config\n    nodeID: 127.0.0.1 # the Node ID of this SMF\n    listenAddr: 127.0.0.1 # the IP/FQDN of N4 interface on this SMF (PFCP)\n    externalAddr: 127.0.0.1 # the IP/FQDN of N4 interface on this SMF (PFCP)\n  userplaneInformation: # list of userplane information\n    upNodes: # information of userplane node (AN or UPF)\n      gNB1: # the name of the node\n        type: AN # the type of the node (AN or UPF)\n      UPF: # the name of the node\n        type: UPF # the type of the node (AN or UPF)\n        nodeID: 127.0.0.8 # the Node ID of this UPF\n        addr: 127.0.0.8 # the IP/FQDN of N4 interface on this UPF (PFCP)\n        sNssaiUpfInfos: # S-NSSAI information list for this UPF\n          - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n              sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n              sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList: # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.60.0.0/16\n                staticPools:\n                  - cidr: 10.60.100.0/24\n          - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n              sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n              sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList: # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.61.0.0/16\n                staticPools:\n                  - cidr: 10.61.100.0/24\n        interfaces: # Interface list for this UPF\n          - interfaceType: N3 # the type of the interface (N3 or N9)\n            endpoints: # the IP address of this N3/N9 interface on this UPF\n              - 10.200.200.2 # 127.0.0.8\n            networkInstances:  # Data Network Name (DNN)\n              - internet\n    links: # the topology graph of userplane, A and B represent the two nodes of each link\n      - A: gNB1\n        B: UPF\n  # retransmission timer for pdu session modification command\n  t3591:\n    enable: true     # true or false\n    expireTime: 16s   # default is 6 seconds\n    maxRetryTimes: 3 # the max number of retransmission\n  # retransmission timer for pdu session release command\n  t3592:\n    enable: true     # true or false\n    expireTime: 16s   # default is 6 seconds\n    maxRetryTimes: 3 # the max number of retransmission\n  nrfUri: http://127.0.0.10:8000 # a valid URI of NRF\n  #urrPeriod: 10 # default usage report period in seconds\n  #urrThreshold: 1000 # default usage report threshold in bytes\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> - free5gc/config/upfcfg.yaml</p> <p>Replace gtpu from <code>127.0.0.8</code>to <code>10.200.200.2</code>:</p> <pre><code>version: 1.0.3\ndescription: UPF initial local configuration\n\n# The listen IP and nodeID of the N4 interface on this UPF (Can't set to 0.0.0.0)\npfcp:\n  addr: 127.0.0.8   # IP addr for listening\n  nodeID: 127.0.0.8 # External IP or FQDN can be reached\n  retransTimeout: 1s # retransmission timeout\n  maxRetrans: 3 # the max number of retransmission\n\ngtpu:\n  forwarder: gtp5g\n  # The IP list of the N3/N9 interfaces on this UPF\n  # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n  ifList:\n    - addr: 10.200.200.2 # 127.0.0.8\n      type: N3\n      # name: upf.5gc.nctu.me\n      # ifname: gtpif\n      # mtu: 1400\n\n# The DNN list supported by UPF\ndnnList:\n  - dnn: internet # Data Network Name\n    cidr: 10.60.0.0/24 # Classless Inter-Domain Routing for assigned IPv4 pool of UE\n    # natifname: eth0\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#ueransim","title":"UERANSIM","text":"<ul> <li> <p>UERANSIM/config/free5gc-gnb.yaml</p> </li> <li> <p>Replace ngapIp from <code>127.0.0.1</code>to <code>10.200.200.1</code></p> </li> <li> <p>Replace gtpIp from <code>127.0.0.1</code>to <code>10.200.200.1</code></p> </li> <li> <p>Replace amfConfigs / address from <code>127.0.0.1</code>to <code>10.200.200.2</code></p> </li> </ul> <p><pre><code>mcc: '208'          # Mobile Country Code value\nmnc: '93'           # Mobile Network Code value (2 or 3 digits)\n\nnci: '0x000000010'  # NR Cell Identity (36-bit)\nidLength: 32        # NR gNB ID length in bits [22...32]\ntac: 1              # Tracking Area Code\n\nlinkIp: 127.0.0.1   # gNB's local IP address for Radio Link Simulation (Usually same with local IP)\nngapIp: 10.200.200.1 # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\ngtpIp: 10.200.200.1 # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n# List of AMF address information\namfConfigs:\n  - address: 10.200.200.2 # 127.0.0.1\n    port: 38412\n\n# List of supported S-NSSAIs by this gNB\nslices:\n  - sst: 0x1\n    sd: 0x010203\n\n# Indicates whether or not SCTP stream number errors should be ignored.\nignoreStreamIds: true\n</code></pre> - UERANSIM/config/free5gc-ue.yaml <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000003'\n# Mobile Country Code value\nmcc: '208'\n# Mobile Network Code value (2 or 3 digits)\nmnc: '93'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OP'\n# Authentication Management Field (AMF) value\namf: '8000'\n# IMEI number of the device. It is used if no SUPI is provided\nimei: '356938035643803'\n# IMEISV number of the device. It is used if no SUPI and IMEI is provided\nimeiSv: '4370816125816151'\n\n# List of gNB IP addresses for Radio Link Simulation\ngnbSearchList:\n  - 127.0.0.1\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n\n# List of requested S-NSSAIs by this UE\nslices:\n  - sst: 0x01\n    sd: 0x010203\n\n# Supported encryption and integrity algorithms by this UE\nintegrity:\n  IA1: true\n  IA2: true\n  IA3: true\nciphering:\n  EA1: true\n  EA2: true\n  EA3: true\n</code></pre></p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#environment-set-up-of-free5gc-and-ueransim","title":"Environment set up of free5GC and UERANSIM","text":"<p>First, create a namespace:</p> <p>Note</p> <p>Assume that you are either running as root, or it behoves you to prepend <code>sudo</code> to commands as necessary.</p> <p><pre><code>ip netns add ueransim\n</code></pre> Next, add the bridge: <pre><code>ip link add free5gc-br type bridge\n</code></pre> Add two pairs of veth: <pre><code>ip link add veth0 type veth peer name br-veth0\nip link add veth1 type veth peer name br-veth1\n</code></pre> Now, it could be like: <pre><code>root@free5gc:~# ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:b1:ba:f4 brd ff:ff:ff:ff:ff:ff\n    inet 10.211.55.23/24 brd 10.211.55.255 scope global dynamic enp0s5\n       valid_lft 1714sec preferred_lft 1714sec\n    inet6 fdb2:2c26:f4e4:0:21c:42ff:feb1:baf4/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591750sec preferred_lft 604550sec\n    inet6 fe80::21c:42ff:feb1:baf4/64 scope link\n       valid_lft forever preferred_lft forever\n3: enp0s6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:f1:11:c6 brd ff:ff:ff:ff:ff:ff\n    inet 10.37.129.20/24 brd 10.37.129.255 scope global enp0s6\n       valid_lft forever preferred_lft forever\n    inet6 fdb2:2c26:f4e4:1:21c:42ff:fef1:11c6/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591750sec preferred_lft 604550sec\n    inet6 fe80::21c:42ff:fef1:11c6/64 scope link\n       valid_lft forever preferred_lft forever\n4: free5gc-br: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 4e:f6:d7:9c:50:de brd ff:ff:ff:ff:ff:ff\n5: br-veth0@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether c2:31:0c:5f:45:81 brd ff:ff:ff:ff:ff:ff\n6: veth0@br-veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n8: veth1@br-veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 12:5a:56:00:5b:be brd ff:ff:ff:ff:ff:ff\n</code></pre></p> <p>Next, assign interface to namespace: <pre><code>ip link set dev veth0 netns ueransim\n</code></pre> Set ip address: <pre><code>ip netns exec ueransim ip a add 10.200.200.1/24 dev veth0\n</code></pre> Enable both interface. Don't forget lo: <pre><code>ip netns exec ueransim ip link set lo up\nip netns exec ueransim ip link set veth0 up\n</code></pre> Check with <code>ip a</code>: <pre><code>root@free5gc:~# ip netns exec ueransim ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n</code></pre> Set for veth1 as well: <pre><code>ip a add 10.200.200.2/24 dev veth1\nip link set veth1 up\n</code></pre> Let two interfaces attatch to bridge: <pre><code>ip link set dev br-veth0 master free5gc-br\nip link set dev br-veth1 master free5gc-br\nip link set br-veth0 up\nip link set br-veth1 up\nip link set free5gc-br up\n</code></pre> Using <code>bridge link</code> to check: <pre><code>root@free5gc:~# bridge link\n5: br-veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master free5gc-br state forwarding priority 32 cost 2\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master free5gc-br state forwarding priority 32 cost 2\n</code></pre> Now it looks like: <pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:b1:ba:f4 brd ff:ff:ff:ff:ff:ff\n    inet 10.211.55.23/24 brd 10.211.55.255 scope global dynamic enp0s5\n       valid_lft 1000sec preferred_lft 1000sec\n    inet6 fdb2:2c26:f4e4:0:21c:42ff:feb1:baf4/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591870sec preferred_lft 604670sec\n    inet6 fe80::21c:42ff:feb1:baf4/64 scope link\n       valid_lft forever preferred_lft forever\n3: enp0s6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:f1:11:c6 brd ff:ff:ff:ff:ff:ff\n    inet 10.37.129.20/24 brd 10.37.129.255 scope global enp0s6\n       valid_lft forever preferred_lft forever\n    inet6 fdb2:2c26:f4e4:1:21c:42ff:fef1:11c6/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591870sec preferred_lft 604670sec\n    inet6 fe80::21c:42ff:fef1:11c6/64 scope link\n       valid_lft forever preferred_lft forever\n4: free5gc-br: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::5499:b0ff:fe82:780d/64 scope link\n       valid_lft forever preferred_lft forever\n5: br-veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master free5gc-br state UP group default qlen 1000\n    link/ether c2:31:0c:5f:45:81 brd ff:ff:ff:ff:ff:ff link-netns ueransim\n    inet6 fe80::c031:cff:fe5f:4581/64 scope link\n       valid_lft forever preferred_lft forever\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master free5gc-br state UP group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::5499:b0ff:fe82:780d/64 scope link\n       valid_lft forever preferred_lft forever\n8: veth1@br-veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 12:5a:56:00:5b:be brd ff:ff:ff:ff:ff:ff\n    inet 10.200.200.2/24 scope global veth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::105a:56ff:fe00:5bbe/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> Let's test it:</p> <p>Note</p> <p>You can perform <code>ip netns exec ueransim /bin/bash --rcfile &lt;(echo \"PS1=\\\"ueransim&gt; \\\"\")</code> to enter namespace and modify shell prefix.</p> <p><pre><code>root@free5gc:~# ip netns exec ueransim /bin/bash --rcfile &lt;(echo \"PS1=\\\"ueransim&gt; \\\"\")\nueransim&gt; ping -c2 10.200.200.2\nPING 10.200.200.2 (10.200.200.2) 56(84) bytes of data.\n64 bytes from 10.200.200.2: icmp_seq=1 ttl=64 time=0.089 ms\n64 bytes from 10.200.200.2: icmp_seq=2 ttl=64 time=0.226 ms\n\n--- 10.200.200.2 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1020ms\nrtt min/avg/max/mdev = 0.089/0.157/0.226/0.068 ms\n</code></pre> Insert default routing rule: <pre><code>ueransim&gt; ip route add default via 10.200.200.2\nueransim&gt; netstat -rn\nKernel IP routing table\nDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         10.200.200.2    0.0.0.0         UG        0 0          0 veth0\n10.200.200.0    0.0.0.0         255.255.255.0   U         0 0          0 veth0\n</code></pre> Try to ping 8.8.8.8: <pre><code>ueransim&gt; ping -c2 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 0 received, 100% packet loss, time 1028ms\n</code></pre> It is because the main host must translate the source addresses. Besides, the main host need to forward packet: <pre><code>root@free5gc:~# iptables -t nat -A POSTROUTING -o enp0s5 -j MASQUERADE\nroot@free5gc:~# sysctl -w net.ipv4.ip_forward=1\nroot@free5gc:~# sudo iptables -I FORWARD 1 -j ACCEPT\n</code></pre> And then: <pre><code>ueransim&gt; ping -c2 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=13.9 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=28.0 ms\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 13.866/20.939/28.012/7.073 ms\n</code></pre></p> <p>After free5GC execute <code>run.sh</code>, it's time for UERANSIM:</p> <p>In terminal 1: <pre><code>ueransim&gt; build/nr-gnb -c config/free5gc-gnb.yaml\nUERANSIM v3.1.0\n[2023-07-05 19:58:26.368] [sctp] [info] Trying to establish SCTP connection... (10.200.200.2:38412)\n[2023-07-05 19:58:26.373] [sctp] [info] SCTP connection established (10.200.200.2:38412)\n[2023-07-05 19:58:26.374] [sctp] [debug] SCTP association setup ascId[3]\n[2023-07-05 19:58:26.375] [ngap] [debug] Sending NG Setup Request\n[2023-07-05 19:58:26.380] [ngap] [debug] NG Setup Response received\n[2023-07-05 19:58:26.380] [ngap] [info] NG Setup procedure is successful\n[2023-07-05 19:58:35.804] [mr] [info] New UE connected to gNB. Total number of UEs is now: 1\n[2023-07-05 19:58:35.806] [rrc] [debug] Sending RRC Setup for UE[3]\n[2023-07-05 19:58:35.807] [ngap] [debug] Initial NAS message received from UE 3\n[2023-07-05 19:58:35.869] [ngap] [debug] Initial Context Setup Request received\n[2023-07-05 19:58:36.108] [ngap] [info] PDU session resource is established for UE[3] count[1]\n</code></pre> In terminal 2: <pre><code>ueransim&gt; sudo build/nr-ue -c config/free5gc-ue.yaml\nUERANSIM v3.1.0\n[2023-07-05 19:58:35.803] [nas] [debug] NAS layer started\n[2023-07-05 19:58:35.803] [rrc] [debug] RRC layer started\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-DEREGISTERED/PLMN-SEARCH\n[2023-07-05 19:58:35.804] [nas] [info] UE connected to gNB\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-DEREGISTERED/NORMAL-SERVICE\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-REGISTERED-INITIATED/NA\n[2023-07-05 19:58:35.805] [rrc] [debug] Sending RRC Setup Request\n[2023-07-05 19:58:35.806] [rrc] [info] RRC connection established\n[2023-07-05 19:58:35.806] [nas] [info] UE switches to state: CM-CONNECTED\n[2023-07-05 19:58:35.838] [nas] [debug] Received rand[61262F32A617D0BAD716603B1CBDA477] autn[44778026F4238000FC14B59D68855328]\n[2023-07-05 19:58:35.838] [nas] [debug] Calculated res[47759045F5ACEA59] ck[1C559301F29EF49572F5D150B3B99288] ik[D223317F752F233CE4C7AA253644D882] ak[528433D1FBE6] mac_a[FC14B59D68855328]\n[2023-07-05 19:58:35.838] [nas] [debug] Used snn[5G:mnc093.mcc208.3gppnetwork.org] sqn[16F3B3F70FC5]\n[2023-07-05 19:58:35.838] [nas] [debug] Derived kSeaf[7FC8B7FB1B141B6579B9C0FAEB9CCF1312FE9F9634868E234756DE49FD67C5F1] kAusf[FA0402A892E6046D52F4DECACA40B2A75B698FCEAD5EB320139FC69B77BD4C46] kAmf[3D4AD68E153B9642ACBECC67AD399015F7CB578F9DF4C88A35EED99C72C9B95B]\n[2023-07-05 19:58:35.843] [nas] [debug] Derived kNasEnc[1F829EB2BA238DD0226C3484E6A79D1F] kNasInt[251C0412B1BAD88A9DD0008F32D6F216]\n[2023-07-05 19:58:35.843] [nas] [debug] Selected integrity[2] ciphering[0]\n[2023-07-05 19:58:35.869] [nas] [debug] T3512 started with int[3600]\n[2023-07-05 19:58:35.869] [nas] [info] UE switches to state: MM-REGISTERED/NORMAL-SERVICE\n[2023-07-05 19:58:35.869] [nas] [info] Initial Registration is successful\n[2023-07-05 19:58:35.869] [nas] [info] Initial PDU sessions are establishing [1#]\n[2023-07-05 19:58:35.869] [nas] [debug] Sending PDU session establishment request\n[2023-07-05 19:58:36.108] [nas] [info] PDU Session establishment is successful PSI[1]\n[2023-07-05 19:58:36.113] [app] [info] Connection setup for PDU session[1] is successful, TUN interface[uesimtun0, 10.60.0.1] is up.\n</code></pre> In terminal 3: <pre><code>ueransim&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.1/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::b5ef:5b4:e3f6:af64/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::480f:1eff:fe80:9bbe/64 scope link\n       valid_lft forever preferred_lft forever\nueransim&gt; ping -c2 -I uesimtun0 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=19.5 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=33.2 ms\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1006ms\nrtt min/avg/max/mdev = 19.478/26.348/33.219/6.870 ms\n</code></pre> Also ping to google.com: <pre><code>ueransim&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=17.3 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=29.5 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1005ms\nrtt min/avg/max/mdev = 17.295/23.385/29.476/6.090 ms\n</code></pre></p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#what-if-two-ueransims-with-two-namespaces","title":"What if two UERANSIMs with two namespaces?","text":"<p>Same as before, you should create another namespace for UERANSIM, called it ueransim2: <pre><code>root@free5gc:~# ip netns ls\nueransim2 (id: 1)\nueransim (id: 0)\n</code></pre> And then: <pre><code>ip link add veth2 type veth peer name br-veth2\nip link set dev veth2 netns ueransim2\nip link set br-veth2 master free5gc-br\nip link set br-veth2 up\nip netns exec ueransim2 ip a add 10.200.200.3/24 dev veth2\nip netns exec ueransim2 ip link set lo up\nip netns exec ueransim2 ip link set veth2 up\nip netns exec ueransim2 ip route add default via 10.200.200.2\n</code></pre></p> <p>Copy UERANSIM/config/free5gc-gnb.yaml and UERANSIM/config/free5gc-ue.yaml to free5gc-gnb2.yaml and free5gc-ue2.yaml, modify:</p> <p>free5gc-gnb2.yaml</p> <ul> <li>Replace ngapIp from <code>127.0.0.1</code> to <code>10.200.200.3</code></li> <li>Replace gtpIp from <code>127.0.0.1</code> to <code>10.200.200.3</code></li> </ul> <p><pre><code>...\nngapIp: 10.200.200.3 # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\ngtpIp: 10.200.200.3 # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n# List of AMF address information\namfConfigs:\n  - address: 10.200.200.2 # 127.0.0.1\n    port: 38412\n...\n</code></pre> free5gc-ue2.yaml</p> <p><code>supi</code> change to <code>imsi-208930000000004</code></p> <pre><code>...\n# IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000004'\n...\n</code></pre> <p>Note</p> <p>Should register ue to webconsole first.</p> <p>The result: <pre><code>ueransim&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::480f:1eff:fe80:9bbe/64 scope link\n       valid_lft forever preferred_lft forever\n7: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.1/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::f6d7:dd81:fe7f:496a/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\nueransim&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=17.2 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=28.5 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1003ms\nrtt min/avg/max/mdev = 17.200/22.863/28.527/5.663 ms\n</code></pre></p> <pre><code>ueransim2&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n5: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.2/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::16a4:523a:a86:bf83/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\n12: veth2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether fa:12:bb:9c:fa:40 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.3/24 scope global veth2\n       valid_lft forever preferred_lft forever\n    inet6 fe80::f812:bbff:fe9c:fa40/64 scope link\n       valid_lft forever preferred_lft forever\nueransim2&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.2 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=18.9 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=15.8 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 15.786/17.353/18.921/1.567 ms\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#about","title":"About","text":"<p>Hi, my name is Jimmy Chang. The current research topic is 5G LAN with a focus on the 5G Data Plane. Any questions or errors in the article are welcome for correction. Please feel free to send an email to provide feedback.</p> <ul> <li>Graduate student major in 5GC Research</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20230705/1-free5gc-with-namespace/#reference","title":"Reference","text":"<ul> <li>https://github.com/s5uishida/free5gc_ueransim_ulcl_sample_config</li> <li>https://github.com/free5gc/free5gc/blob/main/test_ulcl.sh</li> <li>https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/</li> <li>https://man7.org/linux/man-pages/man7/namespaces.7.html</li> <li>https://linux.die.net/man/8/iptables</li> </ul>"},{"location":"blog/20230712/TSN/","title":"Time-Sensitive Networking over 5G system - Introduction (Rel-16)","text":"<p>Note</p> <p>Author: Ya-shih Tseng Date: 2023/7/12</p> <p>This blog focuses on the role of the 5G system in 3GPP Release 16 TSN (Time-Sensitive Networking).</p>"},{"location":"blog/20230712/TSN/#what-is-time-sensitive-network-tsn","title":"What is Time-Sensitive Network (TSN)","text":"<p>Traditional Ethernet technology can only achieve \"best-effort\" communication and cannot meet the high reliability and low latency requirements of industrial manufacturing applications. Therefore, in the context of industrial automation, there is a need to upgrade the traditional \"best-effort\" Ethernet to provide \"deterministic\" services.</p> <p>Time Sensitive Networking (TSN) brings determinism and real-time communication to standard Ethernet through mechanisms and protocols defined by the IEEE 802.1 standard, which is used by Audio Video Bridging (AVB) and TSN. It offers reliable message delivery, minimized jitter, and guaranteed delivery through central management, time scheduling, and other key features. The introduction of TSN technology holds great potential and benefits for real-time applications in industrial control, automation, and other fields. </p> <p>TSN_OSI_layer</p>"},{"location":"blog/20230712/TSN/#tsn-standard","title":"TSN Standard","text":"<p>There are a lot of standards that TSN task group has completed or ongoing projects. Here are some base standards.</p> Standard Title IEEE 1588 V2 Precision Clock Synchronization Protocol for Networked Measurement and Control Systems IEEE 802.1Q-2022 Bridges and Bridged Networks IEEE 802.1AB-2016 Station and Media Access Control Connectivity Discovery (specifies the Link Layer Discovery Protocol (LLDP)) IEEE 802.1AS-2020 Timing and Synchronization for Time-Sensitive Applications IEEE 802.1AX-2020 Link Aggregation IEEE 802.1CB-2017 Frame Replication and Elimination for Reliability IEEE 802.1CS-2020 Link-local Registration Protocol"},{"location":"blog/20230712/TSN/#the-role-of-5g-system-in-tsn","title":"The role of 5G system in TSN","text":"<p>With the increasing demands for wireless control in applications such as industrial automation, remote surgical operations, smart grid distribution automation, transportation safety, autonomous driving, and more, there is a growing need to meet the low-latency requirements of these applications while achieving management, scheduling, and traffic planning. Time synchronization becomes a critical aspect. The following will explain how the interaction between TSN and 5G systems enables time synchronization.</p>"},{"location":"blog/20230712/TSN/#time-synchronization","title":"Time Synchronization","text":"<p>To achieve time synchronization between TSN and 5G systems, TSN utilizes the time synchronization method defined in IEEE 802.1AS, which is the generalized Precision Time Protocol (gPTP). gPTP supports time synchronization for Time-aware end stations and Time-aware Bridges in Layer 2.  In the 3GPP TS23.501 release 16 specification, the 5G system plays the role of a \"Time-aware system\" as defined in IEEE 802.1AS and is designated as a Logical bridge, connecting TSN system end stations.</p> <p>Note</p> <p>gPTP is an extended version of PTP (Precision Time Protocol) that primarily expands support for second-layer network devices.</p> <p>How can we synchronize the time of two end stations into the same time domain?</p> <p>First, the time synchronization architecture includes Master clocks and Slave clocks. The Master regularly sends sync messages to allow the Slave to obtain the Master's time. The Slave, in turn, periodically sends peer delay requests to exchange messages with the Master, obtaining the delay time between the two devices for time correction. Additionally, the resident time, which is the message propagation delay introduced by bridges, should also be taken into account. By considering all these factors, the time synchronization of both sides can be achieved within the TSN time domain. </p> <p>Time Synchronization process of gPTP</p> <p>Check the link for more detail about how PTP works.</p>"},{"location":"blog/20230712/TSN/#intergration-of-tsn-and-5g","title":"Intergration of TSN and 5G","text":"<p>By now, I believe you have gained an understanding of the time synchronization mechanism in TSN. Let's briefly explain how the 5G system supports TSN as a logical TSN bridge. The 3GPP has defined new functionalities such as NW-TT, DS-TT, and TSN-AF, as well as TSN control nodes like CUC and CNC. Please check TS 23.501 Release 16 for more details. </p> <p>System architecture of 5G support TSN</p>"},{"location":"blog/20230712/TSN/#support-ethernet-type-pdu-session","title":"Support Ethernet type PDU session","text":"<p>To archive the intergration, 5G system should support ingress port and egress port pair via an Ethernet Type PDU session between the corresponding UE and UPF. As mentioned above, gPTP supports layer 2 (Ethernet) only.</p>"},{"location":"blog/20230712/TSN/#ds-tt-and-nw-tt","title":"DS-TT and NW-TT","text":"<p>In the 5G system, DS-TT (Device-side TSN translator) and NW-TT (Network-side TSN translator) serve as TSN translators. DS-TT is responsible for connecting TSN Slave endpoints with the UE, while NW-TT connects TSN Master endpoints with the UPF.</p> <p>When the sync message generated by the Master clock reaches the bridge, NW-TT captures its Ingress Timestamp and measures the delay between NW-TT and the Master clock. These timestamps are then embedded within the sync message and transmitted to the UE. Once the UE receives the sync message, DS-TT calculates the resident time by subtracting the Ingress Timestamp provided in the sync message, from the Egress Timestamp which represents the time of sync message reception. The resident time is added to the delay time mentioned in the sync message to determine the corrected time. Through the assistance of the TSN translators, the Slave endpoint receives the message and obtains information about time deviation and other relevant data for further adjustment.</p> <p>Note</p> <p>DS-TT and NW-TT enable the 5G system to function as a virtual bridge. The bridge is also called \"Transparent clock\" which is definded in IEEE 1588 and required in IEEE 802.1AS. You can say that Master and Slaver don't know the exist of the 5G TSN bridge, since it's logical transparent.</p> <p>\"Transparent clocks are used to route timing messages within a network. Used when: Ethernet timing must pass through switches.\" - different type of clocks</p>"},{"location":"blog/20230712/TSN/#tsn-af","title":"TSN-AF","text":"<p>With TSN-AF, CNC can manage the 5G system functioning as a logical bridge and achieve the integration of the 5G TSN bridge with the TSN network in collaboration with NW-TT and DS-TT. Additionally, TSN-AF gathers information and capability lists of the 5G TSN Bridge and transmits them to CNC.</p>"},{"location":"blog/20230712/TSN/#tsn-control-nodes","title":"TSN control nodes","text":"<p>To meet the requirements of application services and control TSN, there are two key functions utilized in the TSN system. CNC (Centralized Network Controller), as the central controller in the TSN system, receives the information from CUC (Centralized User Configuration) and performs scheduling and planning tasks. It calculates the optimal transmission schedule for the TSN traffic based on factors such as bandwidth requirements, latency constraints, and network conditions. Once the transmission schedule is computed and confirmed, CNC proceeds to deploy the necessary network resource configuration on the TSN switches. This ensures that the TSN network operates efficiently and effectively in delivering the required QoS (Quality of Service) for the application services.</p>"},{"location":"blog/20230712/TSN/#reference","title":"Reference","text":"<ul> <li>IEEE Std 802.1AS-2020: \u201cIEEE Standard for Local and metropolitan area networks--Timing and Synchronization for Time-Sensitive Applications\u201d.</li> <li>IEEE Std 1588: \u201cIEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems\u201d, Edition 2019.</li> <li>3GPP TS 23.501 Release 16</li> <li>Time-Sensitive Networking - Wikipedia</li> <li>Time-Sensitive Networking (TSN) Task Group | - IEEE 802.1</li> </ul>"},{"location":"blog/20230712/TSN/#about","title":"About","text":"<p>Hi, This is Ya-shih Tseng. I am currently researching the implementation of 5G TSN (Time-Sensitive Networking) as part of my master's studies. In the future, I will introduce more information about TSN. Hope you enjoy it.</p>"},{"location":"blog/20230719/UDM_introduce/","title":"Network function UDM introduction","text":"<p>Note</p> <p>Author: \u5f35\u54f2\u777f Date: 2023/7/19</p>"},{"location":"blog/20230719/UDM_introduce/#overview","title":"Overview","text":"<p>In this article, I will introduce UDM and its three services that will be used in the general UE registration procedure (Nudm_UECM service, Nudm_SubscriberDataManagement Service, and Nudm_UEAuthentication service) to let everyone understand UDM more clearly.</p>"},{"location":"blog/20230719/UDM_introduce/#udm","title":"UDM","text":"<p>Unified Data Management is responsible for managing information related to UE. When other NFs need to use the UE subscription information, they will obtain it from UDM through the SBI of UDM.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_ueauthentication-service","title":"Nudm_UEAuthentication Service","text":"<p>This service is used by AUSF to retrieve authentication-related information and, after authentication, confirm the result.</p> <p></p> <p>3GPP TS33.501 v15.2.0</p> <p>In Authentication, AUSF uses the GET operation to retrieve authentication information for the UE. The request contains the UE\u2019s identity (supi or suci) and the serving network name. The serving network name is used in the derivation of the anchor key, which is used by subsensual authentication. UE\u2019s identity will be contained in the URI, and the serving network name will be contained in the request body.</p> <p>Upon reception of the Nudm_UEAuthentication_Get Request, the UDM shall de-conceal SUCI to gain SUPI if SUCI is received. At this time, UDM will query the authentication subscription data from UDR. Then, UDM shall select the authentication method based on SUPI, and if required (e.g., 5G-AKA), UDM will calculate the authentication vector and pass it to AUSF.</p> <ul> <li>SUPI: A globally unique 5G Subscription Permanent Identifier, used to identify UE.</li> <li>SUCI: Subscription concealed identifier, obtained by encrypting supi through the Home Network Public Key so that supi will not be obtained by a third party on the network.</li> </ul> <pre><code>logger.UeauLog.Traceln(\"In GenerateAuthDataProcedure\")\n\nresponse = &amp;models.AuthenticationInfoResult{}\nrand.Seed(time.Now().UnixNano())\nsupi, err := suci.ToSupi(supiOrSuci, udm_context.Getself().SuciProfiles)\nif err != nil {\n    problemDetails = &amp;models.ProblemDetails{\n        Status: http.StatusForbidden,\n        Cause:  authenticationRejected,\n        Detail: err.Error(),\n    }\n\n    logger.UeauLog.Errorln(\"suciToSupi error: \", err.Error())\n    return nil, problemDetails\n}\n\nlogger.UeauLog.Tracef(\"supi conversion =&gt; [%s]\", supi)\n\nclient, err := createUDMClientToUDR(supi)\nif err != nil {\n    return nil, openapi.ProblemDetailsSystemFailure(err.Error())\n}\nauthSubs, res, err := client.AuthenticationDataDocumentApi.QueryAuthSubsData(context.Background(), supi, nil)\n\n//in the udm/internal/sbi/producer/generate_auth_data.go, GenerateAuthDataProcedure function.\n</code></pre> <p>From the code, we can see UDM first de-conceal SUCI (line 5), then use QueryAuthSubsData to get authSub from UDR. After that, UDM uses this information to create the authentication vector.</p> <p>Then we record the packet sent in the registration process and find the packet according to the URI specified by the specification. We can find the packet corresponding to this service.</p> <p></p> <p>Open the response packet, and we can see the response body matches the AuthenticationInfoResult data type.</p> <p></p> <p></p> <p>3GPP TS29.503 v15.2.1</p> <p>After AUSF authenticates the UE, it will confirm the result with UDM. These details will be used in linking authentication confirmation to the Nudm_UECM_Registration procedure from AMF.</p> <pre><code>func communicateWithUDM(ue *context.AmfUe, accessType models.AccessType) error {\n    ue.GmmLog.Debugln(\"communicateWithUDM\")\n    amfSelf := context.GetSelf()\n\n    // UDM selection described in TS 23.501 6.3.8\n    // TODO: consider udm group id, Routing ID part of SUCI, GPSI or External Group ID (e.g., by the NEF)\n    param := Nnrf_NFDiscovery.SearchNFInstancesParamOpts{\n        Supi: optional.NewString(ue.Supi),\n    }\n    resp, err := consumer.SendSearchNFInstances(amfSelf.NrfUri, models.NfType_UDM, models.NfType_AMF, &amp;param)\n    if err != nil {\n        return errors.Errorf(\"AMF can not select an UDM by NRF: SendSearchNFInstances failed\")\n    }\n\n    var uecmUri, sdmUri string\n    for _, nfProfile := range resp.NfInstances {\n        ue.UdmId = nfProfile.NfInstanceId\n        uecmUri = util.SearchNFServiceUri(nfProfile, models.ServiceName_NUDM_UECM, models.NfServiceStatus_REGISTERED)\n        sdmUri = util.SearchNFServiceUri(nfProfile, models.ServiceName_NUDM_SDM, models.NfServiceStatus_REGISTERED)\n        if uecmUri != \"\" &amp;&amp; sdmUri != \"\" {\n            break\n        }\n    }\n    ue.NudmUECMUri = uecmUri\n    ue.NudmSDMUri = sdmUri\n    if ue.NudmUECMUri == \"\" || ue.NudmSDMUri == \"\" {\n        return errors.Errorf(\"AMF can not select an UDM by NRF: SearchNFServiceUri failed\")\n    }\n\n    problemDetails, err := consumer.UeCmRegistration(ue, accessType, true)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"UECM_Registration Error\")\n    }\n\n    // TS 23.502 4.2.2.2.1 14a-c.\n    // \"After a successful response is received, the AMF subscribes to be notified\n    //      using Nudm_SDM_Subscribe when the data requested is modified\"\n    problemDetails, err = consumer.SDMGetAmData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get AmData Error\")\n    }\n\n    problemDetails, err = consumer.SDMGetSmfSelectData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get SmfSelectData Error\")\n    }\n\n    problemDetails, err = consumer.SDMGetUeContextInSmfData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get UeContextInSmfData Error\")\n    }\n\n    problemDetails, err = consumer.SDMSubscribe(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM Subscribe Error\")\n    }\n    ue.ContextValid = true\n    return nil\n}\n\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <p>Next, let's take a look at this function. It is called in HandleInitialRegistration, which handles UE's initial registration. UeCmRegistration will use the Nudm_UECM (UECM) service to store related UE Context Management information in UDM. In lines 40, 47, and 54, AMF uses the Nudm_SubscriberDataManagement (SDM) Service to get some subscribe data.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_uecontextmanagement-service","title":"Nudm_UEContextManagement Service","text":"<p>In the UeCmRegistration function, AMF registers as UE's serving NF on UDM and stores related UE Context Management information in UDM. Looking at the packet, you can see that the request body contains <code>amfInstanceId</code> and <code>guami</code>, representing the amf identity, and <code>ratType</code>, representing the radio access technology type used by UE.</p> <p></p> <pre><code>// TS 29.503 5.3.2.2.2\nfunc RegistrationAmf3gppAccessProcedure(registerRequest models.Amf3GppAccessRegistration, ueID string) (\n    header http.Header, response *models.Amf3GppAccessRegistration, problemDetails *models.ProblemDetails,\n) {\n    // TODO: EPS interworking with N26 is not supported yet in this stage\n    var oldAmf3GppAccessRegContext *models.Amf3GppAccessRegistration\n    if udm_context.Getself().UdmAmf3gppRegContextExists(ueID) {\n        ue, _ := udm_context.Getself().UdmUeFindBySupi(ueID)\n        oldAmf3GppAccessRegContext = ue.Amf3GppAccessRegistration\n    }\n\n    udm_context.Getself().CreateAmf3gppRegContext(ueID, registerRequest)\n\n    clientAPI, err := createUDMClientToUDR(ueID)\n    if err != nil {\n        return nil, nil, openapi.ProblemDetailsSystemFailure(err.Error())\n    }\n\n    var createAmfContext3gppParamOpts Nudr_DataRepository.CreateAmfContext3gppParamOpts\n    optInterface := optional.NewInterface(registerRequest)\n    createAmfContext3gppParamOpts.Amf3GppAccessRegistration = optInterface\n    resp, err := clientAPI.AMF3GPPAccessRegistrationDocumentApi.CreateAmfContext3gpp(context.Background(),\n        ueID, &amp;createAmfContext3gppParamOpts)\n    if err != nil {\n        logger.UecmLog.Errorln(\"CreateAmfContext3gpp error : \", err)\n        problemDetails = &amp;models.ProblemDetails{\n            Status: int32(resp.StatusCode),\n            Cause:  err.(openapi.GenericOpenAPIError).Model().(models.ProblemDetails).Cause,\n            Detail: err.Error(),\n        }\n        return nil, nil, problemDetails\n    }\n    defer func() {\n        if rspCloseErr := resp.Body.Close(); rspCloseErr != nil {\n            logger.UecmLog.Errorf(\"CreateAmfContext3gpp response body cannot close: %+v\", rspCloseErr)\n        }\n    }()\n\n    // TS 23.502 4.2.2.2.2 14d: UDM initiate a Nudm_UECM_DeregistrationNotification to the old AMF\n    // corresponding to the same (e.g. 3GPP) access, if one exists\n    if oldAmf3GppAccessRegContext != nil {\n        deregistData := models.DeregistrationData{\n            DeregReason: models.DeregistrationReason_SUBSCRIPTION_WITHDRAWN,\n            AccessType:  models.AccessType__3_GPP_ACCESS,\n        }\n        callback.SendOnDeregistrationNotification(ueID, oldAmf3GppAccessRegContext.DeregCallbackUri,\n            deregistData) // Deregistration Notify Triggered\n\n        return nil, nil, nil\n    } else {\n        header = make(http.Header)\n        udmUe, _ := udm_context.Getself().UdmUeFindBySupi(ueID)\n        header.Set(\"Location\", udmUe.GetLocationURI(udm_context.LocationUriAmf3GppAccessRegistration))\n        return header, &amp;registerRequest, nil\n    }\n}\n\n//in the udm/internal/sbi/producer/ue_context_management.go\n</code></pre> <p>In the RegistrationAmf3gppAccessProcedure function, UDM first checks whether the context has been established for that UE; if UDM has such a context, it initiates a Nudm_UECM_DeregistrationNotification to the old AMF later. UDM used the received information to create context and stored it in UDR.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_subscriberdatamanagement-sdm-service","title":"Nudm_SubscriberDataManagement (SDM) Service","text":"<p>The SDM service is used to retrieve the UE's individual subscription data relevant to the consumer's NF from the UDM. In the SDMGetAmData function, AMF gets subscription data used in registration and mobility management. In the response packet, AMF got <code>gpsis</code>, <code>subscribedUeAmbr</code>, and <code>nssai</code>.</p> <p></p> <p>The GPSI (Generic Public Subscription Identifier) is used to address a 3GPP subscription in data networks outside the realms of a 3GPP system. It contains either an External ID or an MSISDN \uff08Mobile Subscriber ISDN Number\uff09.The <code>subscribedUeAmbr</code> is The Maximum Aggregated uplink and downlink MBRs (max. bit rate) to be shared across all Non-GBR (non-guaranteed Bit Rate) QoS Flows according to the subscription of the user.</p> <p></p> <p>In the SDMGetSmfSelectData function, AMF gets subscribed S-NSSAIs (Single Network Slice Selection Assistance Information) and Data Network Names for these S-NSSAIs. AMF will use this information to select an SMF that manages the PDU Session.</p> <pre><code>func HandleInitialRegistration(ue *context.AmfUe, anType models.AccessType) error {\n    ue.GmmLog.Infoln(\"Handle InitialRegistration\")\n\n    amfSelf := context.GetSelf()\n\n    // update Kgnb/Kn3iwf\n    ue.UpdateSecurityContext(anType)\n\n    // Registration with AMF re-allocation (TS 23.502 4.2.2.2.3)\n    if len(ue.SubscribedNssai) == 0 {\n        getSubscribedNssai(ue)\n    }\n\n    if err := handleRequestedNssai(ue, anType); err != nil {\n        return err\n    }\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <p>In the initialization of HandleInitialRegistration, AMF sends a request to the UDM to receive the UE's NSSAI (Network Slice Selection Assistance Information). After receiving subscribed NSSAI, AMF will compare it to UE's requested NSSAI. If there is a S-NSSAI that has not been subscribed before, AMF will request NSSF for Allowed NSSAI.</p> <pre><code>func handleRequestedNssai(ue *context.AmfUe, anType models.AccessType) error {\n    amfSelf := context.GetSelf()\n\n    if ue.RegistrationRequest.RequestedNSSAI != nil {\n        requestedNssai, err := nasConvert.RequestedNssaiToModels(ue.RegistrationRequest.RequestedNSSAI)\n        if err != nil {\n            return fmt.Errorf(\"Decode failed at RequestedNSSAI[%s]\", err)\n        }\n\n        needSliceSelection := false\n        for _, requestedSnssai := range requestedNssai {\n            ue.GmmLog.Infof(\"RequestedNssai - ServingSnssai: %+v, HomeSnssai: %+v\",\n                requestedSnssai.ServingSnssai, requestedSnssai.HomeSnssai)\n            if ue.InSubscribedNssai(*requestedSnssai.ServingSnssai) {\n                allowedSnssai := models.AllowedSnssai{\n                    AllowedSnssai: &amp;models.Snssai{\n                        Sst: requestedSnssai.ServingSnssai.Sst,\n                        Sd:  requestedSnssai.ServingSnssai.Sd,\n                    },\n                    MappedHomeSnssai: requestedSnssai.HomeSnssai,\n                }\n                if !ue.InAllowedNssai(*allowedSnssai.AllowedSnssai, anType) {\n                    ue.AllowedNssai[anType] = append(ue.AllowedNssai[anType], allowedSnssai)\n                }\n            } else {\n                needSliceSelection = true\n                break\n            }\n        }\n\n        if needSliceSelection {\n            if ue.NssfUri == \"\" {\n                for {\n                    err := consumer.SearchNssfNSSelectionInstance(ue, amfSelf.NrfUri, models.NfType_NSSF, models.NfType_AMF, nil)\n                    if err != nil {\n                        ue.GmmLog.Errorf(\"AMF can not select an NSSF Instance by NRF[Error: %+v]\", err)\n                        time.Sleep(2 * time.Second)\n                    } else {\n                        break\n                    }\n                }\n            }\n\n            // Step 4\n            problemDetails, err := consumer.NSSelectionGetForRegistration(ue, requestedNssai)\n            if problemDetails != nil {\n                ue.GmmLog.Errorf(\"NSSelection Get Failed Problem[%+v]\", problemDetails)\n                gmm_message.SendRegistrationReject(ue.RanUe[anType], nasMessage.Cause5GMMProtocolErrorUnspecified, \"\")\n                return fmt.Errorf(\"Handle Requested Nssai of UE failed\")\n            } else if err != nil {\n                ue.GmmLog.Errorf(\"NSSelection Get Error[%+v]\", err)\n                gmm_message.SendRegistrationReject(ue.RanUe[anType], nasMessage.Cause5GMMProtocolErrorUnspecified, \"\")\n                return fmt.Errorf(\"Handle Requested Nssai of UE failed\")\n            }\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <pre><code>if param.SliceInfoRequestForRegistration.RequestedNssai != nil &amp;&amp;\n    len(param.SliceInfoRequestForRegistration.RequestedNssai) != 0 {\n    // Requested NSSAI is provided\n    // Verify which S-NSSAI(s) in the Requested NSSAI are permitted based on comparing the Subscribed S-NSSAI(s)\n    if param.Tai != nil &amp;&amp;\n        !util.CheckSupportedNssaiInPlmn(param.SliceInfoRequestForRegistration.RequestedNssai, *param.Tai.PlmnId) {\n        // Return ProblemDetails indicating S-NSSAI is not supported\n        // TODO: Based on TS 23.501 V15.2.0, if the Requested NSSAI includes an S-NSSAI that is not valid in the\n        //       Serving PLMN, the NSSF may derive the Configured NSSAI for Serving PLMN\n        *problemDetails = models.ProblemDetails{\n            Title:  util.UNSUPPORTED_RESOURCE,\n            Status: http.StatusForbidden,\n            Detail: \"S-NSSAI in Requested NSSAI is not supported in PLMN\",\n            Cause:  \"SNSSAI_NOT_SUPPORTED\",\n        }\n\n        status = http.StatusForbidden\n        return status\n    }\n\n    // Check if any Requested S-NSSAIs is present in Subscribed S-NSSAIs\n    checkIfRequestAllowed := false\n\n    for _, requestedSnssai := range param.SliceInfoRequestForRegistration.RequestedNssai {\n        if param.Tai != nil &amp;&amp; !util.CheckSupportedSnssaiInTa(requestedSnssai, *param.Tai) {\n            // Requested S-NSSAI does not supported in UE's current TA\n            // Add it to Rejected NSSAI in TA\n            authorizedNetworkSliceInfo.RejectedNssaiInTa = append(\n                authorizedNetworkSliceInfo.RejectedNssaiInTa,\n                requestedSnssai)\n            continue\n        }\n\n        var mappingOfRequestedSnssai models.Snssai\n        // TODO: Compared with Restricted S-NSSAI list in configuration under roaming scenario\n        if param.HomePlmnId != nil &amp;&amp; !util.CheckStandardSnssai(requestedSnssai) {\n            // Standard S-NSSAIs are supported to be commonly decided by all roaming partners\n            // Only non-standard S-NSSAIs are required to find mappings\n            targetMapping, found := util.FindMappingWithServingSnssai(requestedSnssai,\n                param.SliceInfoRequestForRegistration.MappingOfNssai)\n\n            if !found {\n                // No mapping of Requested S-NSSAI to HPLMN S-NSSAI is provided by UE\n                // TODO: Search for local configuration if there is no provided mapping from UE, and update UE's\n                //       Configured NSSAI\n                checkInvalidRequestedNssai = true\n                authorizedNetworkSliceInfo.RejectedNssaiInPlmn = append(\n                    authorizedNetworkSliceInfo.RejectedNssaiInPlmn,\n                    requestedSnssai)\n                continue\n            } else {\n                // TODO: Check if mappings of S-NSSAIs are correct\n                //       If not, update UE's Configured NSSAI\n                mappingOfRequestedSnssai = *targetMapping.HomeSnssai\n            }\n        } else {\n            mappingOfRequestedSnssai = requestedSnssai\n        }\n\n        hitSubscription := false\n        for _, subscribedSnssai := range param.SliceInfoRequestForRegistration.SubscribedNssai {\n            if mappingOfRequestedSnssai == *subscribedSnssai.SubscribedSnssai {\n                // Requested S-NSSAI matches one of Subscribed S-NSSAI\n                // Add it to Allowed NSSAI list\n                hitSubscription = true\n\n                var allowedSnssaiElement models.AllowedSnssai\n                allowedSnssaiElement.AllowedSnssai = new(models.Snssai)\n                *allowedSnssaiElement.AllowedSnssai = requestedSnssai\n                nsiInformationList := util.GetNsiInformationListFromConfig(requestedSnssai)\n                if nsiInformationList != nil {\n                    // TODO: `NsiInformationList` should be slice in `AllowedSnssai` instead of pointer of slice\n                    allowedSnssaiElement.NsiInformationList = append(\n                        allowedSnssaiElement.NsiInformationList,\n                        nsiInformationList...)\n                }\n                if param.HomePlmnId != nil &amp;&amp; !util.CheckStandardSnssai(requestedSnssai) {\n                    allowedSnssaiElement.MappedHomeSnssai = new(models.Snssai)\n                    *allowedSnssaiElement.MappedHomeSnssai = *subscribedSnssai.SubscribedSnssai\n                }\n\n                // Default Access Type is set to 3GPP Access if no TAI is provided\n                // TODO: Depend on operator implementation, it may also return S-NSSAIs in all valid Access Type if\n                //       UE's Access Type could not be identified\n                var accessType models.AccessType = models.AccessType__3_GPP_ACCESS\n                if param.Tai != nil {\n                    accessType = util.GetAccessTypeFromConfig(*param.Tai)\n                }\n\n                util.AddAllowedSnssai(allowedSnssaiElement, accessType, authorizedNetworkSliceInfo)\n\n                checkIfRequestAllowed = true\n                break\n            }\n        }\n\n        if !hitSubscription {\n            // Requested S-NSSAI does not match any Subscribed S-NSSAI\n            // Add it to Rejected NSSAI in PLMN\n            checkInvalidRequestedNssai = true\n            authorizedNetworkSliceInfo.RejectedNssaiInPlmn = append(\n                authorizedNetworkSliceInfo.RejectedNssaiInPlmn,\n                requestedSnssai)\n        }\n    }\n\n    if !checkIfRequestAllowed {\n        // No S-NSSAI from Requested NSSAI is present in Subscribed S-NSSAIs\n        // Subscribed S-NSSAIs marked as default are used\n        useDefaultSubscribedSnssai(param, authorizedNetworkSliceInfo)\n    }\n} else {\n    // No Requested NSSAI is provided\n    // Subscribed S-NSSAIs marked as default are used\n    checkInvalidRequestedNssai = true\n    useDefaultSubscribedSnssai(param, authorizedNetworkSliceInfo)\n}\n\n//in the nssf/internal/sbi/producer/nsselection_for_registration.go, nsselectionForRegistration funcion.\n</code></pre> <p>If NSSF needs to select S-NSSAI, it first finds the mapping of requested NSSAI to configured NSSAI for the HPLMN and converts requested S-NSSAI to S-NSSAI in configured NSSAI for the HPLMN. Then compare these S-NSSAIs with Subscribed S-NSSAIs; if NSSF find one match, set it as <code>AllowedSnssai</code>. If NSSF can't find such a mapping or no S-NSSAI in the mapping matches subscribed S-NSSAIs, it will use default subscribed S-NSSAIs.</p>"},{"location":"blog/20230719/UDM_introduce/#reference","title":"Reference","text":"<ul> <li>3GPP TS29.503 v15.2.1</li> <li>3GPP TS23.502 v15.2.0</li> <li>3GPP TS23.501 v15.2.0</li> <li>3GPP TS33.501 v15.2.0</li> <li>free5GC v3.3.0</li> </ul>"},{"location":"blog/20230719/UDM_introduce/#about","title":"About","text":"<p>Hello! My name is \u5f35\u54f2\u777f, and my current research topic is ATSSS (Access Traffic Steering, Switching and Splitting), I will continue to write articles related to 5G networks in the future. If you find any mistakes in my articles or have any topics you want to know about, please contact me.</p> <ul> <li>Linkedln</li> </ul>"},{"location":"blog/20230726/network_slice/","title":"How to deploy a free5GC network slice on OpenStack","text":"<p>Note</p> <p>Author: Daniel Hsieh Date: 2023/7/26</p>"},{"location":"blog/20230726/network_slice/#whats-network-slicing","title":"What's Network Slicing","text":"<p>Network slicing allows for the creation of multiple logical, isolated, and independent virtual networks that can coexist within a shared physical infrastructure. Each network slice provides dedicated and customized network resources to meet the specific requirements of different services The main elements of a network slice include:</p> <ul> <li> <p>Virtualized Network Functions (VNFs): Each network slice can include a set of virtualized network functions that provide specific network capabilities and services. These VNFs can include functions like routing, switching, firewalling, load balancing, or any other network service required by the slice.</p> </li> <li> <p>Isolation and Resource Allocation: Network slicing ensures the isolation of resources between slices, preventing interference and conflicts. It allows for the allocation of dedicated and optimized resources such as bandwidth, processing power, and storage to each slice based on its specific needs.</p> </li> <li> <p>Orchestration and Management: Network slice orchestration involves the creation, provisioning, and management of network slices. It involves configuring the appropriate VNFs, assigning resources, and establishing connectivity between the different components of a slice.</p> </li> </ul> <p></p> <p>NFV Enabling Network Slicing for 5G</p> <p>Take Figure 1 as an example. The first slice is designed for mobile devices such as smartphones. Such slice requires a huge diversity of VNFs, and virtual links with high speed and low latency to support the broadband service of smartphones. In 5G network, Those slices are referred to as eMBB (enhanced mobile broadband) slices.</p> <p>The second slice is designed for autonomous driving. In such scenario, extremely low latency and high reliability are paramount to ensure the vehicles' operability, smoothness and safety. To achieve low latency, some of the NFs should be deployed close to the access node,i.e. on edge cloud. To achieve high reliability, a NF should have multiple instances on available physical resources to make the slice more fault tolerant. Such slice is referred to as URLLC (Ultra-Reliable Low-Latency Communications) slice.</p> <p>The third slice is designed for massive IoT. IoT devices are expected to not move and send very small amount of data intermittently. Due to the nature of such devices, functions that handle mobiltiy and always-on connections are not needed. Such slices are referred to as mIoT (massive IoT) slices.</p>"},{"location":"blog/20230726/network_slice/#mano-architecture","title":"MANO Architecture","text":"<p>In this article, we utilize MANO network function virtualization (NFV) architecture to deploy virtual network function (VNF). It plays the role of creating, deploying, and managing VNFs. MANO consists of three main functional components: NFV Orchestrator (NFVO), Virtualized Infrastructure Manager (VIM), and Virtual Network Function Manager (VNFM).</p> <p></p> <p>NFV MANO Architecture</p> <ul> <li> <p>NFVO manages the underlying resource by coordinating VIM and VNFM. It handles tasks such as receiving requests, service instantiation, scaling, termination, and monitoring.</p> </li> <li> <p>VNFM manages the lifecycle of VNF instances. It interacts with the VIM to instantiate, configure, monitor, and terminate VNF instances.</p> </li> <li> <p>VIM is responsible for managing the underlying virtualized infrastructure that hosts the VNFs. It abstracts the physical resources, such as compute, storage, and networking, and provides a unified view to the NFVO. The VIM handles tasks like resource allocation, performance monitoring, fault management, and virtualization management.</p> </li> </ul> <p>For VIM, we use OpenStack, an open-source software that provides IaaS, to utilize the physical resources. For VNFM and NFVO, we use Tacker, a service component of OpenStack, to manage VNFs.</p>"},{"location":"blog/20230726/network_slice/#openstack","title":"OpenStack","text":"<p>OpenStack is an open-source cloud computing platform that provides a set of software tools for building and managing customized clouds. OpenStack offers a infrastructure-as-a-service (IaaS) solution, enabling organizations to create and manage virtualized resources in a cloud environment. It is designed to be modular and consists of various components that work together to deliver a comprehensive cloud computing platform. Some of the key components include:</p> <ul> <li> <p>Nova: Nova is the computing component of OpenStack and serves as the main compute engine. It manages the creation, scheduling, and management of virtual machines (VMs) and provides APIs for controlling and interacting with the compute resources.</p> </li> <li> <p>Cinder: Cinder is the block storage component of OpenStack. It provides persistent storage for virtual machines. With Cinder, users can create and manage volumes that can be attached to instances, allowing for flexible and scalable storage options.</p> </li> <li> <p>Neutron: Neutron is the networking component of OpenStack. It provides a networking-as-a-service (NaaS) solution, allowing users to define and manage network resources. Neutron supports virtual LANs, software-defined networking (SDN), and network function virtualization (NFV), etc.</p> </li> <li> <p>Keystone: Keystone is the identity service component of OpenStack. It provides authentication and authorization services, enabling users to securely access and manage resources within the cloud. Keystone supports multiple authentication mechanisms, including username/password, token-based, and external identity providers.</p> </li> <li> <p>Horizon: Horizon is the web-based dashboard for OpenStack. It provides a user-friendly interface for managing and monitoring the cloud infrastructure. With Horizon, users can perform various tasks, such as launching instances, managing storage resources, and configuring networking options.</p> </li> </ul> <p></p> <p>OpenStack Architecture</p> <p>OpenStack is highly flexible and customizable, allowing organizations to tailor the cloud infrastructure to their specific needs. It supports multiple hypervisors, including KVM, VMware, and Hyper-V.</p>"},{"location":"blog/20230726/network_slice/#tacker","title":"Tacker","text":"<p>To enable NFV, we need another service component of OpenStack called Tacker. Tacker is designed to simplify the deployment and lifecycle management of VNFs and network service functions (NSFs) in a cloud infrastructure. It leverages OpenStack's existing components, such as Nova, Neutron, and Heat, to provide a comprehensive solution for network service orchestration. Tacker provides several key features and functionalities:</p> <ul> <li> <p>Service Templates: Tacker uses service templates to define the composition and behavior of network services. These templates describe the VNFs and NSFs involved, their interconnections, resource requirements, etc. Service templates are written using the TOSCA (Topology and Orchestration Specification for Cloud Applications) standard.</p> </li> <li> <p>Lifecycle Management: Tacker automates the entire lifecycle of network services, including provisioning, scaling, healing, and termination. It leverages Heat, OpenStack's orchestration service, to manage the underlying infrastructure resources required by the services and handle dynamic scaling of VNFs based on traffic demands.</p> </li> <li> <p>VNF Manager: Tacker includes a VNF Manager component responsible for managing the lifecycle of VNFs. It interacts with OpenStack's compute and networking services, to instantiate and manage VNF instances.</p> </li> <li> <p>Multi-VIM Support: Tacker supports multiple virtual infrastructure managers  to accommodate different cloud platforms and environments. It can interact with OpenStack, VMware vSphere and Kubernetes and so on, enabling operators to deploy network services across heterogeneous infrastructure environments.</p> </li> </ul> <p></p> <p>Tacker Architecture</p>"},{"location":"blog/20230726/network_slice/#deploy-a-free5gc-network-slice","title":"Deploy a free5GC Network Slice","text":"<ol> <li> <p>In our implementation, we install OpenStack and Tacker on two different virtual machines for resource utilization reasons, but in fact, they can be installed on the same virtual machine.</p> </li> <li> <p>we need to install OpenStack on a virtual machine. Specific details and corresponding compatibility can be found on OpenStack official website. Using devstack scripts for installation enables operators to customize the environment based on their needs, such as extra plugins (softwares that extends the functionality of OpenStack environment) and overcommit (allows deploying NFs that require more resource than existing physical resourcce) functionality. Upon completion, a web UI enabled by Horizon can be used  to access and operate on your own personalized OpenStack cloud. </p> </li> <li> <p>Install Tacker on another virtual machine, which requires four OpenStack service components, Keystone, Mistral, Barbican and Horizon. Once the installation is completed, we can register our OpenStack VIM on Tacker using <code>openstack vim register</code>command.</p> </li> <li> <p>Create two instances that will be used as images (one for control plane VNFs, one for UPF) for the VNFs that we will create. Then, <code>ssh</code> into those instances to set up the configurations for the VNFs, such as, installing required packages (go language, mongodb, libtool, etc.) and <code>git clone</code> free5GC source code. Once all the configurations are done, use OpenStack dashboard to take snapshots of these instances, which will be used as the images for VNFs.</p> </li> <li> <p>Import all the VNF descriptors (VNFD) of the VNFs we need by using <code>openstack vnf descriptor create</code> command. VNFDs should be written in accordance with TOSCA format. TOSCA format allows you to define the virtual links (a virtual network VNFs will be running in) and virtual deployment unit (operation unit of a VNF).     Below is an example of UPF VNFD: <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\ndescription: description\nnode_types:\n  tosca.nodes.nfv.VNF11:\n    requirements:\n    - virtualLink1:\n        type: tosca.nodes.nfv.VL\n        required: true\nmetadata:\n  template_name: free5GCSetup\ntopology_template:\n  substitution_mappings:\n    node_type: tosca.nodes.nfv.VNF11\n  node_templates:\n    VDU1:\n      type: tosca.nodes.nfv.VDU.Tacker\n      properties:\n        name: free5gc-upf1-VNF\n        image: stage3-up\n        flavor: free5gc\n        availability_zone: nova\n        mgmt_driver: noop\n        key_name: free5gc\n        user_data_format: RAW\n        user_data: |\n          #!/bin/sh\n          cd /home/ubuntu/free5gc/src/upf/build\n          cat &gt; config/upfcfg.yaml &lt;&lt;- EOM\n          info:\n            version: 1.0.0\n            description: UPF configuration\n\n          configuration:\n            # debugLevel: panic|fatal|error|warn|info|debug|trace\n            debugLevel: info\n\n            pfcp:\n              - addr: 192.168.2.111\n\n            gtpu:\n              - addr: 192.168.2.111\n              # [optional] gtpu.name\n              # - name: upf.5gc.nctu.me\n              # [optional] gtpu.ifname\n              # - ifname: gtpif\n\n            apn_list:\n              - apn: internet\n                cidr: 60.60.0.0/24\n                # [optional] apn_list[*].natifname\n                # natifname: eth0\n          EOM\n          #sudo ./bin/free5gc-upfd -f config/upfcfg.yaml\n\n    CP1:\n      type: tosca.nodes.nfv.CP.Tacker\n      properties:\n        ip_address: 192.168.2.111\n        management: true\n      requirements:\n      - virtualLink:\n          node: VL1\n      - virtualBinding:\n          node: VDU1\n    VL1:\n      type: tosca.nodes.nfv.VL\n      properties:\n        network_name: 5GC\n        vendor: Tacker\n    FIP1:\n      type: tosca.nodes.network.FloatingIP\n      properties:\n        floating_network: public\n        floating_ip_address: 172.24.4.111\n      requirements:\n      - link:\n          node: CP1\n</code></pre></p> </li> <li>Import the network service descriptor (NSD) using <code>openstack ns descriptor create</code> command. The NSD should also be written in accordance with TOSCA format. Once all the VNFDs and NSD are all successfully imported, we can use <code>openstack ns create</code> to deploy the network slice. The VNFs specified in the NSD will also be instantiated along with the network slice. Their instances can be viewed on OpenStack dashboard enabled by Horizon or just use <code>openstack vnf list</code> to check the status of the VNFs.     Below is an example of NSD <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\ndescription: Import Common Slice VNFDs (already on-boarded)\nimports:\n  - mongo\n  - nrf\n  - amf\n  - smf\n  - udr\n  - pcf\n  - udm\n  - nssf\n  - ausf\ntopology_template:\n  node_templates:\n    VNF0:\n      type: tosca.nodes.nfv.VNF0\n    VNF1:\n      type: tosca.nodes.nfv.VNF1\n    VNF2:\n      type: tosca.nodes.nfv.VNF2\n    VNF3:\n      type: tosca.nodes.nfv.VNF3\n    VNF4:\n      type: tosca.nodes.nfv.VNF4\n    VNF5:\n      type: tosca.nodes.nfv.VNF5\n    VNF6:\n      type: tosca.nodes.nfv.VNF6\n    VNF7:\n      type: tosca.nodes.nfv.VNF7\n    VNF8:\n      type: tosca.nodes.nfv.VNF8\n</code></pre></li> <li><code>ssh</code> into the VNF instances to make the necessary configuration for each VNF and start the free5GC VNF.</li> <li>Voila! Now we have a fully functional free5GC network slice.</li> </ol> <p>There are many other ways to set up a network slice. For example, we can deploy VNFs of the same network slice on different VIMs, or we can deploy all the network slices on the same VIM, as long as it is specified in the VNFDs.</p>"},{"location":"blog/20230726/network_slice/#about","title":"About","text":"<p>Hi, my name is Daniel Hsieh. I am a CS major graduate student. My research field is network slicing. If there are any questions about the article, please feel free to contact.</p> <ul> <li>email: e657shai@gmail.com</li> </ul>"},{"location":"blog/20230726/network_slice/#reference","title":"Reference","text":"<ul> <li> <p>https://www.acecloudhosting.com/blog/openstack-the-catalyst-of-the-public-cloud-market/</p> </li> <li> <p>https://telcocloudbridge.com/blog/a-beginners-guide-to-nfv-management-orchestration-mano/</p> </li> <li> <p>https://wiki.openstack.org/wiki/Tacker</p> </li> <li> <p>B. Chatras, U. S. Tsang Kwong and N. Bihannic, \"NFV enabling network slicing for 5G,\" 2017 20th Conference on Innovations in Clouds, Internet and Networks (ICIN), Paris, France, 2017, pp. 219-225, doi: 10.1109/ICIN.2017.7899415.</p> </li> </ul>"},{"location":"blog/20230802/20230802/","title":"Authentication Mechanism in NRF: What Is OAuth?","text":"<p>Note</p> <p>Author: Wilson Date: 2023/8/2</p>"},{"location":"blog/20230802/20230802/#abstract","title":"Abstract","text":"<p>Regarding the theme this time, I will briefly introduce OAuth. OAuth 2.0 defines four types of authorization flows. I choose the Client Credentials Flow to explain because the authentication mechanism in NRF is closely related to the Client Credentials Flow.</p> <p>Next, I will explain how to apply the concept of the Client Credentials Flow to NRF and introduce <code>Nnrf_AccessToken Service</code>, because <code>Nnrf_AccessToken Service</code> is closely related to the Client Credentials Flow.</p> <p>Finally, I will make a simple experiment of the authentication mechanism in NRF and share the environment settings and methods of operation.</p>"},{"location":"blog/20230802/20230802/#oauth","title":"OAuth","text":"<p>Before explaining the authentication mechanism in NRF, I will introduce OAuth. Regarding the OAuth flow, we can log in to the account through the platform before accessing an application. After logging in, we agree that an application can limitedly obtain the information of the user on the platform. The application can be LinkedIn, YouTube, etc. The platform can be Google, Facebook, etc.</p> <p>The full English name of OAuth is Open standard Authorization. OAuth is an open standard, and it's used to deal with authorization-related behaviors. OAuth 2.0 defines four types of authorization flows. The four types of the authorization flows are:</p> <ul> <li>Authorization Code</li> <li>Implicit</li> <li>Resource Owner Password Credentials</li> <li>Client Credentials</li> </ul> <p>This article explains the entire authorization of the Client Credentials Flow only, because the authentication mechanism in NRF adopts the Client Credentials.</p> <p>If you're interested in how authorization mechanism works, please refer to this article for more details.</p>"},{"location":"blog/20230802/20230802/#client-credentials-flow","title":"Client Credentials Flow","text":"<p> Figure 1. Client Credentials Flow</p> <p>Referring to the Figure 1, the Client Credentials Flow is mainly composed of:</p> <ul> <li>Client</li> <li>Authorization Server</li> <li>Resource Server</li> </ul> <p>The entire authorization of the Client Credentials Flow can be devided into 3 steps:</p> <ul> <li>First, the Client provdies Client ID, Client Secret Token, Scope, and Grant Type to the Authorization Server.</li> <li>Second, the Authorization Server verifies the information provided by the Client. After the Authorization Server verifies the information, it signs with the private key and sends the Access Token to the Client.</li> <li>Third, the Client obtains resources from the Resource Server with the Access Token.</li> </ul> <p>In addition, the Client and the Authorization Server have their own Scope list. The Scope list records a series of the actions. The Client or the Authorization Server is permitted to do the actions for obtaining the user\u2019s name, deleting posts, etc.</p> <p>Below I will explain how to apply the Client Credentials Flow to NRF after talking about the Client Credentials Flow.</p>"},{"location":"blog/20230802/20230802/#client-credentials-flow-in-nrf","title":"Client Credentials Flow in NRF","text":"<p>The Figure 2 and the Figure 3 originate from the Figure 13.4.1.1-1 and the Figure 13.4.1.1-2 of the TS 33.501.</p> <p> Figure 2. NF Service Consumer Obtaining Access Token before NF Service Access</p> <p>The entire flow in Figure 2 is the same as Step 1 and Step 2 in the Figure 1. The role of the Client is played by the NF Service Consumer, and the role of the Authorization Server is played by the NRF.</p> <p>First, the NF Service Consumer registers with NRF. Then the NF Service Consumer sends the <code>Nnrf_AccessToken_Get Request</code> to NRF. The <code>Nnrf_AccessToken_Get Request</code> includes:</p> <ul> <li>Consumer NF Type</li> <li>Expected NF Type</li> <li>Expected NF Service Name</li> <li>Client ID</li> </ul> <p>The NF Type can be AMF, SMF, etc. , and the NF Service Name can be <code>namf-comm</code>, <code>nsmf-pdusession</code>, etc.</p> <p>NRF verifies the information provided by the NF Service Consumer after it receives the <code>Nnrf_AccessToken_Get Request</code>. NRF generates an Access Token and uses the NRF private key to sign on the Access Token after the verification is successful.</p> <p>Finally, NRF returns the <code>Nnrf_AccessToken_Get Response</code> to the NF Service Consumer. The NF Service Consumer stores the Access Token within the validity period after it gets the Access Token. The services provided by the NF Service Producer are in the Expected NF Service Name. The NF Service Consumer doesn\u2019t need to verify again when it wants to use the services provided by the NF Service Producer.</p> <p> Figure 3. NF Service Consumer Requesting Service Access with an Access Token</p> <p>The entire flow in Figure 3 is the same as Step 3 in the Figure 1. The role of the Client is played by the NF Service Consumer, and the role of the Resource Server is played by the NF Service Producer.</p> <p>First, the NF Service Consumer sends the <code>NF Service Request</code> to the NF Service Producer with the Access Token. Simply put, the NF Service Consumer wants to consume the service provided by the NF Service Producer.</p> <p>The NF Service Producer uses the NRF public key to verify the signed Access Token after it receives the <code>NF Service Request</code>. If the verification is successful, the NF Service Producer will send the <code>NF Service Response</code> to the NF Service Consumer.</p> <p>Now I will talk about the <code>Nnrf_AccessToken Service</code> after explaining how to apply the Client Credentials Flow to NRF.</p>"},{"location":"blog/20230802/20230802/#nnrf_accesstoken-service","title":"Nnrf_AccessToken Service","text":"<p> Figure 4. Access Token Request</p> <p>The Figure 4 originates from the Figure 5.4.2.2.1-1 of the TS 29.510.</p> <p>First, the NF Service Consumer sends the POST <code>/oauth2/token</code> to NRF, and the data is stored in the <code>AccessTokenReq</code>. The attribute name, the data type, and the formulation rule of the <code>AccessTokenReq</code> are shown in the Table 1. The Table 1 originates from the Table 6.3.5.2.2-1 of the TS 29.510.</p> <p> Table 1. Definition of Type AccessTokenReq</p> <p>Definition of type <code>AccessTokenReq</code>:</p> <ul> <li><code>grant_type</code>: The value must be set to the client_credentials, and it is checked in the Snippet 1.</li> <li><code>nfInstanceId</code>: The value stores the ID of the NF Service Consumer.</li> <li><code>targetNfInstanceId</code>: The value stores the ID of the NF Service Producer.</li> <li><code>nfType</code>: The value stores the network function name of the NF Service Consumer. The network function name can be the AMF, SMF, etc.</li> <li><code>targetNfType</code>: The value stores the network function name of the NF Service Producer.</li> <li><code>scope</code>: It stores the services. The services can be the <code>namf-comm</code>, <code>nsmf-pdusession</code>, etc. When the NF Service Consumer requests the services. The services will be provided by the NF Service Producer.</li> <li><code>requesterPlmn</code>: It is mainly used in the roaming.</li> <li><code>targetPlmn</code>: It is mainly used in the roaming.</li> </ul> <p><pre><code>if reqGrantType != \"client_credentials\" {\n    return &amp;models.AccessTokenErr{\n        Error: \"unsupported_grant_type\",\n    }\n}\n</code></pre> Snippet 1. Grant Type Value Checking</p> <p>NRF sends <code>AccessTokenRsp</code> to the NF Service Consumer in the Step 2a of the Figure 4. The attribute name, the data type, and the formulation rule of the <code>AccessTokenRsp</code> are shown in the Table 2. The Table 2 originates from the Table 6.3.5.2.3-1 of the TS 29.510.</p> <p> Table 2. Definition of Type AccessTokenRsp</p> <p>The <code>AccessTokenRsp</code> contains four attribute names. The four attribute names are:</p> <ul> <li><code>access_token</code>: It stores all the attribute names and values of the AccessTokenClaims in the Table 3. The Table 3 originates form the Table 6.3.5.2.4-1 of the TS 29.510.</li> <li><code>token_type</code>: It must be set to the Bearer and can be seen in the Snippet 2.</li> <li><code>expires_in</code>: It stores information related to the expiration date.</li> <li><code>scope</code>: The NF Service Consumer and the NF Service Producer have their own scope list. The scope in the <code>AccessTokenRsp</code> has a series of these services, and the NF Service Producer is permitted to consume these services.</li> </ul> <p> Table 3. Definition of Type AccessTokenClaims</p> <p>Definition of Type <code>AccessTokenClaims</code>:</p> <ul> <li><code>iss</code>: It is called issuer, and the content usually stores the ID of NRF.</li> <li><code>sub</code>: It is called subject, and the content stores the ID of the NF Service Consumer.</li> <li><code>aud</code>: It is called audience, and the content stores the ID of the NF Service Producer.</li> <li><code>scope</code>: The scope in the <code>AccessTokenClaims</code> has a series of these services, and the NF Service Consumer is authorized by the NF Service Producer and permitted to consume these services.</li> <li><code>exp</code>: It stores information related to the validity period.</li> </ul> <p><pre><code>func AccessTokenProcedure(request models.AccessTokenReq) (\n    *models.AccessTokenRsp, *models.AccessTokenErr,\n) {\n    logger.AccTokenLog.Infoln(\"In AccessTokenProcedure\")\n\n    var expiration int32 = 1000\n    scope := request.Scope\n    tokenType := \"Bearer\"\n    now := int32(time.Now().Unix())\n\n    errResponse := AccessTokenScopeCheck(request)\n    if errResponse != nil {\n        return nil, errResponse\n    }\n\n    // Create AccessToken\n    nrfCtx := nrf_context.GetSelf()\n    accessTokenClaims := models.AccessTokenClaims{\n        Iss:            nrfCtx.Nrf_NfInstanceID,    // NF instance id of the NRF\n        Sub:            request.NfInstanceId,       // nfInstanceId of service consumer\n        Aud:            request.TargetNfInstanceId, // nfInstanceId of service producer\n        Scope:          request.Scope,              // TODO: the name of the NF services for which the\n        Exp:            now + expiration,           // access_token is authorized for use\n        StandardClaims: jwt.StandardClaims{},\n    }\n    accessTokenClaims.IssuedAt = int64(now)\n\n    // Use NRF private key to sign AccessToken\n    token := jwt.NewWithClaims(jwt.GetSigningMethod(\"RS512\"), accessTokenClaims)\n    accessToken, err := token.SignedString(nrfCtx.NrfPrivKey)\n    if err != nil {\n        logger.AccTokenLog.Warnln(\"Signed string error: \", err)\n        return nil, &amp;models.AccessTokenErr{\n            Error: \"invalid_request\",\n        }\n    }\n\n    response := &amp;models.AccessTokenRsp{\n        AccessToken: accessToken,\n        TokenType:   tokenType,\n        ExpiresIn:   expiration,\n        Scope:       scope,\n    }\n    return response, nil\n}\n</code></pre> Snippet 2. AccessTokenProcedure Function</p> <p>The Snippet 2 is the <code>AccessTokenProcedure()</code> function. The function is executed in NRF.</p> <p>The function mainly processes:</p> <ol> <li>The NRF receives the <code>AccessTokenReq</code> sent by the NF Service Consumer.</li> <li>The function calls the <code>AccessTokenScopeCheck()</code> function. The <code>AccessTokenScopeCheck()</code> function checks whether the content of the attribute name in the <code>AccessTokenReq</code> complies with the requirements of the TS 29.510. If not, the <code>AccessTokenProcedure()</code> function immediately returns the <code>AccessTokenErr</code> to the NF Service Consumer.</li> <li>The function starts to create the Access Token. The Access Token is stored in the <code>AccessTokenRsp</code>. The <code>AccessTokenRsp</code> is sent back to the NF Service Consumer. The <code>Iss</code> in the AccessToken obtains its own ID in NRF. The <code>Sub</code> and <code>Aud</code> are obtained from the <code>NfInstancedId</code> and the <code>TargetNfInstanceId</code> in the <code>AccessTokenReq</code> respectively. The <code>Scope</code> is obtained from the <code>scope</code> in the <code>AccessTokenReq</code>. The expiration is set to the 1000 in the Snippet 2. Therefore, the value of the <code>exp</code> is the current time + 1000.</li> <li>After the Access Token is created, the function uses the NRF private key to sign on the Access Token. After signing, the function checks whether there is an error. If so, the function immediately sends the <code>AccessTokenErr</code> to the NF Service Consumer.</li> <li>The function puts the signed Access Token into the <code>AccessTokenRsp</code>. The value of the <code>TokenType</code> is set to the Bearer by the function. The function sets the <code>ExprieIn</code> and the <code>Scope</code> in the Snippet 2.</li> </ol> <p>Finally, I make a simple experiment about the Access Token and share the environment setting and method of operation with you.</p>"},{"location":"blog/20230802/20230802/#experiment","title":"Experiment","text":"<p>The Table 4 is my environment setting. I provide the Table 4 for you. You can refer it.</p> <p> Table 4. Environment</p> <p>Remove the part of the <code>tls</code> and add the content of the <code>cert</code>, <code>rootcert</code> and <code>oauth</code> under <code>sbi</code> in the <code>nrfcfg.yaml</code> before implementing about the Access Token.</p> <p><pre><code>info:\n  version: 1.0.2\n  description: NRF initial local configuration\n\nconfiguration:\n  MongoDBName: free5gc # database name in MongoDB\n  MongoDBUrl: mongodb://127.0.0.1:27017 # a valid URL of the mongodb\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.10 # IP used to serve NFs or register to another NRF\n    bindingIPv4: 127.0.0.10  # IP used to bind the service\n    port: 8000 # port used to bind the service\n    cert:\n      pem: cert/nrf.pem\n      key: cert/nrf.key\n    rootcert:\n      pem: cert/nrf.pem\n      key: cert/nrf.key\n    oauth: true\n  DefaultPlmnId:\n    mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n    mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n  serviceNameList: # the SBI services provided by this NRF, refer to TS 29.510\n    - nnrf-nfm # Nnrf_NFManagement service\n    - nnrf-disc # Nnrf_NFDiscovery service\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> nrfcfg.yaml</p> <p>Find the <code>http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531</code> in the NRF log, and you will get the <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code> is the <code>nfInstanceID</code>.</p> <pre><code>2023-08-02T20:07:43.300826205Z [INFO][NRF][NFM] Handle NFRegisterRequest\n2023-08-02T20:07:43.308259291Z [INFO][NRF][NFM] urilist create\n2023-08-02T20:07:43.311674255Z [INFO][NRF][NFM] Create NF Profile\n2023-08-02T20:07:43.318192771Z [INFO][NRF][NFM] Location header:  http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:07:43.325073275Z [INFO][NRF][GIN] | 201 |       127.0.0.1 | PUT     | /nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531 |\n</code></pre> <p>Execute <code>$ curl -X GET {apiRoot}/nnrf-nfm/v1/nf-instances/{nfInstanceID}</code>, and you will obtain the detail information about the <code>nfInstanceID</code>. You can see the <code>nfType</code> of the <code>nfInstanceID</code> is NSSF, and the information about the <code>nfInstanceID</code> is used when you implement the Access Token.</p> <pre><code>ubuntu@free5GC:~/free5gc/NFs/nrf$ curl -X GET http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531\n{\"ipv4Addresses\":[\"127.0.0.31\"],\"nfInstanceId\":\"8f7891b4-b127-4f59-9ec2-b5e6aade5531\",\"nfServices\":[{\"apiPrefix\":\"http://127.0.0.31:8000\",\"ipEndPoints\":[{\"ipv4Address\":\"127.0.0.31\",\"port\":8000,\"transport\":\"TCP\"}],\"nfServiceStatus\":\"REGISTERED\",\"scheme\":\"http\",\"serviceInstanceId\":\"0\",\"serviceName\":\"nnssf-nsselection\",\"versions\":[{\"apiFullVersion\":\"1.0.2\",\"apiVersionInUri\":\"v1\"}]},{\"apiPrefix\":\"http://127.0.0.31:8000\",\"ipEndPoints\":[{\"ipv4Address\":\"127.0.0.31\",\"port\":8000,\"transport\":\"TCP\"}],\"nfServiceStatus\":\"REGISTERED\",\"scheme\":\"http\",\"serviceInstanceId\":\"1\",\"serviceName\":\"nnssf-nssaiavailability\",\"versions\":[{\"apiFullVersion\":\"1.0.2\",\"apiVersionInUri\":\"v1\"}]}],\"nfStatus\":\"REGISTERED\",\"nfType\":\"NSSF\",\"plmnList\":[{\"mcc\":\"208\",\"mnc\":\"93\"}]}\n</code></pre> <p>Then you execute this command, see below. <pre><code>$ curl -X POST -H \"Content-Type: application/json\" -d '{\"nfInstanceId\": {nfInstanceID}, \"grant_type\": \"client_credentials\", \"nfType\": {nfType}, \"targetNfType\": \"UDR\", \"scope\": \"nudr-dr\"}' {apiRoot}/oauth2/token\n</code></pre> You will get the long symbols. The long symbols is that the Access Token is encrypted by the private key of NRF and stored in the <code>AccessTokenRsp</code>.</p> <pre><code>ubuntu@free5GC:~/free5gc/NFs/nrf$ curl -X POST -H \"Content-Type: application/json\" -d '{\"nfInstanceId\": \"8f7891b4-b127-4f59-9ec2-b5e6aade5531\", \"grant_type\": \"client_credentials\", \"nfType\": \"NSSF\", \"targetNfType\": \"UDR\", \"scope\": \"nudr-dr\"}' http://127.0.0.10:8000/oauth2/token\n\"eyJhY2Nlc3NfdG9rZW4iOiJleUpoYkdjaU9pSlNVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcGMzTWlPaUlpTENKemRXSWlPaUk0WmpjNE9URmlOQzFpTVRJM0xUUm1OVGt0T1dWak1pMWlOV1UyWVdGa1pUVTFNekVpTENKaGRXUWlPaUlpTENKelkyOXdaU0k2SW01MVpISXRaSElpTENKbGVIQWlPakUyT1RFd01EZzBPRGdzSW1saGRDSTZNVFk1TVRBd056UTRPSDAuY3VHSkkwTndfV280S2lQbS1fZEZVdnVTQWM1WVEwMmRKYk5PTUhmMV9IOHdIZ2JKWFhUam9xU1Y2OTNYSmFKemkweGIxdC1DMW14TWhVZkZjbXpNMC1Nd2oxTXZYaWhyTTktdDFRUFItSFcxQlBlN0tHMUxBV3d5MEJfcXpIalltRlR6eGhONVlyNkpURDhBbkMxaFJFeEh4WHBjV1NqbV9vZnV0NVhfUFRFRkZtaHZrbmtVbU8waWFrTmdRWElRVTc1NnlvZ29ZTlFDRnJvSmRWamJMdnpFdkJLYTVFN0hQeXc3RkRDRHpTZU5WT2t2WTlobU11eldYZ3dOVmRIT3c1c2lNbmppbTlmTVZ0RTFxS1hjWDlScXlUdXlsWjM2ZlJ1QjdVZ2hkLU15Q19xd2VJRE41ZFdYOWZqdnA3VUNZZ01mVHhSLUI2M3d5OWFjQ183eThRIiwidG9rZW5fdHlwZSI6IkJlYXJlciIsImV4cGlyZXNfaW4iOjEwMDAsInNjb3BlIjoibnVkci1kciJ9\"\n</code></pre> <p>NSSF sends the <code>AccessTokenReq</code> to NRF after you execute the above command. In the <code>AccessTokenReq</code>, the <code>nfInstanceId</code> is set to <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>grant_type</code> is set to the client_credentials. The <code>nfType</code> is set to NSSF. The <code>targetNfType</code> is set to UDR. The <code>scope</code> is set to <code>nudr-dr</code>. The information is shown in the NRF log. The value of the <code>targetNfInstanceId</code>, <code>requesterPlmn</code>, and <code>targetPlmn</code> is empty because they are not set.</p> <pre><code>2023-08-02T20:18:08.127557565Z [INFO][NRF][Token] In AccessTokenProcedure\n2023-08-02T20:18:08.127586736Z [INFO][NRF][Token] Access Token Request\n2023-08-02T20:18:08.127611885Z [INFO][NRF][Token] Grant Type: client_credentials\n2023-08-02T20:18:08.127637480Z [INFO][NRF][Token] NF Instance ID: 8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:18:08.127664415Z [INFO][NRF][Token] Target NF Instance ID:\n2023-08-02T20:18:08.127689792Z [INFO][NRF][Token] NF Type: NSSF\n2023-08-02T20:18:08.127712916Z [INFO][NRF][Token] Target NF Type: UDR\n2023-08-02T20:18:08.127734827Z [INFO][NRF][Token] Scope: nudr-dr\n2023-08-02T20:18:08.127758317Z [INFO][NRF][Token] Requester PLMN: &lt;nil&gt;\n2023-08-02T20:18:08.127781052Z [INFO][NRF][Token] Target PLMN: &lt;nil&gt;\n</code></pre> <p>Next, you can see the Access Token in the NRF log. The value of the <code>Sub</code> is <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>Sub</code> represents NSSF, and NSSF belongs to the NF Service Consumer. The value of the <code>Scope</code> is the <code>nudr-dr</code>. The value of the <code>Exp</code> is 1691008488.</p> <pre><code>2023-08-02T20:18:08.134096785Z [INFO][NRF][Token] Access Token Claims\n2023-08-02T20:18:08.138100978Z [INFO][NRF][Token] Iss:\n2023-08-02T20:18:08.138185972Z [INFO][NRF][Token] Sub: 8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:18:08.138228925Z [INFO][NRF][Token] Aud:\n2023-08-02T20:18:08.138264519Z [INFO][NRF][Token] Scope: nudr-dr\n2023-08-02T20:18:08.138298628Z [INFO][NRF][Token] Exp: 1691008488\n</code></pre> <p>Next, you can see the <code>AccessTokenRsp</code>. You can see that the Access Token has become the long symbols. The value of the <code>Token Type</code> is set to the Bearer. The value of the <code>ExpiresIn</code> is set to 1000. The value of the <code>Scope</code> is set to <code>nudr-dr</code>.</p> <pre><code>2023-08-02T20:18:08.149587382Z [INFO][NRF][Token] Access Token Response\n2023-08-02T20:18:08.150006665Z [INFO][NRF][Token] Access Token: eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiIiLCJzdWIiOiI4Zjc4OTFiNC1iMTI3LTRmNTktOWVjMi1iNWU2YWFkZTU1MzEiLCJhdWQiOiIiLCJzY29wZSI6Im51ZHItZHIiLCJleHAiOjE2OTEwMDg0ODgsImlhdCI6MTY5MTAwNzQ4OH0.cuGJI0Nw_Wo4KiPm-_dFUvuSAc5YQ02dJbNOMHf1_H8wHgbJXXTjoqSV693XJaJzi0xb1t-C1mxMhUfFcmzM0-Mwj1MvXihrM9-t1QPR-HW1BPe7KG1LAWwy0B_qzHjYmFTzxhN5Yr6JTD8AnC1hRExHxXpcWSjm_ofut5X_PTEFFmhvknkUmO0iakNgQXIQU756yogoYNQCFroJdVjbLvzEvBKa5E7HPyw7FDCDzSeNVOkvY9hmMuzWXgwNVdHOw5siMnjim9fMVtE1qKXcX9RqyTuylZ36fRuB7Ughd-MyC_qweIDN5dWX9fjvp7UCYgMfTxR-B63wy9acC_7y8Q\n2023-08-02T20:18:08.150094277Z [INFO][NRF][Token] Token Type: Bearer\n2023-08-02T20:18:08.150133189Z [INFO][NRF][Token] Expires In: 1000\n2023-08-02T20:18:08.150167371Z [INFO][NRF][Token] Scope: nudr-dr\n</code></pre> <p>Finally, you can see 200. 200 means that AUSF sends the <code>AccessTokenReq</code> to NRF. NRF successfully sends to AUSF after verification.</p> <pre><code>2023-08-02T20:18:08.150302345Z [INFO][NRF][GIN] | 200 |       127.0.0.1 | POST    | /oauth2/token |\n</code></pre>"},{"location":"blog/20230802/20230802/#reference","title":"Reference","text":"<ul> <li>TS 29.510</li> <li>TS 33.501</li> <li>[Notes] Understanding OAuth 2.0: Understand the differences of each role and each type of process at one time</li> <li>https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/</li> <li>https://github.com/free5gc/free5gc/issues/434</li> </ul>"},{"location":"blog/20230802/20230802/#about","title":"About","text":"<p>Hi, my name is Wilson. I am a master\u2019s student. My main area of research is network slicing. In the future, I will introduce more information about 5G. Hope you enjoy it.</p>"},{"location":"blog/20230809/main/","title":"Fuzz Testing in Go: Discovering Vulnerabilities and Analyzing a Real Case (CVE-2022-43677)","text":"<p>Note</p> <p>Author: Yu-Sheng Liu Date: 2023/8/9</p>"},{"location":"blog/20230809/main/#overview","title":"Overview","text":"<p>In this article, we begin by introducing the concept of fuzz testing and its significance in software testing. Subsequently, we present Go Fuzzing as an illustrative example to demonstrate how to implement fuzz testing in Go. Lastly, we showcase a practical case, CVE-2022-43677, to exemplify how we conduct fuzz testing on the free5GC system.</p>"},{"location":"blog/20230809/main/#fuzz-testing","title":"Fuzz Testing","text":""},{"location":"blog/20230809/main/#what-is-fuzz-testing-fuzzing","title":"What is Fuzz Testing (Fuzzing)?","text":"<p>Fuzz testing, commonly known as fuzzing, is an automated software testing technique used to uncover vulnerabilities, defects, and unexpected behavior in computer systems, applications, and networks. The primary objective of fuzzing is to identify security flaws, crashes, or abnormal program behavior caused by invalid or unexpected inputs.</p>"},{"location":"blog/20230809/main/#how-fuzz-testing-works","title":"How Fuzz Testing Works","text":"<p>Fuzz testing involves subjecting the target software or system to a large number of inputs, including random or malformed data, to see how it handles them. The idea is to explore edge cases and input combinations that may not have been adequately tested during traditional software testing. Here's how the fuzzing process typically works:</p> <ol> <li> <p>Test Input Generation:</p> <ul> <li>Fuzzing tools generate test inputs based on various techniques, which can be broadly categorized as:<ul> <li>Random Fuzzing: The simplest approach where random data is generated as input.</li> <li>Mutation-Based Fuzzing: Starting with valid inputs, the tool applies mutations to create variations of the original data.</li> <li>Grammar-Based Fuzzing: Using a predefined grammar or structure to generate valid and invalid inputs.</li> <li>Seed Corpus: Using existing inputs (e.g., files, network packets) as the starting set for mutation.</li> </ul> </li> </ul> </li> <li> <p>Test Execution:</p> <ul> <li>The generated inputs are provided as input to the target application, component, or system.</li> <li>The application is executed with each input, and its behavior is monitored during runtime.</li> </ul> </li> <li> <p>Monitoring and Analysis:</p> <ul> <li>The fuzzer observes the application's behavior, including any crashes, exceptions, hangs, or memory-related issues.</li> <li>Code coverage analysis is often performed to determine which parts of the code were exercised during the testing.</li> </ul> </li> <li> <p>Feedback and Iteration:</p> <ul> <li>Fuzzing tools use feedback mechanisms to prioritize and select inputs that lead to new code paths or unique behavior.</li> <li>The process is iterated with refined inputs to continue exploring deeper into the application.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#types-of-fuzz-testing","title":"Types of Fuzz Testing","text":"<ol> <li> <p>Black Box Fuzzing:</p> <ul> <li>The tester has no access to the application's internal code or design.</li> <li>Random or mutated inputs are provided to the application to observe its behavior.</li> <li>Suitable for testing closed-source software or systems where the tester has limited knowledge.</li> </ul> </li> <li> <p>White Box Fuzzing:</p> <ul> <li>The tester has access to the application's source code and can leverage this knowledge for targeted testing.</li> <li>Inputs can be intelligently crafted to explore specific code paths and functions.</li> <li>Provides more in-depth coverage but requires access to the application's code.</li> </ul> </li> <li> <p>Grey Box Fuzzing:</p> <ul> <li>A combination of black box and white box approaches.</li> <li>The tester has partial knowledge of the application, such as certain APIs or protocols, but not complete access to the source code.</li> <li>Offers a balance between targeted testing and exploration of unknown behaviors.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#advantages-of-fuzz-testing","title":"Advantages of Fuzz Testing","text":"<ol> <li> <p>Bug and Vulnerability Discovery:</p> <ul> <li>Fuzzing can uncover previously unknown security vulnerabilities and software defects, including memory corruption errors and input validation issues.</li> </ul> </li> <li> <p>Automation and Efficiency:</p> <ul> <li>Fuzzing is an automated testing process, which allows it to scale and test large codebases quickly and efficiently.</li> </ul> </li> <li> <p>Diverse Test Inputs:</p> <ul> <li>Fuzzing generates a wide range of test inputs, exploring various edge cases that might not be covered by manual testing.</li> </ul> </li> <li> <p>Early Vulnerability Detection:</p> <ul> <li>Fuzzing can be integrated into the development process, enabling early detection and mitigation of vulnerabilities before deployment.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#conclusion-for-fuzz-testing","title":"Conclusion for fuzz testing","text":"<p>Fuzz testing, or fuzzing, is a powerful and essential technique in the realm of software security testing. By providing a diverse set of inputs and exploring uncharted code paths, fuzz testing uncovers vulnerabilities and defects that might otherwise remain hidden.</p> <p>Next, we will use Go fuzzing as an example to introduce how to develop a fuzzing in Go.</p>"},{"location":"blog/20230809/main/#go-fuzzing","title":"Go Fuzzing","text":"<p>Go officially supports fuzzing starting from Go 1.18, and its official figure provides a brief and clear summary of the fuzzing function components. </p> <p>Similar to Go's unit test functions, the fuzzing function in Go must follow the naming convention <code>FuzzXxx</code> and take an argument of type <code>*testing.F</code>. This argument has two main functions, <code>Add</code> and <code>Fuzz</code>.</p> <ol> <li> <p><code>Add</code> Function:</p> <ul> <li>You can use the <code>Add</code> function to add your own test data to the seed corpus for fuzz testing. The seed corpus is the initial set of inputs that <code>go-fuzz</code> will use to start the fuzzing process.</li> </ul> </li> <li> <p><code>Fuzz</code> Function:</p> <ul> <li>The <code>Fuzz</code> function will be the target function that you want to test using fuzzing. It must have <code>*testing.T</code> as its first argument, similar to regular unit tests.</li> <li>Additionally, the <code>Fuzz</code> function supports variadic arguments with the following basic data types:<ul> <li><code>string</code>, <code>[]byte</code></li> <li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32/rune</code>, <code>int64</code></li> <li><code>uint</code>, <code>uint8/byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li> <li><code>float32</code>, <code>float64</code></li> <li><code>bool</code></li> </ul> </li> </ul> </li> </ol> <p>These data types represent the different kinds of input data that can be passed to the <code>Fuzz</code> function during the fuzzing process. The fuzzer will generate and mutate inputs of these types to explore different code paths and uncover bugs or unexpected behavior in the target function.</p> <p>In summary, when writing fuzzing functions in Go, remember to use the <code>FuzzXxx</code> naming pattern, accept <code>*testing.F</code> as an argument, utilize the <code>Add</code> function to customize the seed corpus, and use the <code>Fuzz</code> function with supported basic data types to perform fuzz testing on your target functions.</p> <p>You can use the command to execute the fuzz testing: <pre><code>go test -fuzz=&lt;regex&gt; -fuzztime=&lt;duration or times&gt;\n\n# Execute the fuzz testing until it crashs or finding some errors\ngo test -fuzz=Fuzz\n\n# Execute the fuzz testing ten iterations\ngo test -fuzz=Fuzz -fuzztime=10x\n\n# Execute the fuzz testing twenty seconds\ngo test -fuzz=Fuzz -fuzztime=20s\n</code></pre></p>"},{"location":"blog/20230809/main/#simple-example-division","title":"Simple Example - Division","text":"<p>We have developed a very simple function called <code>Division</code> that accepts two arguments, <code>dividend</code> and <code>divisor</code>, and then returns two results: <code>quotient</code> and <code>remainder</code>.</p> <pre><code>func Division(dividend, divisor int32) (\n    quotient, remainder int32,\n) {\n    quotient = dividend / divisor\n    remainder = dividend % divisor\n\n    return\n}\n</code></pre> <p>In the <code>FuzzDivision</code> function, we utilize the data generated by the Go fuzzer to test our <code>Division</code> function.</p> <pre><code>func FuzzDivision(f *testing.F) {\n    f.Fuzz(func(t *testing.T,\n        n1, n2 int32,\n    ) {\n        q, r := Division(n1, n2)\n\n        require.Equal(t, n1, n2*q+r)\n    })\n}\n</code></pre> <p>We expected to see: <pre><code>n1 / n2 = q ... r\nn1 = n2 * q + r\n</code></pre></p> <p>There should not be any problems with this implementation.</p> <p>Then we can use the following command to start the fuzz testing.</p> <pre><code>go test -fuzz=^FuzzDivision$\n</code></pre> <p>The fuzz testing reports the error \"integer divide by zero\".</p> <p></p> <p>As a normal user, we understand that the divisor cannot be zero. However, the input data may not always be as expected. This is precisely why we use fuzz testing\u2014to help us find edge cases and uncover unexpected behavior.</p> <p>Go stores the data that caused the fuzz testing to fail. You can check them using the following command.     * Note: The file name, <code>29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91</code>, may not be the same.</p> <pre><code>cat testdata/fuzz/FuzzDivision/29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91\n</code></pre> <p>The content of the file is as follows: <pre><code>go test fuzz v1\nint32(-7)\nrune('\\x00')\n</code></pre></p> <p>The first line indicates the encoding version, and the subsequent lines represent the argument values that triggered the error during the fuzz testing.</p> <p>Now we can modify our <code>Division</code> function to check the <code>divisor</code> if it is zero.</p> <pre><code>var ErrorDivideByZero = fmt.Errorf(\"integer divide by zero\")\n\nfunc Division(dividend, divisor int32) (\n    quotient, remainder int32, err error,\n) {\n    if divisor == 0 {\n        err = ErrorDivideByZero\n        return\n    }\n\n    quotient = dividend / divisor\n    remainder = dividend % divisor\n\n    return\n}\n</code></pre> <p>Similarly, the <code>FuzzDivision</code> fuzzing function now checks for the presence of the <code>ErrorDivideByZero</code> error.</p> <pre><code>func FuzzDivision(f *testing.F) {\n    f.Add(int32(67), int32(3))\n\n    f.Fuzz(func(t *testing.T,\n        n1, n2 int32,\n    ) {\n        if q, r, err := Division(n1, n2); err != ErrorDivideByZero {\n            require.Equal(t, n1, n2*q+r)\n        }\n    })\n}\n</code></pre> <p>Now, we can use the following command to re-test the failing case.</p> <pre><code>go test -run=FuzzDivision/29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91\n</code></pre>"},{"location":"blog/20230809/main/#conclusion-for-go-fuzzing","title":"Conclusion for Go Fuzzing","text":"<p>We have used a simple example to describe how to develop a fuzzing function in Go and how to leverage the Go command-line tool to execute fuzz testing.</p> <p>Next, we will examine a real case, CVE-2022-43677, and demonstrate the process of developing a fuzzing function to identify edge cases.</p>"},{"location":"blog/20230809/main/#cve-2022-43677","title":"CVE-2022-43677","text":"<p>Accroding to the descriptoin:</p> <p>In free5GC 3.2.1, a malformed NGAP message can crash the AMF and NGAP decoders via an index-out-of-range panic in aper.GetBitString.</p> <p>In response to this vulnerability, we have developed a fuzzing function to test the NGAP decoder. The function utilizes two approaches: modifying the NGAP message's content under a valid template or adjusting its format by changing the Information Elements (IEs) with variable lengths.</p> <pre><code>// Put the code under the free5gc/test\nfunc FuzzNgapDecode(f *testing.F) {\n    f.Fuzz(func(t *testing.T,\n        modifyWhat uint8,\n        changeIe0, changeIe1, changeIe2, changeIe3, changeIe4 bool,\n        valueIe0A uint32,\n        valueIe2ACellId uint64, valueIe2ATac uint32,\n        valueIe3A uint64,\n        valueIe4A uint64,\n        valueIePlmn uint32,\n    ) {\n        var idx, n int\n        var sendMsg []byte\n        var registrationRequest []byte\n        var bs []byte\n        var err error\n        var ngapPdu ngapType.NGAPPDU\n        var mobileIdentity5GS nasType.MobileIdentity5GS\n        var ue *test.RanUeContext\n\n        // New UE\n        ue = test.NewRanUeContext(\"imsi-2089300007487\", 1, security.AlgCiphering128NEA0, security.AlgIntegrity128NIA2,\n            models.AccessType__3_GPP_ACCESS)\n        ue.AmfUeNgapId = 1\n        ue.AuthenticationSubs = test.GetAuthSubscription(TestGenAuthData.MilenageTestSet19.K,\n            TestGenAuthData.MilenageTestSet19.OPC,\n            TestGenAuthData.MilenageTestSet19.OP)\n\n        mobileIdentity5GS = nasType.MobileIdentity5GS{\n            Len:    12, // suci\n            Buffer: []uint8{0x01, 0x02, 0xf8, 0x39, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x47, 0x78},\n        }\n\n        if modifyWhat%2 == DoModifyContent {\n            if changeIe0 {\n                // RAN UE NGAP ID\n                ue.RanUeNgapId = int64(valueIe0A)\n            }\n\n            registrationRequest = nasTestpacket.GetRegistrationRequest(\n                nasMessage.RegistrationType5GSInitialRegistration, mobileIdentity5GS, nil, ue.GetUESecurityCapability(), nil, nil, nil)\n            ngapPdu = ngapTestpacket.BuildInitialUEMessage(ue.RanUeNgapId, registrationRequest, \"\")\n\n            if changeIe2 {\n                // User Location Information\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDUserLocationInformation {\n                        bs = make([]byte, 4)\n                        valueIePlmn &amp;= uint32(PlmnMask)\n                        binary.LittleEndian.PutUint32(bs, valueIePlmn)\n\n                        NgRan := ie.Value.UserLocationInformation.UserLocationInformationNR\n                        NgRan.NRCGI.PLMNIdentity.Value = bs[:PlmnByteLen]\n                        NgRan.TAI.PLMNIdentity.Value = bs[:PlmnByteLen]\n\n                        bs = make([]byte, 8)\n                        valueIe2ACellId &amp;= uint64(CellIdMask)\n                        binary.LittleEndian.PutUint64(bs, valueIe2ACellId)\n                        NgRan.NRCGI.NRCellIdentity.Value.Bytes = bs[:CellIdByteLen]\n\n                        bs = make([]byte, 4)\n                        valueIe2ATac &amp;= uint32(TacMask)\n                        binary.LittleEndian.PutUint32(bs, valueIe2ATac)\n                        NgRan.TAI.TAC.Value = bs[:TacByteLen]\n                    }\n                }\n            }\n            if changeIe3 {\n                // RRC Establishment Cause\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDRRCEstablishmentCause {\n                        ie.Value.RRCEstablishmentCause.Value = aper.Enumerated(valueIe3A)\n                    }\n                }\n            }\n            if changeIe4 {\n                // UE Context Request\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDUEContextRequest {\n                        ie.Value.UEContextRequest.Value = aper.Enumerated(valueIe4A)\n                    }\n                }\n            }\n            sendMsg, err = ngap.Encoder(ngapPdu)\n        } else if modifyWhat%2 == DoModifyFormat {\n            registrationRequest = nasTestpacket.GetRegistrationRequest(\n                nasMessage.RegistrationType5GSInitialRegistration, mobileIdentity5GS, nil, ue.GetUESecurityCapability(), nil, nil, nil)\n\n            if changeIe1 {\n                registrationRequest[3] += 1\n                registrationRequest = append(registrationRequest, registrationRequest[len(registrationRequest)-1])\n            } else {\n                registrationRequest[3] -= 1\n                registrationRequest = registrationRequest[:len(registrationRequest)-1]\n            }\n\n            ngapPdu = ngapTestpacket.BuildInitialUEMessage(ue.RanUeNgapId, registrationRequest, \"\")\n            sendMsg, err = ngap.Encoder(ngapPdu)\n            require.Nil(t, err, \"Error: %v\", err)\n            require.Equal(t, int(sendMsg[3]), len(sendMsg[4:]), \"%v\", sendMsg)\n\n            idx = bytes.Index(sendMsg, []byte(\"\\x00\\x70\\x40\"))\n            assert.NotEqual(t, idx, -1, \"Can not find UE context Request\")\n            if idx != -1 {\n                if valueIe4A%8 == 0 || valueIe4A%8 == 1 {\n                    n = 2\n                } else {\n                    n = int(valueIe4A % 8)\n                }\n                sendMsg[idx+3] = uint8(n)\n                sendMsg = sendMsg[:idx+4]\n                bs = make([]byte, 8)\n                binary.LittleEndian.PutUint64(bs, valueIe4A)\n\n                for i := 0; i &lt; n; i++ {\n                    sendMsg = append(sendMsg, bs[i])\n                }\n\n                sendMsg[3] += uint8(n - 1) // total length\n            }\n        }\n        require.Equal(t, int(sendMsg[3]), len(sendMsg[4:]), \"%v\", sendMsg)\n\n        _, err = ngap.Decoder(sendMsg)\n    })\n}\n</code></pre> <p>We can use the following command to execute the fuzz testing.</p> <pre><code>go test -fuzz=^FuzzNgapDecode$ -run=^FuzzNgapDecode$\n</code></pre> <p>The test resulted in a crash, which confirms the presence of the vulnerability as described in CVE-2022-43677.</p> <p></p> <p>The bug was found in the package aper at version v1.0.4. Fortunately, the latest version of the package has already fixed this issue. To verify the fix, we can update the aper package to the latest commit using the following commands:</p> <pre><code># Update package aper to the latest commit\ngo get github.com/free5gc/aper@main\n</code></pre> <p>After updating the aper package, we can test it again with the fuzzing function:</p> <p><pre><code>go test -fuzz=^FuzzNgapDecode$ -run=^FuzzNgapDecode$\n</code></pre> </p> <pre><code># Alternatively, re-testing the failing case\ngo test -run=FuzzNgapDecode/87af855bbc381c8d510af5ce897fcdd7f9154574e61c0413223f7e31769c2767\n</code></pre> <p></p>"},{"location":"blog/20230809/main/#conclusion","title":"Conclusion","text":"<p>Fuzz testing is a powerful technique for improving the security and reliability of software systems. By subjecting programs to a wide range of inputs, fuzzing can uncover vulnerabilities and defects that might not be found through traditional testing methods. It automates the testing process, making it efficient and scalable for large codebases.</p> <p>In the context of Go programming, Go fuzzing is well-supported and integrates seamlessly with the standard testing framework. Developers can create fuzzing functions to target specific functions and uncover potential issues using random or mutated inputs.</p> <p>To demonstrate the effectiveness of fuzz testing, we presented a real case, CVE-2022-43677, which affected free5GC version 3.2.1. By developing a fuzzing function for the NGAP decoder, we were able to identify a vulnerability that caused a crash.</p> <p>In conclusion, fuzz testing is a critical practice in software development, enabling developers to proactively discover and resolve bugs and vulnerabilities. It empowers them to deliver more secure and robust software systems, providing users with a higher level of confidence in the applications they use. By incorporating fuzz testing as part of the software development lifecycle, developers can significantly enhance the quality and security of their software products.</p>"},{"location":"blog/20230809/main/#reference","title":"Reference","text":"<ul> <li>Go Fuzzing</li> <li>CVE-2022-43677</li> </ul>"},{"location":"blog/20230809/main/#about","title":"About","text":"<p>I'm Yu-Sheng Liu, a master's student at National Yang Ming Chiao Tung University. My research topic focuses on improving the performance of the 5G core network, such as reducing the latency of message propagation in SBI. If you have any questions, please don't hesitate to contact me!</p> <ul> <li>LinkedIn</li> </ul>"},{"location":"blog/20230816/main/","title":"Introduce Kubernetes and Deploy free5GC on Kubernetes with helm","text":"<p>Note</p> <p>Author: Elisa Lee Date: 2023/8/16</p>"},{"location":"blog/20230816/main/#abstract","title":"Abstract","text":"<p>In the initial section of the article, I will provide an introduction to Kubernetes. Moving on to the subsequent part, I will delve into the utilization of Kubernetes for facilitating the deployment of free5GC. Lastly, in the final segment of the article, I will elaborate on the effective utilization of Kubernetes for monitoring services.</p>"},{"location":"blog/20230816/main/#introduce-kubernetes","title":"Introduce Kubernetes","text":"<p>Do you know why Kubernetes is called k8s?</p> <p>It's due to a shorthand notation that uses the first letter \"k,\" followed by the number \"8,\" and ending with the last letter \"s\" to represent the full name. Kubernetes,stands as an open-source container orchestration platform that bestows organizations with the capacity to adeptly govern, deploy, and expand containerized applications. Initially conceived by Google and presently overseen by the Cloud Native Computing Foundation (CNCF), Kubernetes has ascended to become a pivotal technological underpinning within the realm of contemporary cloud-native computing.</p> <p>For those who find themselves unacquainted with the intricacies of Kubernetes, let us embark on an exploration of its architectural framework.</p> <p> I understand that the image presented above might appear intricate at first glance. However, there's no need for concern. Allow me to guide you through each component step by step.</p>"},{"location":"blog/20230816/main/#pods","title":"Pods","text":"<p>A \"Pod\" stands as the most diminutive executable entity within the Kubernetes ecosystem. It possesses the capability to encompass either an individual container or a collective assembly of containers. The subsequent enumeration outlines several salient distinctions that set it apart from the act of directly launching a standalone container.</p> <p>Notably, a Pod possesses its dedicated network interface, affording all enclosed containers the ability to intercommunicate seamlessly by interfacing with the \"localhost.\" Furthermore, connectivity to other Pods is conveniently established through direct usage of their respective IP addresses within the Kubernetes environment.</p> <p>The Pod's inherent duplicability and capacity for effortless restarts, even from the point of its most recent execution, distinguish it. Additionally, the versatility of including a functioning container within its initial state further characterizes its nature.</p> <p>Collectively, these attributes contribute to the refinement and streamlined nature of networking within the Kubernetes ecosystem. Such qualities not only facilitate smoother scalability but also offer enhanced capabilities for restarting services with utmost ease.</p>"},{"location":"blog/20230816/main/#nodes","title":"Nodes","text":"<p>Consider a \"node\" as a tangible computing entity akin to a physical machine. Analogous to our personal machines, these nodes possess the capacity to concurrently execute multiple tasks, akin to the pods referenced earlier. The orchestration of nodes is overseen by a pivotal component known as the Kubernetes control plane, which, in an automated fashion, allocates pods across the available nodes. Within each node, a minimum of two services operate in tandem.</p> <ol> <li> <p>Kubelet: This crucial service undertakes the responsibility of facilitating seamless communication between the Kubernetes control plane and the individual node. It serves as the intermediary that relays instructions and status updates, ensuring synchronization and cooperation.</p> </li> <li> <p>Container Runtime: Operating in tandem with Kubelet, the container runtime undertakes pivotal functions. These encompass retrieving container images from registries, the unpacking of containers, and the actual execution of applications. A prime example of such a container runtime is Docker, renowned for its role in enabling containerization.</p> </li> </ol> <p>In essence, this intricate interplay of nodes, services, and orchestration elements underscores the dynamism and efficiency inherent to the Kubernetes ecosystem. Through these interlocking mechanisms, the platform optimizes resource utilization, ensures effective communication, and enables the seamless execution of applications across a distributed infrastructure.</p>"},{"location":"blog/20230816/main/#master-nodes","title":"Master Nodes","text":"<p>We've now explored all the scalable components and the task runner. Undoubtedly, to orchestrate and oversee everything, a central command hub is necessary \u2013 this is referred to as the master node. Although direct intervention within these nodes isn't typically required to ensure the seamless operation of the entire system, it's still beneficial for you to grasp a basic understanding of its functionality.</p>"},{"location":"blog/20230816/main/#api-server","title":"API server","text":"<p>It determines which interface among all nodes can be externally accessed. Any subsequent commands you execute will be channeled through this service to the designated node or pod. Furthermore, essential cluster information can also be obtained from this service.</p>"},{"location":"blog/20230816/main/#scheduler","title":"Scheduler","text":"<p>Similar to an airport's control tower, its function is akin to orchestrating the deployment of pods on specific nodes based on the rules you've established and the data obtained from the API server. The effectiveness of these rules is pivotal, as they often determine the system's overall efficiency.</p>"},{"location":"blog/20230816/main/#controller-manager","title":"Controller Manager","text":"<p>When the need arises to enact concrete modifications on a pod, such as terminating or pausing its operation, a fundamental prerequisite is pinpointing the pod's process location and establishing the means to interact with it. This is precisely the role fulfilled by the controller manager. Additionally, this manager oversees vital components, including accounts, services, and more.</p>"},{"location":"blog/20230816/main/#etcd","title":"Etcd","text":"<p>For a simplified understanding, we can view this as essentially a comprehensive backup of the entire cluster.</p>"},{"location":"blog/20230816/main/#service","title":"Service","text":"<p>In Kubernetes, a \"service\" is an abstraction that enables communication between different sets of pods, usually to provide a stable network endpoint for accessing a specific group of pods. Pods in Kubernetes are ephemeral and can be created, terminated, or scaled dynamically, which makes their IP addresses and lifecycles unpredictable. Services provide a way to decouple the frontend of an application from the backend pods, making it easier for other components or users to access the application without having to know the exact locations or IP addresses of the pods.</p> <p>A service can be defined in Kubernetes using a YAML or JSON configuration file, and it is associated with a set of pods based on a label selector. The service acts as a load balancer, distributing incoming network traffic among the pods that match the specified selector. This distribution ensures that even if pods are scaled up or down, the service remains available and reachable.</p> <p>There are different types of services in Kubernetes:</p> <ol> <li> <p>ClusterIP: This is the default service type, and it exposes the service on a cluster-internal IP address. It is accessible only within the cluster.</p> </li> <li> <p>NodePort: This type exposes the service on each node's IP address at a static port. It allows external access to the service using the node's IP and the specified static port.</p> </li> <li> <p>LoadBalancer: This type automatically provisions a cloud provider load balancer to expose the service externally. It works in environments that support external load balancers.</p> </li> <li> <p>ExternalName: This type provides an alias for an external service by returning a CNAME record with the configured DNS name.</p> </li> </ol> <p>Services are a fundamental concept in Kubernetes and play a crucial role in enabling communication and load balancing between pods and external clients. They provide a stable and abstracted network endpoint that allows applications to scale and be more resilient without disrupting access from users or other components.</p> <p>In the upcoming section, I will delve into the process of deploying free5GC on Kubernetes.</p>"},{"location":"blog/20230816/main/#deploying-5g-core-network-with-free5gc","title":"Deploying 5G core network with free5GC","text":"<p>Now I'm going to introduce how to implement free5GC on Kubernetes with helm</p>"},{"location":"blog/20230816/main/#install-require-packages","title":"Install require packages","text":"<pre><code>sudo apt update -y\nsudo apt upgrade -y\n</code></pre>"},{"location":"blog/20230816/main/#install-apt-transport-https","title":"Install apt-transport-https","text":"<p>\"apt-transport-https\" is a crucial package that equips your system with the essential tools and libraries required to seamlessly integrate the HTTPS protocol. This integration ensures secure and encrypted communication when connecting to package repositories while utilizing the Advanced Package Tool (APT) for effective package management. <pre><code>sudo apt install -y curl wget apt-transport-https\n</code></pre></p>"},{"location":"blog/20230816/main/#install-gtp5g","title":"Install gtp5g","text":"<p>\"gtp5g\" refers to a customized Linux kernel module specifically designed to handle packets by PFCP (Packet Forwarding Control Protocol) Information Elements (IEs) such as PDR (Packet Detection Rule) and FAR (Forwarding Action Rule). For comprehensive insights, you can delve into the 3GPP specifications TS 29.281 and TS 29.244. To employ the UPF (User Plane Function) component effectively, it's imperative to operate on either the 5.0.0-23-generic or 5.4.x version of the Linux kernel. This ensures optimal compatibility and seamless integration with the necessary functionalities. <pre><code>sudo apt install gcc\nsudo apt install make\ngit clone -b v0.8.1 https://github.com/free5gc/gtp5g.git\ncd gtp5g\nmake\nsudo make install\n</code></pre></p>"},{"location":"blog/20230816/main/#install-docker","title":"Install docker","text":"<p>\"docker\" is a platform that enables developers to build, package, and distribute applications as containers. Containers are lightweight, portable, and self-sufficient units that encapsulate everything an application needs to run, including the code, runtime, system tools, system libraries, and settings. Docker provides a consistent environment across different development and deployment stages, from local development to testing and production. <pre><code>for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\necho \\\n  \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n  sudo apt-get update\n  sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre></p>"},{"location":"blog/20230816/main/#install-minikube","title":"Install minikube","text":"<p>\"minikube\" is an open-source tool that enables developers to set up and run a single-node Kubernetes cluster locally on their own computer. It's particularly useful for learning, development, and testing purposes. Minikube provides an easy way to experience Kubernetes without needing access to a full-scale cluster, making it a great tool for getting familiar with Kubernetes concepts and features. <pre><code>wget https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo cp minikube-linux-amd64 /usr/local/bin/minikube\nsudo chmod +x /usr/local/bin/minikube\n</code></pre></p>"},{"location":"blog/20230816/main/#install-kubectl","title":"Install kubectl","text":"<p>\"kubectl\" is the command-line tool used to interact with and manage Kubernetes clusters. It is an essential component for working with Kubernetes, allowing users to perform various tasks and operations on Kubernetes clusters directly from the terminal. <pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl\nchmod +x kubectl\nsudo mv kubectl /usr/local/bin/\n</code></pre></p>"},{"location":"blog/20230816/main/#install-helm","title":"Install helm","text":"<p>\"helm\" is a package manager for Kubernetes that simplifies the deployment and management of applications and services on a Kubernetes cluster. It allows you to define, install, and upgrade complex applications using pre-configured templates called \"charts.\" These charts encapsulate all the necessary resources, configurations, and dependencies required to run an application. <pre><code>curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3\nchmod 700 get_helm.sh\n./get_helm.sh\nhelm list -A\n</code></pre> </p>"},{"location":"blog/20230816/main/#install-multus-cni","title":"Install multus-cni","text":"<p>\"multus-cni\" is a project that provides a Kubernetes network plugin, specifically a \"Container Network Interface\" (CNI) plugin, which enables the attachment of multiple network interfaces to pods in a Kubernetes cluster. <pre><code>git clone https://github.com/k8snetworkplumbingwg/multus-cni.git\n</code></pre></p>"},{"location":"blog/20230816/main/#deploy-free5gc","title":"Deploy free5GC","text":""},{"location":"blog/20230816/main/#useful-kubectl-command","title":"Useful kubectl command","text":"<p>Now, I will proceed to introduce a selection of kubectl command that can be employed during the deployment of free5GC.</p> <p>\"kubectl get pods\" retrieves a list of running pods in the current namespace along with their names, statuses, and other relevant information. <pre><code>kubectl get pods\n</code></pre> \"kubectl describe pod\" is used to get detailed information about a specific pod, including its status, events, labels, and more.</p> <p><pre><code>kubectl describe pod [pod-name]\n</code></pre> \"kubectl logs\" fetches the logs of a specific pod, helping you troubleshoot issues and monitor application output.</p> <p><pre><code>kubectl logs [pod-name]\n</code></pre> \"kubectl exec -it\" allows you to execute a command inside a running pod. The <code>-it</code> flag enables interactive terminal access. <pre><code>kubectl exec -it [pod-name] -- [command]\n</code></pre> \"kubectl apply -f \" deploys resources defined in a YAML file, such as pods, services, or deployments, to your cluster. <pre><code>kubectl apply -f [yaml-file]\n</code></pre> \"kubectl delete\" deletes a specific resource by specifying its type and name, freeing up resources and cleaning the cluster. <pre><code>kubectl delete [resource-type] [resource-name]\n</code></pre> \"kubectl expose deployment\" creates a new service, typically of type LoadBalancer, to expose a deployment's pods to external network traffic. <pre><code>kubectl expose deployment [deployment-name] --type=LoadBalancer --port=[port]\n</code></pre></p> <p>\"kubectl get services\" lists all services running in the current namespace along with their details, including ClusterIP, external IP (if applicable), and ports. <pre><code>kubectl get services\n</code></pre> \"kubectl get nodes\" retrieves information about the worker nodes in the cluster, displaying their statuses, roles, and other essential data. <pre><code>kubectl get nodes\n</code></pre> \"kubectl describe node\" provides detailed information about a specific node, including its capacity, allocated resources, and conditions. <pre><code>kubectl describe node [node-name]\n</code></pre> \"kubectl get namespaces\" displays all available namespaces in the cluster, which are used to isolate resources and manage multi-tenancy. <pre><code>kubectl get namespaces\n</code></pre> \"kubectl create namespace\" creates a new namespace, allowing you to logically separate and organize resources. <pre><code>kubectl create namespace [namespace-name]\n</code></pre> \"kubectl port-forward\" enables you to create a network tunnel between your local machine and a specific pod running within a Kubernetes cluster. This allows you to access services or applications running inside the pod as if they were running on your local machine. The command forwards traffic from a specified local port to a port on the selected pod. <pre><code>kubectl port-forward [pod-name] [local-port]:[remote-port]\n</code></pre></p>"},{"location":"blog/20230816/main/#start-minikube","title":"Start minikube","text":"<p>Use flannel as cni plugin to start minikue. Flannel is a popular \"Container Network Interface\" (CNI) plugin used for networking in Kubernetes and other container orchestration platforms. It provides a simple and lightweight network fabric designed to facilitate communication between containers and pods in a distributed environment, such as a Kubernetes cluster. <pre><code>sudo usermod -aG docker $USER &amp;&amp; newgrp docker\nminikube start --driver=docker --cpus=4 --memory=8g --disk-size=20g --cni=flannel\n## verify minikube installation\nminikube status\n</code></pre> </p>"},{"location":"blog/20230816/main/#enable-multus-cni-plugin","title":"Enable Multus-CNI Plugin","text":"<pre><code>cd multus-cni\ncat ./deployments/multus-daemonset.yml | kubectl apply -f -\n</code></pre>"},{"location":"blog/20230816/main/#install-free5gc-and-ueransim","title":"Install free5GC and UERANSIM","text":"<p>If you have only one interface on each Kubernetes node and its name is <code>toto</code>. Then you have to set these parameters to <code>toto</code>: <code>global.n2network.masterIf</code> <code>global.n3network.masterIf</code> <code>global.n4network.masterIf</code> <code>global.n6network.masterIf</code> <code>global.n9network.masterIf</code></p> <p><pre><code>kubectl create ns free5gc\ngit clone https://github.com/Orange-OpenSource/towards5gs-helm.git\ncd towards5gs-helm/charts/\nhelm -n free5gc install free5gc-v1 ./free5gc/\nhelm -n free5gc install ueransim-v1 ./ueransim/\nwatch kubectl get pods -n free5gc\n</code></pre> </p>"},{"location":"blog/20230816/main/#start-webconsole","title":"Start WebConsole","text":"<p>free5GC offers a user-friendly web tool called WebConsole, designed to facilitate the creation and management of User Equipment (UE) registrations. This tool serves as a valuable resource for multiple 5G network functions (NFs), streamlining the process of handling UE registrations and associated tasks. <pre><code>kubectl port-forward --namespace free5gc svc/webui-service 5000:5000\n</code></pre> Execute the following command in your local machine's terminal, and subsequently, you will be able to access the WebConsole via localhost:5000. You can login with username <code>admin</code> and password <code>free5gc</code>. <pre><code>ssh -L localhost:5000:localhost:5000 ubuntu@[VM ip]\n</code></pre> </p>"},{"location":"blog/20230816/main/#service-monitoring","title":"Service Monitoring","text":""},{"location":"blog/20230816/main/#install-prometheusgrafana-services","title":"install Prometheus/Grafana services","text":"<p>For monitoring Kubernetes, I utilized Prometheus and Grafana. The installation of Prometheus and Grafana services is facilitated through the Helm chart provided by the prometheus-community. <pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo update\nkubectl create namespace prometheus\nhelm install prometheus prometheus-community/kube-prometheus-stack -n prometheus\nwatch kubectl get pods -n prometheus\n</code></pre> </p> <p><pre><code>kubectl port-forward -n prometheus svc/prometheus-grafana 8080:80\n</code></pre> Execute the following command in your local machine's terminal, and subsequently, you will be able to access the WebConsole via localhost:8080. <pre><code>ssh -L localhost:8080:localhost:8080 ubuntu@[VM ip]\n</code></pre>  A variety of dashboards are available, offering different perspectives for those who are interested. Below is a snapshot of one such dashboard option.</p> <p></p>"},{"location":"blog/20230816/main/#reference","title":"Reference","text":"<p>https://free5gc.org/</p> <p>https://medium.com/rahasak/deploying-5g-core-network-with-free5gc-kubernets-and-helm-charts-29741cea3922</p> <p>https://github.com/Orange-OpenSource/towards5gs-helm</p> <p>https://github.com/k8snetworkplumbingwg/multus-cni</p>"},{"location":"blog/20230816/main/#about","title":"About","text":"<p>Hello, I am Elisa Lee. My ongoing research revolves around VoNR (Voice over New Radio). I encourage any inquiries or identification of errors within the article, as they are welcomed for correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20230823/20230823/","title":"Web security: CSRF vulnerability in webconsole","text":"<p>Note</p> <p>Author: Brian Chen (\u9673\u715c\u76db) Date: 2023/8/23</p>"},{"location":"blog/20230823/20230823/#abstract","title":"Abstract","text":"<p>This article is intended for individuals who possess an interest in free5gc/webconsole and hold concerns regarding security matters. It aims to provide a concise introduction to the webconsole, followed by an exposition of a significant security concern along with our corresponding solution. Within webconsole v1.2.0, aligning with the most recent iteration of free5gc v3.3.0, certain vulnerabilities have been identified that could potentially lead to the exposure of subscriber data. It is my responsibility to address and rectify these vulnerabilities, enhancing the webconsole's resilience against cyber attacks.</p>"},{"location":"blog/20230823/20230823/#webconsole-overview","title":"Webconsole Overview","text":"<p>The Webconsole serves as a web-based tool designed to manage User Equipment (UE) subscription data. It plays a crucial role in aiding the free5GC Core Network manager by facilitating the configuration of UEs and providing the ability to monitor the status of activated UEs.</p>"},{"location":"blog/20230823/20230823/#environment","title":"Environment","text":"<ul> <li>Frontend<ul> <li>React v17.0.2</li> <li>node.js v20.2.0</li> <li>yarn v1.22.19</li> </ul> </li> <li>Backend<ul> <li>Golang v1.17</li> <li>Gin v1.9.0</li> <li>MongoDB v3.6.8</li> </ul> </li> </ul>"},{"location":"blog/20230823/20230823/#install-run-webconsole","title":"Install &amp; Run webconsole","text":"<p>Prior to building webconsole, install nodejs and yarn package first:</p> <pre><code>sudo apt remove cmdtest\nsudo apt remove yarn\ncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt-get update\nsudo apt-get install -y nodejs yarn\n</code></pre> <p>To run free5GC webconsole server. The following steps are to be considered.</p> <pre><code>git clone https://github.com/free5gc/webconsole.git\ncd frontend\nyarn install\nyarn build\nrm -rf ../public\ncp -R build ../public\ncd ..\ngo run server.go\n</code></pre> <p>Default account and password is <code>admin/free5gc</code></p> <p></p>"},{"location":"blog/20230823/20230823/#pages","title":"Pages","text":""},{"location":"blog/20230823/20230823/#subscribers","title":"SUBSCRIBERS","text":"<p>Creation/deletion/editing the subscriber's data:</p> <p></p> <p>A Subscriber data contains these informations:</p> <ul> <li>PLMN ID</li> <li>SUPI (UE ID)</li> <li>AKA parameters</li> <li>S-NSSAI Configurations<ul> <li>Sst/Sd</li> <li>DNN<ul> <li>Name</li> <li>AMBR</li> <li>Flow Rules<ul> <li>IP Filter</li> <li>Precedence</li> <li>5QI</li> <li>GBR</li> <li>MBR</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p></p>"},{"location":"blog/20230823/20230823/#tenant-and-user","title":"TENANT AND USER","text":"<p>The Webconsole also allows for the creation, deletion, and editing of tenants. A tenant functions as an access control group, delineating specific permissions and boundaries. In this setup, if you do not possess admin privileges, you are unable to access subscriber data generated by other tenants, ensuring data privacy and security.</p> <p></p> <p>Furthermore, the capability to incorporate users within a tenant is available. To illustrate, by selecting the brian1 tenant and clicking on the New User option, it becomes possible to introduce a new user. As an example, a user with the email address aaabbb@gmail.com can be added through this process.</p> <p></p> <p>The data within MongoDB can be accessed and reviewed using the MongoDBCompass tool.</p> <p></p>"},{"location":"blog/20230823/20230823/#csrf-cross-site-request-forgery-vulnerability","title":"CSRF (Cross-Site Request Forgery) Vulnerability","text":"<p>The vulnerability was discovered by INCIBE, and they promptly notified the free5GC team via email. </p> <p>The corresponding issue related to this vulnerability is also documented in the free5gc repository. Despite the typical deployment of the webconsole within LAN or Docker environments, it's essential to exercise caution regarding users who operate this service on a public IP or within an insecure network environment.</p> <p>In a nutshell, an attacker can gain unauthorized access to the database by merely setting the token to the term 'admin'. <pre><code>$ curl '&lt;webconsole's IP&gt;:5000/api/subscriber' -H 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0' -H 'Accept: application/json' -H 'Accept-Language: en-US,en;q=0.5' -H 'Accept-Encoding: gzip, deflate' -H 'Referer: http://&lt;webconsole's IP&gt;:5000/' -H 'Connection: keep-alive' -H 'X-Requested-With: XMLHttpRequest' -H 'Token: admin' -H 'Pragma: no-cache' -H 'Cache-Control: no-cache'\n</code></pre></p> <p>Subsequently, they can directly retrieve subscriber information from the server's MongoDB. <pre><code>[{\"plmnID\":\"20893\",\"ueId\":\"imsi-208930000000003\"}]\n</code></pre></p> <p>Undoubtedly, this vulnerability is of significant concern since the intended safeguard, allowing access solely to admin, has been compromised, thereby enabling easy access for anyone.</p>"},{"location":"blog/20230823/20230823/#trace-code","title":"Trace Code","text":""},{"location":"blog/20230823/20230823/#frontend","title":"Frontend","text":"<p>In <code>webconsole/frontend/src/util/AuthHelper.js</code></p> <ul> <li>In scenarios where the default username and password (admin/free5gc) are employed, the <code>ApiHelper.login()</code> function remains untouched. This practice might expedite agile development, but it comes at the cost of compromising security.</li> </ul> <p></p>"},{"location":"blog/20230823/20230823/#backend","title":"Backend","text":"<p>In <code>webconsole/frontend/WebUI/api_webui.go</code> - In situations where a webconsole client configures the <code>tokenStr</code> as 'admin', the backend process will omit the execution of <code>ParseJWT()</code>.</p> <p></p>"},{"location":"blog/20230823/20230823/#json-web-token-jwt","title":"JSON Web Token (JWT)","text":"<p>The Webconsole relies on JSON Web Token (JWT) as its authentication mechanism, a specification outlined in RFC 7519.</p> <p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties.  The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.</p> <p>When a client employs a web browser to initiate a login via the HTTP(s) protocol, the Web server is expected to furnish the client with a JWT token in response. Subsequently, the client employs this JWT token to interact with resources by sending requests through the RESTful API (such as GET, POST, PUT, etc.).</p> <p>A JSON Web Token (JWT) consists of three distinct parts. In the context of the webconsole backend, the following fields are relevant:</p> <ul> <li>Header: This section contains information about the type of token and the signing algorithm used. It often includes the \"alg\" (algorithm) and \"typ\" (type) fields.</li> <li>Payload: The payload holds the actual claims or data that are being conveyed by the token. For the webconsole backend, specific fields within this section could include:<ul> <li>Claim (JSON object)<ul> <li><code>sub</code>: identifies the principal that is the subject of the JWT.</li> <li><code>iat</code>: identifies the time at which the JWT was issued.</li> <li><code>exp</code>: identifies the expiration time onor after which the JWT MUST NOT be accepted for processing.</li> <li><code>email</code></li> <li><code>tenantId</code></li> <li>...(you can design the attribute yourself)</li> </ul> </li> </ul> </li> <li>Signature: This component is created by combining the encoded header and payload with a secret key (or a public/private key pair) to ensure the token's integrity and authenticity. The signature allows the recipient to verify that the token hasn't been tampered with.</li> </ul> <p>The JWT Claims Set represents a JSON object whose members are the claims conveyed by the JWT.  The Claim Names within a JWT Claims Set MUST be unique; JWT parsers MUST either reject JWTs with duplicate Claim Names or use a JSON parser that returns only the lexically last duplicate member name</p> <p>The image depicted below illustrates the process of using jwt.io to both encode and decode JWT tokens. These tokens are segmented into distinct sections denoted by the red, purple and blue divisions, separated by periods dots.</p> <p></p> <p>Given that the Payload can be decoded using the algorithm specified in the Header, it's essential to refrain from including sensitive details like passwords or credit card numbers within it. Instead, the Payload typically holds claims and application-specific metadata.</p> <p>To maintain the security of the process, the server retains a confidential key used to validate the signature. In situations where a client endeavors to access a resource using a JWT token that possesses an incorrect Verify Signature, an error response will be generated. This stringent signature verification mechanism ensures that the authenticity and integrity of both the token and its enclosed data are upheld.</p>"},{"location":"blog/20230823/20230823/#trace-code-cont","title":"Trace Code (Cont.)","text":"<p>In <code>webconsole/frontend/WebUI/api_webui.go</code>, we can find the implementation of JWT.</p> <ul> <li><code>JWT()</code> is for encoding: <pre><code>func JWT(email, userId, tenantId string) string {\n    token := jwt.New(jwt.SigningMethodHS256)\n\n    claims := token.Claims.(jwt.MapClaims)\n    claims[\"sub\"] = userId\n    claims[\"iat\"] = time.Now()\n    claims[\"exp\"] = time.Now().Add(time.Hour * 24).Unix()\n    claims[\"email\"] = email\n    claims[\"tenantId\"] = tenantId\n\n    if jwtKey == \"\" {\n        return \"\"\n    }\n\n    tokenString, err := token.SignedString([]byte(jwtKey))\n    if err != nil {\n        logger.ProcLog.Errorf(\"JWT err: %+v\", err)\n        return \"\"\n    }\n\n    return tokenString\n}\n</code></pre></li> <li><code>ParseJWT()</code> is for decoding: <pre><code>func ParseJWT(tokenStr string) (jwt.MapClaims, error) {\n    token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n        return []byte(jwtKey), nil\n    })\n    if err != nil {\n        return nil, errors.Wrap(err, \"ParseJWT error\")\n    }\n\n    claims, _ := token.Claims.(jwt.MapClaims)\n\n    return claims, nil\n}\n</code></pre></li> <li>The function <code>CheckAuth()</code> serves the purpose of determining whether a user possesses the authorization to access a particular resource.</li> </ul> <pre><code>func CheckAuth(c *gin.Context) bool {\n    tokenStr := c.GetHeader(\"Token\")\n    if tokenStr == \"admin\" {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li> <p>The secret key utilized for signature verification is obtained through <code>os.Getenv(\"SIGNINGKEY\")</code>. However, there's a possibility that <code>SIGNINGKEY</code> might not be exported as an environment variable, leading to a potential return of an empty value. Under such circumstances, an implication arises: an admin in Webconsole A could potentially gain access to subscriber data within Webconsole B.</p> </li> <li> <p>Within the <code>CheckAuth()</code> function, if the client sets the JWT token to 'admin', the function will evaluate to true, effectively allowing the check to be passed.</p> </li> </ul>"},{"location":"blog/20230823/20230823/#implementation","title":"Implementation","text":""},{"location":"blog/20230823/20230823/#check-authentication","title":"Check Authentication","text":"<p>Initially, I have revised the design of the <code>CheckAuth()</code> function to ensure the mandatory execution of <code>ParseJWT()</code>. <pre><code>func CheckAuth(c *gin.Context) bool {\n    tokenStr := c.GetHeader(\"Token\")\n    claims, err := ParseJWT(tokenStr)\n\n    if err == nil &amp;&amp; claims[\"email\"] == \"admin\" {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> Furthermore, I've implemented a second change where, considering that the webconsole v1.2.0 doesn't inherently establish a tenant named 'admin' or a user named 'admin', I propose a more effective approach. During the initialization of the webconsole backend, it is recommended to generate an 'admin' tenant and user. This means that executing <code>go run server.go</code> within the <code>webconsole/</code> directory should consistently generate an admin user, thereby fulfilling the initial login requirement.</p> <p></p> <p>Certainly, in the <code>backend/WebUI/api_webui.go</code> file, I propose the addition of a function named <code>SetAdmin()</code>. To streamline the process and maintain consistency with the rest of the free5GC project, it is recommended to leverage the <code>mongoapi</code> module established within the <code>free5gc/util</code> repository. Given the project's heavy reliance on MongoDB, employing <code>mongoapi</code> over frequent calls to <code>mongo-driver</code> is essential to ensure efficiency and coherence.</p> <pre><code>func SetAdmin() {\n    err := mongoapi.RestfulAPIDeleteOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIDeleteOne err: %+v\", err)\n    }\n    err = mongoapi.RestfulAPIDeleteOne(\"userData\", bson.M{\"email\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIDeleteOne err: %+v\", err)\n    }\n\n    // Create Admin tenant\n    logger.InitLog.Infoln(\"Create tenant: admin\")\n\n    adminTenantData := bson.M{\n        \"tenantId\":   uuid.Must(uuid.NewRandom()).String(),\n        \"tenantName\": \"admin\",\n    }\n\n    _, err = mongoapi.RestfulAPIPutOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"}, adminTenantData)\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIPutOne err: %+v\", err)\n    }\n\n    AmdinTenant, err := mongoapi.RestfulAPIGetOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIGetOne err: %+v\", err)\n    }\n\n    // Create Admin user\n    logger.InitLog.Infoln(\"Create user: admin\")\n\n    hash, err := bcrypt.GenerateFromPassword([]byte(\"free5gc\"), 12)\n    if err != nil {\n        logger.InitLog.Errorf(\"GenerateFromPassword err: %+v\", err)\n    }\n\n    adminUserData := bson.M{\n        \"userId\":            uuid.Must(uuid.NewRandom()).String(),\n        \"tenantId\":          AmdinTenant[\"tenantId\"],\n        \"email\":             \"admin\",\n        \"encryptedPassword\": string(hash),\n    }\n\n    _, err = mongoapi.RestfulAPIPutOne(\"userData\", bson.M{\"email\": \"admin\"}, adminUserData)\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIPutOne err: %+v\", err)\n    }\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#jwt-verify-signature","title":"JWT Verify Signature","text":"<p>Certainly, within the <code>backend/WebUI/api_webui.go</code> file, I recommend introducing a string variable named <code>jwtKey</code> to serve as the private key for JWT Verify Signature. Although the length of jwtKey is specified as 256 bytes, it's worth noting that the distinction between 256 bytes and 256 bits is inconsequential in this context. The jwt module will adeptly transform the key to a 256-bit form. For further insights, you can refer to issue 28.</p> <pre><code>var jwtKey = \"\" // for generating JWT\n\n/* ... */\n\nfunc InitJwtKey() error {\n    randomBytes := make([]byte, 256)\n    _, err := rand.Read(randomBytes)\n    if err != nil {\n        return errors.Wrap(err, \"Init JWT key error\")\n    } else {\n        jwtKey = string(randomBytes)\n    }\n    return nil\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#backend-initialization","title":"Backend Initialization","text":"<p>In <code>backend/webui_service/webui_init.go</code>:</p> <pre><code>func (a *WebuiApp) Start(tlsKeyLogPath string) {\n    /* ... */\n    WebUI.SetAdmin()\n    if err := WebUI.InitJwtKey(); err != nil {\n        logger.InitLog.Errorln(err)\n        return\n    }\n    /* ... */\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#frontend-login","title":"Frontend Login","text":"<p>Certainly, in the <code>frontend/src/util/AuthHelper.js</code> file, it is advised to remove the section of code that could be considered a \"cheating snippet.\" To ensure a robust authentication process, all users should be required to successfully pass through the <code>ApiHelper.login</code> function and receive a response code of 200. This approach ensures a consistent and legitimate authentication mechanism.</p> <pre><code>static async login(username, password) {\n    let response = await ApiHelper.login({username: username, password: password});\n\n    if (response !== undefined &amp;&amp; response.status === 200) {\n      var user = null\n      if (username == \"admin\") {\n        user = new User(username, \"System Administrator\", response.data.access_token);\n      } else {\n        user = new User(username, \"User\", response.data.access_token);\n      }\n      LocalStorageHelper.setUserInfo(user);\n      store.dispatch(authActions.setUser(user));\n      return true;\n    } else {\n      return false;\n    }\n  }\n</code></pre>"},{"location":"blog/20230823/20230823/#conclusion","title":"Conclusion","text":"<p>In this endeavor, we've successfully addressed the CSRF vulnerability issue, as highlighted in issue #387 and acknowledged by INCIBE. Furthermore, I've introduced the concept of JWT tokens in this article, detailing their implementation and the corresponding adjustments made within the webconsole. You can locate the detailed implementation in the merged PR #44 of the webconsole repository. I'd like to extend my gratitude to the contributors kishiguro and LaumiH for their significant role in refactoring the webconsole. As a result of their efforts, the webconsole UI has been notably enhanced. Our upcoming focus involves the integration of the charging function, which we are actively pursuing.</p>"},{"location":"blog/20230823/20230823/#reference","title":"Reference","text":"<p>free5gc/webconsole merged PR #44 free5gc issue #387 free5gc issue #28 JSON Token RFC 7519 MongoDBCompass</p>"},{"location":"blog/20230823/20230823/#about","title":"About","text":"<p>Hello everyone,</p> <p>I'm Brian Chen (\u9673\u715c\u76db), and I've been immersed in the realm of 5G Core Network technologies. Over the course of seven months, I've had the privilege of serving as an intern at Saviah. In this role, my responsibilities encompass a spectrum of tasks including maintenance, development, and rigorous testing of the free5GC project.</p> <p>Should any inquiries, questions, or bug reports regarding free5GC arise, I encourage you to reach out by creating an issue in the free5gc repository or by participating in discussions on the forum. I'm here to assist and collaborate with the community as we navigate the intricacies of this project.</p> <p>Warm regards, Brian Chen (\u9673\u715c\u76db)</p> <ul> <li>Github</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20230830/20230830/","title":"Article Sharing: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)","text":"<p>Note</p> <p>Author: Lin Poyi Date: 2023/8/30</p> <p>Original Paper: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</p>"},{"location":"blog/20230830/20230830/#overview","title":"Overview","text":"<p>This article shows why extended Berkeley Packet Filter (eBPF) is a powerful tool to use on cloud-native platforms. Using specific eBPF programs to improve network observability and runtime security. Also, present a platform named Sauron to demonstrate how eBPF allows us to write custom code and dynamically load eBPF programs into the kernel. These programs can be used to derive performance counters and gauges for transport networks, 5G applications, and non-access stratum protocols.</p>"},{"location":"blog/20230830/20230830/#layout-of-ebpf","title":"Layout of eBPF","text":"<ul> <li>eBPF programs: run in the kernel to react to events.</li> <li>User space programs: load eBPF programs to the kernel and interact with them.</li> <li>eBPF Maps: allow data storage and information sharing between eBPF/User space programs.<ul> <li>There are different types of eBPF Maps, for example: Hash, Array, etc. A special type of eBPF Maps is called per-CPU map, since it is only accessed by one CPU and the eBPF process cannot be preempted, there's no lock needed. As a result, the performance is better.</li> </ul> </li> </ul> <p>Development phase:</p> <ol> <li>A program is compiled into an object Executable and Linkable Format (ELF) file. Using compiler suites like clang/LLVM to compile it into eBPF bytecode.</li> <li>The ELF file is loaded into the kernel using a monolithic approach enabled by bpf system calls.</li> <li>Maps are created in the kernel space. The eBPF programs can utilize eBPF maps to share data and preserve the state.</li> </ol> <p>Runtime phase:</p> <ol> <li>The eBPF program is loaded into the kernel to be verified by eBPF verifier and to be compiled by JIT Compiler into native instructions.</li> <li>The eBPF program is attached to selected events (injected in the desired kernel hooks). The eBPF program is executed once the event has occurred.</li> </ol> <p>Higher-level networking constructs can be created by combining the hooks below:</p> <ul> <li>Express Data Path (XDP): XDP BPF hook can be attached to the networking driver. The eBPF program is triggered when a packet arrives in the driver.</li> <li>Traffic Control ingress/egress: hooking eBPF programs to the traffic control ingress/egress. The eBPF program is triggered after the initial packet processing.</li> <li>Socket operations</li> </ul>"},{"location":"blog/20230830/20230830/#ebpfs-for-kubernetes","title":"eBPF's for Kubernetes","text":""},{"location":"blog/20230830/20230830/#container-networking","title":"Container Networking","text":"<p>In K8s, the kernel typically runs a networking stack for each pod. The data path is convoluted, as shown in a). eBPF can simplify the networking stack in the kernel, and connect pods as endpoints.</p> <p></p> <p>This is an example of load balancing between four replicated pods on two worker nodes. Using eBPF service (svc) Map to replace the iptables rules. This allows operators to transport data directly from inbound sockets to outbound sockets, which enables super-fast service load balancing with eBPF.</p>"},{"location":"blog/20230830/20230830/#service-mesh","title":"Service Mesh","text":"<p>A Service Mesh is a dedicated infrastructure layer that can be added to applications or Cloud-Native Network Function (CNF) micro-services. Provides connectivity between applications at the service level, and offers features such as observability, security, and traffic management.</p> <p></p> <p>The traditional approach (left) was to use a Service Mesh Library. It requires the Service Mesh Library to be written in the application's language framework.</p> <p>Then Service Mesh was achieved by implementing a cloud-native Sidecar Model (middle). With the Service Mesh Sidecar run as a proxy outside of the application, there's no limit to the language being used. And there's no modification needed to be done in the application code.</p> <p>Service Mesh which utilizes eBPF (right) has fewer resources used since duplicate copies of state configuration information within each pod are no longer needed. Also, there's no pod configuration to be modified. In addition, eBPF is aware of all activities carried out on that node, which can provide extra security.</p>"},{"location":"blog/20230830/20230830/#sauron-concept-and-architecture","title":"Sauron concept and architecture","text":"<p>The proposed eBPF platform, named Sauron, includes a Node Agent, a Controller to handle the Node Agents (NAs) deployed in the clusters, and three eBPF modules for observability, security, and networking use cases. There's no installation of any specific K8s plug-in needed.</p>"},{"location":"blog/20230830/20230830/#sauron-ebpf-module-for-transport","title":"Sauron eBPF module for transport","text":""},{"location":"blog/20230830/20230830/#ebpf-solutions-for-latency-calculation","title":"eBPF solutions for latency calculation","text":"<p>By leveraging the XDP hook, the programs can inspect or modify the content of the packets, but they can also decide whether to redirect or drop them. Moreover, through eBPF helpers, they can perform more advanced actions such as timestamping.</p> <p></p> <p>The eBPF program utilizes an XDP feature that allows it to redirect the synthetic packet through the same interface at which it was received. The program also adds a timestamp of each action (send or receive) to the packet payload. The packet will bounce between the receiving device and the original sender for a fixed number of times. After the final iteration, the original sender passes the packet to the Sauron Agent through the socket interface. The Sauron Agent then uses the collected timestamps to calculate both One-way and Two-way latency. Once the calculation is done, the data can be exported to a remote collector for processing and visualization.</p>"},{"location":"blog/20230830/20230830/#sauron-module-for-network-observability","title":"Sauron module for network observability","text":"<p>The Sauron Agent configures the necessary eBPF programs and collects the messages using a Ring buffer or throughout eBPF Maps. It also detects containers and pods of the 5GC network by querying the API server. The Agent can be configured to collect information from all parts of the network (radio access and core domains) with minimal overhead.</p>"},{"location":"blog/20230830/20230830/#sauron-ebpf-module-for-security","title":"Sauron eBPF module for security","text":"<p>eBPF Traffic Control Programs are used to implement network security. The primary job is to detect policy violations and enforce configured rules on unwanted traffic. Unwanted traffic could be:</p> <ol> <li>Traffic directed to or coming from entities that are not allowed to communicate with the object pod.</li> <li>Malicious traffic directed to or coming from sources that are allowed to communicate with the object pod but not authorized to perform certain tasks.</li> <li>Malicious traffic that insists on a disallowed communication path.</li> </ol> <p>eBPF tracepoints programs are attached to static markers defined by kernel developers in the kernel code. Tracepoints can be used to track events related to multiple subsystems, including sched, netlink, and system call (only syscall is shown in the graph). Static markers implementing the hook points guarantee the Application Binary Interface for tracepoints to be more stable than the one available for kprobes.</p> <p>Even though kprobes are not as effective or stable as tracepoints, they allow the implementation of an additional layer of defense. By tapping deeper into the system calls implementation, it is possible to solve the well-known Time-Of-Check Time-Of-Use vulnerability of tracepoints.</p> <p>eBPF Linux Security Module (LSM) programs also add an additional layer of security to the kernel. They can detect malicious behaviors and deny the access and permission directly in the kernel. By doing this, they provide faster response than tracepoint and kprobe programs.</p> <p>The agent in user space provides all rules for detecting malicious behavior to eBPF programs via eBPF maps. The eBPF programs in kernel space sent three kinds of data to the Agent: samples of normal events, suspicious events, and malicious events. Suspicious events will be classified in the agent. Then all collected data will be sent to a cluster-wide events collector, which can build an AI/ML model using the collected events to enforce rules in each agent or provide a plugin-based interface to a third-party system.</p>"},{"location":"blog/20230830/20230830/#ebpf-for-performance-monitoring-of-5g-protocols","title":"eBPF for performance monitoring of 5G protocols","text":""},{"location":"blog/20230830/20230830/#ngap-and-nas-performance-monitoring","title":"NGAP and NAS performance monitoring","text":"<p>NAS messages are encapsulated into NGAP messages and NGAP relies on the SCTP of the 5G transport network layer. To extract information from NGAP messages, we need to parse SCTP packets containing multiple data chunks that can be fragmented. Since XDP and TC hooks are at the packet level, they're not suitable for handling NGAP messages. To have direct access to messages, using tracepoint hooks is the way to go.</p> <p>Examples of NGAP and NAS metrics:</p> <ul> <li>NGAP Initial Context Setup Counters</li> <li>NGAP Setup Success Ratio</li> <li>NGAP Setup Time (ms)</li> <li>NGAP Procedure Duration (ms)</li> <li>NGAP Failed Procedures Cause Code</li> <li>PDU Session Establishment Attempts</li> </ul>"},{"location":"blog/20230830/20230830/#packet-capturing-and-forwarding","title":"Packet capturing and forwarding","text":"<ol> <li>A libpcap probe is installed on the interface.</li> <li>Packets pass through the BPF filter installed on the interface.</li> <li>Matching packets flow to the agent.</li> <li>The agent encodes incoming packets in PCAPNG format.</li> <li>Send them to the processing probe.</li> </ol>"},{"location":"blog/20230830/20230830/#ebpf-for-estimating-energy-consumption","title":"eBPF for estimating energy consumption","text":""},{"location":"blog/20230830/20230830/#conclusion","title":"Conclusion","text":"<p>Using eBPF is hard. The way of implementation also changes based on what version of kernel is used. There's no easy packaging solution. Developers need to be familiar with not only the eBPF library but also the kernel they're working with.</p> <p>Although the development of eBPF might be challenging, it can be used to provide great observability, security, and networking in a cloud-native environment. Allow developers to dynamically program the kernel in a safe, performant, and scalable way. By leveraging the benefit of low overhead monitoring and close-to-source data processing, eBPF will be handy for real-time monitoring 5GC, or even boost the performance of K8s deployments.</p>"},{"location":"blog/20230830/20230830/#about","title":"About","text":"<p>Poyi Lin</p> <ul> <li>Graduate student majoring in 5GC Research</li> </ul>"},{"location":"blog/20230830/20230830/#reference","title":"Reference","text":"<ul> <li>eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</li> </ul>"},{"location":"blog/20230906/0905-2023blog/","title":"The role of VNFD and NSD in 5G Network Slicing","text":"<p>Note</p> <p>Author: Leon Sawada(\u6fa4\u7530\u535a\u4e45) Date: 2023/09/05</p>"},{"location":"blog/20230906/0905-2023blog/#overview","title":"Overview","text":"<p>Before you read this blog article, I highly recommend you read this blog article first:  How to deploy a free5GC network slice on OpenStack. This blog article was written by my friend Daniel Hsieh, and in his article, he went through the entire process of how to deploy a free5GC network slice on OpenStack. He also introduced some architectures we need to know when we are deploying the free5GC network slice. However, there are still some details remaining, so in this blog article, I will explore more information and what role these components play in the overall experiment. Daniel used 8 steps to explain how to [deploy a free5GC Network Slice].In this article, I am going to focus on VNFD and NSD, which appear in steps No.5 and No.6, these two most important concepts while we are creating the network slice. By this article, you will understand more about the 5G network slicing.</p>"},{"location":"blog/20230906/0905-2023blog/#vnfd","title":"VNFD","text":"<p>VNFD, You may have seen this word a few times in Daniel\u2019s blog posts already, but what exactly is VNFD? Before I tell you the answer directly, there is something I want you to know first.</p> <p>We know that network slicing is a technology that allows network operators to divide physical network infrastructure into multiple customized virtual network slices, and each of the slices can meet specific requirements for specific use cases.  One of the most important functions of 5G network slicing is the virtual network function (VNF). VNF is a virtualized network service running on an open computing platform. In this free5GC network slicing experiment, the VNF in our experiment is our NF in free5GC, such as UPF, NSSF, UDM... etc. When you load all your VNFs into OpenStack, it should be like this:</p> <p></p> <p>So what is VNFD? What is the connection between it and VNF? VNFD's full name is Virtual Network Function Descriptor. A VNFD is a deployment template that describes a VNF in terms of deployment and operational behavior requirements. It also contains connectivity, interface, and virtualized resource requirements. The VNFD conforms to the GS NFV-SOL 001 specifications and standards specified by ETSI. The Virtual Network Function Descriptor (VNFD) file describes the instantiation parameters and operational behaviors of the VNFs. It contains KPIs and other key requirements that can be used in the process of onboarding and managing the lifecycle of a VNF. Each VNFD template has the following fields:</p> <p></p> <p>In the deployment of free5GC network slicing experiment, if you onboard all your VNFs successfully, then your VNFD should also be like this:</p> <p></p> <p>As you can see, every VNFD is matched with its represented VNF and its IP address, VNFD acts as a blueprint or template for VNF. Also be aware that The VNFD is a static description file, not a dynamic configuration file. The metadata description in the VNFD is not changed during the whole VNF lifecycle. Some VNF parameters described in the VNFD can be declared to be configurable during the VNF design phase, and further be configured by the VNFM during or after VNF instantiation.</p>"},{"location":"blog/20230906/0905-2023blog/#vnfd-architecture-and-details","title":"VNFD Architecture And Details","text":"<p>The UML representation of the VNFD high-level structure is shown in the figure below.</p> <p></p> <p>The ETSI released a specification that defines the requirements for the structure and format of a VNFD. As you can see, this graph illustrates the high\u2010level structure of a VNFD. The VNFD is composed of one or many virtual deployment units (VDUs) that describe the deployment resources and operation behavior of a VNF component (VNFC). Virtual Deployment Unit(VDU) is a basic part of VNF. It is the VM that hosts the network function. They are virtual machines that host the VNF or parts of it. Each part of the VNF is a VNFC and can be deployed on one or more VDUs. Each VDU is characterized, among other elements, by the software image loaded on it and the resources needed to deploy it. That is the flavor of Nova in OpenStack, which can set Disk, Memory, CPU, etc. An NS(Network Service) might contain different VNF. A VNF might also contain different VDU. Each level puts constraints on the subsequent levels, information in a lower level does not appear in a higher level. This is a complex and flexible architecture, very beautiful, very powerful.</p> <p>The following graph shows the composition of the virtual deployment unit in a VNFD:</p> <p></p> <p>This graph illustrates a VDU deployment view. A VDU describes mainly the virtual compute (VC), virtual storage (VS), and virtual memory (VM) resources that are necessary for deploying a VNFC, and it could be linked via connection points (CPD) to other VDUs or to external VDUs that belong to other VNFs via external CPD. Virtual links in the VNFD indicate how the VDUs are connected and via which CPD. This means that different VDUs can be connected to each other through the CPD. However, in free5GC network slicing, things might be different. For 5G's NS (network slice), since there are already many VNFs in 5G, under the 5G network slice architecture, an NS contains many VNFs, but a VNF always contains one and only VDU. We use AMF as an example, (AMF is an NF in free5GC) AMF is an important and complete function and we didn't break it into more pieces. Therefore, there are not many examples in our 5G of a VNF having many VDUs. Each VNF contains one VDU only, and the via connection points (CPD) function will no longer be used in 5G network slicing, although it is a powerful and convenient function.</p>"},{"location":"blog/20230906/0905-2023blog/#nsd","title":"NSD","text":"<p>NSD is a template file, whose parameters follow the ETSI MANO specification, used by the NFV Orchestrator (NFVO) for deploying network services (as a combination of multiple VNFs). Which consists of information used by the NFV Orchestrator (NFVO) for the life cycle management of an NS. Just like VNFD, NSD is also a static configuration file.</p> <p>An NS is a composition of Network Functions (NF) arranged as a set of functions with unspecified connectivity between them or according to one or more forwarding graphs. As the following figure shows, the description of an NS as used by the NFV Management and Orchestration (MANO) functions to deploy an NS instance includes or references the descriptors of its constituent objects:</p> <p></p> <p>As the specification mentioned in ETSI GS NFV-IFA 014 V3.3.1, an NSD references at least one VNFD or one nested NSD, just like this graph has shown. Here is an example code if today we want to instantiate VNF1 and VNF2 in the experiment.</p> <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\nimports:\n  - VNFD1\n  - VNFD2\ntopology_template:\n  node_templates:\n    VNF1:\n      type: tosca.nodes.nfv.VNF1\n      requirements:\n        - virtualLink1: VL1\n        - virtualLink2: VL2\n    VNF2:\n      type: tosca.nodes.nfv.VNF2\n    VL1:\n      type: tosca.nodes.nfv.VL\n      properties:\n      network_name: net0\n      vendor: tacker\n    VL2:\n      type: tosca.nodes.nfv.VL\n      properties:\n          network_name: net_mgmt\n          vendor: tacker\n</code></pre> <p>In the above NSD template, VL1 and VL2 are substituting the virtual links of VNF1. If we want to apply the NFs we have in free5GC, just import these NFs into the VNF to which they belong.</p> <p>To onboard the above NSD:</p> <pre><code>tacker nsd-create \u2013nsd-file &lt;nsd file&gt; &lt;nsd name&gt;\n</code></pre> <p>This is also how we can use NSD to import all the VNFs we want to create network slices. It is very easy and convenient to create free5GC network slice that we want, the step was mentioned in Dainel's blog article.</p>"},{"location":"blog/20230906/0905-2023blog/#deployment-flavor","title":"Deployment flavor","text":"<p>Please go back to the VNFD high-level structure, On the right side we can see the DnfDf, which stands for VNF deployment flavor. Deployment flavor is a very important concept in NSD and VNFD, therefore it needs to be explained separately. Since VNFD and NSD are not dynamic configuration files but static configuration files. Even static configuration file has their own advantages, however, they are irreversible and lack of flexibility. To overcome this problem, we have a concept called deployment flavor. While we are using these static configuration files, we can have different deployment flavors, therefore when we are deploying these static configuration files, we can have different ways to deploy them. For example, when we deploy them, we use the 10 MB memory, and we use 100 MB memory to deploy another one. In this example, while we are deploying our deployment parameters are different, then we can define it into deployment flavor. Deployment flavor helps NSD and VNFD to increase their flexibility as a static configuration file. Make sure it's not 100% unchangeable. We can deploy different types of Deployment_Flavor that case needs, like Deployment_Flavor#2, Deployment_Flavor#3, and Deployment_Flavor#4. Therefore, we can deploy different NS and VNF for different specific needs. Add some deployment flexibility as much as possible under the limitation that they are static configuration files.</p> <p></p> <p>That's it, I hope this blog article can help you learn more about 5G network slicing, even if you go back and read this previous blog post How \u200b\u200bto deploy free5GC network slicing on OpenStack now, I think you will have a clearer idea of \u200b\u200bhow the whole experiment works. Learning the theory behind the scenes will always help you further your studies.</p>"},{"location":"blog/20230906/0905-2023blog/#reference","title":"Reference","text":"<p>https://docs.openstack.org/tacker/latest/contributor/vnfd_template_description.html</p> <p>https://docs.openstack.org/tacker/ocata/devref/nsd_usage_guide.html</p> <p>Atoui, Wassim &amp; Assy, Nour &amp; Gaaloul, Walid &amp; Grida Ben Yahia, Imen. (2020). Configurable Deployment Descriptor Model in NFV. Journal of Network and Systems Management. 28. 10.1007/s10922-020-09531-2.</p> <p>Automated Network Service Scaling in NFV: Concepts, Mechanisms and Scaling Workflow</p> <p>ETSI GS NFV-IFA 011 V2.4.1</p> <p>ETSI GS NFV-IFA 014 V3.3.1</p>"},{"location":"blog/20230906/0905-2023blog/#about","title":"About","text":"<p>Greetings everyone, my name is Leon Sawada, I am a 2nd-year master's student in NYCU Wireless Internet Research and Engineering (WIRE) Laboratory. My research field is network slicing, and I will be very grateful if this blog article helps you understand more about these components in network slicing. Best wishes.</p>"},{"location":"blog/20230913/20230913/","title":"CHarging Function(CHF) Overview","text":"<p>Note</p> <p>Author: Benson Hsu Date: 2023/9/13</p> <p>The <code>charging function</code> is a crucial component of the 5G core network responsible for tasks such as <code>traffic calculation and quota management</code>. For network providers and administrators, it is one of the most critical network elements. This article will explain the fundamental concepts and mechanisms of charging, as well as highlight the differences between 4G and 5G charging. Finally, we will include information about the CHF implementation developed by the free5GC team. </p>"},{"location":"blog/20230913/20230913/#charging-mechanisms","title":"Charging Mechanisms","text":"<p>The charging system can be divided into three main types: offline charging, online charging, and converged charging:</p> <ul> <li> <p>Offline Charging:</p> <ul> <li>After network resource usage, charging information is transmitted from the network to the Billing Domain (BD).</li> <li>The Billing Domain is responsible for performing cost calculations and data statistics.</li> </ul> </li> <li> <p>Online Charging:</p> <ul> <li>Before network resource usage, the network sends an authentication request to the Online Charging System (OCS).</li> <li>The OCS queries the subscriber's account information to determine whether the usage of these resources is allowed.</li> <li>After receiving authentication from the OCS, resource usage is monitored, and related account information is stored in the OCS.</li> </ul> </li> <li> <p>Converged Charging:</p> <ul> <li>Converged charging is a mechanism that combines both online and offline charging.</li> <li>For example, the CHF (Converged Charging Function) architecture in the 5G core system is an example of converged charging.</li> <li>In other service systems, if the charging system includes both offline and online charging functionalities, it can also be referred to as converged charging.</li> </ul> </li> </ul> <p>Typical triggers for charging related to network resource usage include:</p> <ul> <li>A voice call of a certain duration.</li> <li>The transport of a certain volume of data.</li> <li>The submission of a multimedia message (MM) of a certain size.</li> </ul> <p>Resource usage requests can be triggered by the UE  or by the core network. Furthermore, for the same chargeable event, both offline and online charging can occur simultaneously and independently.</p>"},{"location":"blog/20230913/20230913/#high-level-common-architecture","title":"High Level Common Architecture","text":"<p>The diagram below is from 3GPP TS32.240-V15.5.0, which illustrates the architectural differences among the three charging systems and indicates through which reference points data is transmitted for each Network Element (NE). </p>"},{"location":"blog/20230913/20230913/#offline-charging-function","title":"Offline Charging Function","text":"<p>The Offline Charging Function primarily consists of three components: CTF (Charging Trigger Function), CDF (Charging Data Function), and CGF (Charging Gateway Function). Here's an overview of the roles of each function and how data flows between them:</p> <ol> <li>CTF (Charging Trigger Function):</li> <li>Role: CTF is responsible for generating charging events by observing network resource usage.</li> <li>Data Flow: It collects information about trigger conditions, information elements to be collected, and which service events, signaling, or user traffic to monitor.</li> <li> <p>Data Transfer: CTF forwards generated charging events to CDF.</p> </li> <li> <p>CDF (Charging Data Function):</p> </li> <li>Role: CDF receives charging events from CTF and processes them.</li> <li>Data Flow: It processes and stores charging data, potentially performing reformatting to comply with specific formats.</li> <li> <p>Data Transfer: CDF sends the processed Charging Data Records (CDRs) to CGF.</p> </li> <li> <p>CGF (Charging Gateway Function):</p> </li> <li>Role: CGF is responsible for persistent CDR storage, preparing CDR files, and transferring them to the Billing Domain (BD).</li> <li>Data Flow: It provides storage for CDRs and manages the routing of CDR files.</li> <li>Data Transfer: CGF transfers CDR files to the Billing Domain via the Bx reference point.</li> </ol> <p>These functions work together to collect, process, and store charging data in the offline charging system.</p>"},{"location":"blog/20230913/20230913/#online-charging-functionsocf","title":"Online Charging Functions(OCF)","text":"<p> The Online Charging Function primarily consists of four components: CTF (Charging Trigger Function), OCF (Online Charging Function), ABMF (Account Balance Management Function), and RF (Rating Function). Here's an overview of the roles of each function and how data flows between them:</p> <p>1. CTF (Charging Trigger Function):    * Role: CTF observes network resource usage to generate charging events.    * Data Flow: It collects information about trigger conditions, information elements to be collected, and the monitoring of service events, signaling, or user traffic.    * Data Transfer: CTF forwards generated charging events to the OCF.</p> <p>2. OCF (Online Charging Function):    * Role: OCF is responsible for real-time charging and authorization of resource usage.    * Data Flow: It evaluates charging events, determines the value of requested resource usage, and authorizes it.    * Data Transfer: OCF sends authorization information to the network element, which then executes the resource usage.</p> <p>3. ABMF (Account Balance Management Function):    * Role: ABMF manages subscriber account balances and credit control.    * Data Flow: It keeps track of subscriber account balances and interacts with OCF for authorization and debiting.    * Data Transfer: ABMF communicates with OCF to manage subscriber balances during resource usage.</p> <p>4. RF (Rating Function):    * Role: RF determines the value or amount of actual network resource usage for OCF (according to OCF from charging event)    * Data Flow: The OCF provides the RF with essential data extracted from the charging event. Then RF returns the rating results, which can be in the form of monetary or non-monetary units.    * Data Transfer: OCF send charging event to RF, and RF return rating results in specific unit</p> <p>These functions collaborate to enable real-time online charging, authorization, and account management for subscribers in the online charging system.</p>"},{"location":"blog/20230913/20230913/#converged-charging-functions","title":"Converged Charging Functions","text":"<p> The Converged Charging Functions consist of various components, each with specific roles and data flow within the system. Here's an overview of the roles of each function and how data flows between them:</p> <p>1. CTF (Charging Trigger Function):    * Role: CTF is mostly integrated into network functions like PCF, SMSF, and SMF. These network functions monitor charging information and transform it into charging events, which are then forwarded to the CHF for further processing.    * Data Flow: It collects information on trigger conditions, information elements to be captured, and monitors service events, signaling, or user traffic.    * Data Transfer: The CTF forwards the generated charging events to the CHF via an SBI (Service-Based Interface) located within the core network's control plane.</p> <p>2. CHF (CHarging Function):    * Role: CHF is responsible for facilitating communication among all functions within the Converged Charging System(CCS). Its role includes receiving charging events and generating CDRs (Charging Data Records). Importantly, it can simultaneously handle both online and offline charging functions.    * Data Flow: It evaluates charging events, determines the value of requested resource usage, authorizes it, and manages subscriber account balances.    * Data Transfer: CHF and its associated functions engage in data exchanges involving various types of information. These data exchanges include charging events, user count balances, CDRs (Charging Data Records), and rating information.</p> <p>The remaining functions mentioned earlier in the descriptions of offline and online charging serve the same purposes and functions, so we won't go into further detail here.</p>"},{"location":"blog/20230913/20230913/#the-differences-between-4g-and-5g-charging","title":"The Differences between 4G and 5G Charging","text":"<p>In the 4G era, various concepts and functions for online and offline charging were already established. When defining the 5G standards, it was recognized that there was a need to support various charging methods. Therefore, a new function called CHF (Charging Function) was introduced, and other functions such as ABMF, CGF, and RF from different systems were integrated into the Converged Charging System. This addition expanded the capabilities of 5G Core (5GC) charging.</p> <p></p> <p>The differences between 4G and 5G charging can be summarized as follows:</p> <p>1. Network Architecture:    * 4G: In 4G networks, charging functions are typically less integrated and may involve multiple separate components.    * 5G: 5G introduces a more integrated and converged charging system where various charging functions are unified within the Converged Charging System (CHF), allowing for more flexibility and efficiency.</p> <p>2. Charging Flexibility:    * 4G: 4G networks may have limitations in terms of charging flexibility, especially when it comes to handling different charging scenarios and services.    * 5G: 5G charging is designed to be more versatile and adaptable, capable of handling various charging models, both online and offline, for a wide range of services and use cases.</p> <p>3. Service Support:    * 4G: 4G charging systems are primarily designed for traditional mobile services like voice and data.    * 5G: 5G charging systems are built to support a broader range of services, including enhanced mobile broadband (eMBB), massive machine-type communications (mMTC), and ultra-reliable low-latency communications (URLLC), making them more suitable for diverse 5G applications.</p> <p>4. Convergence:    * 4G: Converged charging in 4G networks is often limited, and different charging models may not be as seamlessly integrated.    * 5G: 5G emphasizes the convergence of charging functions, allowing for greater consistency and interoperability across various charging scenarios and services.</p> <p>5. Charging Efficiency:    * 4G: Charging efficiency in 4G networks may vary depending on the specific implementation and the level of integration between charging components.    * 5G: 5G charging systems aim to improve efficiency by streamlining charging processes and reducing redundancy, thanks to the unified CHF.</p> <p>Overall, the key difference between 4G and 5G charging lies in the level of integration, flexibility, and support for a broader range of services and use cases in 5G networks. The introduction of the CHF in 5G brings greater convergence and efficiency to charging operations.</p>"},{"location":"blog/20230913/20230913/#chf-implementation","title":"CHF Implementation","text":"<p>Hello everyone, we are the free5gc development team. We have recently added CHF (Charging Function) to enhance the functionality of 5G Core (5GC). We invite anyone interested in CHF to check out how we have implemented the charging function. Below is the relevant link, and thank you for your interest.</p> <p></p> <ul> <li>Ref: https://github.com/free5gc/chf</li> </ul>"},{"location":"blog/20230913/20230913/#reference","title":"Reference","text":"<ul> <li>3GPP TS32.240 v15 spec(offline)</li> <li>3GPP TS32.240 v15 spec(online)</li> <li>https://devopedia.org/5g-service-based-architecture</li> <li>https://free5gc.org/</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/","title":"Introduction of gtp5g and some kernel concepts","text":"<p>Note</p> <p>Author: Jimmy Date: 2023/9/20</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#overview","title":"Overview","text":"<p>GTP (General Packet Radio System Tunneling Protocol) is a group of IP-based communication protocols used to transport General Packet Radio Services (GPRS) within LTE, 5G NR, and other networks. GTP can be broken down into several components: GTP-C, GTP-U, and GTP prime. GTP-C and GTP-U are responsible for the control plane and user plane, respectively, while GTP prime is utilized for transmitting charging data through the Ga interface as defined in the 3GPP GPRS Core Network.</p> <p>In the context of free5GC, the UPF network function combines the GTP-C control part to correctly instruct the routing path for any packet passing through the core network. GTP-U, on the other hand, is managed by gtp5g, which transports packets using kernel modules generated by gtp5g. This article will introduce how gtp5g assists free5GC in handling packets and some kernel-related concepts.</p> <p>Let's start the journey!</p> <p>Additional information:</p> <ul> <li>Linux kernel version is 5.4.0-159-generic in article. According to other versions, some of content would be different, but the main concept is the same.</li> <li>Gtp5g version is v0.8.2</li> <li>UPF version is v1.2.0</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#netlink-generic-netlink-and-rtnetlink","title":"Netlink, Generic Netlink and Rtnetlink","text":""},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#netlink","title":"Netlink","text":"<p>Before we continue, I need to introduce Netlink first. What is Netlink? Netlink is an IPC (Inter Process Communication) protocol which can connect kernel space and user space processes by socket.  Traditionally, it used three methods: Ioctl, sysfs, or procfs, to facilitate communication between the kernel and user space. However, it can only be initiated from user space, not from kernel space. Netlink can support not only initiated from kernel and user space but also:</p> <ul> <li>Bidirectional transmission, asynchronous communication.</li> <li>Standard socket API used in user space.</li> <li>Specialized API used in kernel space.</li> <li>Support for multicast.</li> <li>Support for 32 protocol types.</li> </ul> <p>There are servel usages define in include/uapi/linux/netlink.h <pre><code>#define NETLINK_ROUTE       0   /* Routing/device hook              */\n#define NETLINK_UNUSED      1   /* Unused number                */\n#define NETLINK_USERSOCK    2   /* Reserved for user mode socket protocols  */\n#define NETLINK_FIREWALL    3   /* Unused number, formerly ip_queue     */\n#define NETLINK_SOCK_DIAG   4   /* socket monitoring                */\n#define NETLINK_NFLOG       5   /* netfilter/iptables ULOG */\n#define NETLINK_XFRM        6   /* ipsec */\n#define NETLINK_SELINUX     7   /* SELinux event notifications */\n#define NETLINK_ISCSI       8   /* Open-iSCSI */\n#define NETLINK_AUDIT       9   /* auditing */\n#define NETLINK_FIB_LOOKUP  10\n#define NETLINK_CONNECTOR   11\n#define NETLINK_NETFILTER   12  /* netfilter subsystem */\n#define NETLINK_IP6_FW      13\n#define NETLINK_DNRTMSG     14  /* DECnet routing messages */\n#define NETLINK_KOBJECT_UEVENT  15  /* Kernel messages to userspace */\n#define NETLINK_GENERIC     16\n/* leave room for NETLINK_DM (DM Events) */\n#define NETLINK_SCSITRANSPORT   18  /* SCSI Transports */\n#define NETLINK_ECRYPTFS    19\n#define NETLINK_RDMA        20\n#define NETLINK_CRYPTO      21  /* Crypto layer */\n#define NETLINK_SMC     22  /* SMC monitoring */\n\n#define NETLINK_INET_DIAG   NETLINK_SOCK_DIAG\n\n#define MAX_LINKS 32\n</code></pre></p> <p>These are Linux system pre-defined Netlink protocols. Therefore, if users want to define their own Netlink protocol, they would need to modify the Linux kernel files to meet their requirements. However, the kernel must be protected from modification. Additionally, the maximum protocol number allowed is 32, can't exceed it.</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#generic-netlink","title":"Generic Netlink","text":"<p>Due to the shortage of protocol numbers and the need to prevent kernel modification, kernel developers extended Netlink and introduced Generic Netlink. Generic Netlink supports 1023 protocols, addressing the protocol number limitation, and it allocates protocol IDs automatically.</p> <p>The following figure is Generic Netlink structure:</p> <pre><code>graph TD\nA1[Application_1] --- B[Kernel_Socket_API]\nA2[Application_2] --- B[Kernel_Socket_API]\n\nB[Kernel_Socket_API] --- C[Netlink_Subsystem]\nB[Kernel_Socket_API] --- C[Netlink_Subsystem]\n\nC[Netlink_Subsystem] --- D[Generic_Netlink_Bus]\n\nD[Generic_Netlink_Bus] --- E1[Controller]\nD[Generic_Netlink_Bus] --- E2[Kernel_User_1]\nD[Generic_Netlink_Bus] --- E3[Kernel_User_2]\n</code></pre> <ul> <li>The Generic Netlink users application_1 and application_2 could communicate both user space and kernel space endpoint through Kernel_socket_API.</li> <li>The Netlink subsystem which serves as the underlying transport layer for all of the Generic Netlink communications.</li> <li>The Generic Netlink bus which is implemented inside the kernel, but which is available to userspace through the socket API and inside the kernel via the normal Netlink and Generic Netlink APIs.</li> <li>The Generic Netlink users who communicate with each other over the Generic Netlink bus; users can exist both in kernel and user space.</li> <li>The Generic Netlink controller which is part of the kernel and is responsible for dynamically allocating Generic Netlink communication channels and other management tasks. The Generic Netlink controller is implemented as a standard Generic Netlink kernel user, however, it listens on a special, pre-allocated Generic Netlink channel.</li> <li>The kernel socket API. Generic Netlink sockets are created with the PF_NETLINK domain and the NETLINK_GENERIC protocol values.</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#rtnetlink","title":"RtNetlink","text":"<p>The last one is rtnetlink, it also known as Netlink protocol type NETLINK_ROUTE, user space program could read and alter kernel's routing table or create new network device.</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#free5gc-upf","title":"free5GC UPF","text":"<p>Since gtp5g is part of UPF logically, article also covers part of UPF.</p> <p>The Driver provides functions to communicate with gtp5g (the functions are one-to-one match to gtp5g_genl_ops[] in genl.c). So, when UPF receives a PFCP message, it parses the content and then uses various functions of the Driver to instruct gtp5g to take regarding rules. <pre><code>// internel/forwarder/driver.go\ntype Driver interface {\n    Close()\n\n    CreatePDR(uint64, *ie.IE) error\n    UpdatePDR(uint64, *ie.IE) error\n    RemovePDR(uint64, *ie.IE) error\n\n    CreateFAR(uint64, *ie.IE) error\n    UpdateFAR(uint64, *ie.IE) error\n    RemoveFAR(uint64, *ie.IE) error\n\n    CreateQER(uint64, *ie.IE) error\n    UpdateQER(uint64, *ie.IE) error\n    RemoveQER(uint64, *ie.IE) error\n\n    CreateURR(uint64, *ie.IE) error\n    UpdateURR(uint64, *ie.IE) ([]report.USAReport, error)\n    RemoveURR(uint64, *ie.IE) ([]report.USAReport, error)\n    QueryURR(uint64, uint32) ([]report.USAReport, error)\n\n    CreateBAR(uint64, *ie.IE) error\n    UpdateBAR(uint64, *ie.IE) error\n    RemoveBAR(uint64, *ie.IE) error\n\n    HandleReport(report.Handler)\n}\n</code></pre></p> <p>UPF use rtnl to create device (interface) named <code>upfgtp</code>. User can observe it while executing run.sh. <pre><code>func OpenGtp5gLink(mux *nl.Mux, addr string, mtu uint32, log *logrus.Entry) (*Gtp5gLink, error) {\n    g := &amp;Gtp5gLink{\n        log: log,\n    }\n\n    g.mux = mux\n\n    rtconn, err := nl.Open(syscall.NETLINK_ROUTE)\n    if err != nil {\n        return nil, errors.Wrap(err, \"open\")\n    }\n    g.rtconn = rtconn\n    g.client = nl.NewClient(rtconn, mux)\n\n    laddr, err := net.ResolveUDPAddr(\"udp4\", addr)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"resolve addr\")\n    }\n    conn, err := net.ListenUDP(\"udp4\", laddr)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"listen\")\n    }\n    g.conn = conn\n\n    // TODO: Duplicate fd\n    f, err := conn.File()\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"file\")\n    }\n    g.f = f\n\n    linkinfo := &amp;nl.Attr{\n        Type: syscall.IFLA_LINKINFO,\n        Value: nl.AttrList{\n            {\n                Type:  rtnllink.IFLA_INFO_KIND,\n                Value: nl.AttrString(\"gtp5g\"),\n            },\n            {\n                Type: rtnllink.IFLA_INFO_DATA,\n                Value: nl.AttrList{\n                    {\n                        Type:  gtp5gnl.IFLA_FD1,\n                        Value: nl.AttrU32(f.Fd()),\n                    },\n                    {\n                        Type:  gtp5gnl.IFLA_HASHSIZE,\n                        Value: nl.AttrU32(131072),\n                    },\n                },\n            },\n        },\n    }\n    attrs := []*nl.Attr{linkinfo}\n\n    if mtu != 0 {\n        attrs = append(attrs, &amp;nl.Attr{\n            Type:  syscall.IFLA_MTU,\n            Value: nl.AttrU32(mtu),\n        })\n    }\n\n    err = rtnllink.Create(g.client, \"upfgtp\", attrs...)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"create\")\n    }\n    err = rtnllink.Up(g.client, \"upfgtp\")\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"up\")\n    }\n    link, err := gtp5gnl.GetLink(\"upfgtp\")\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"get link\")\n    }\n    g.link = link\n    return g, nil\n}\n</code></pre></p> <p>Connect UPF Driver functions and <code>gtp5g_genl_ops</code>. <pre><code>// internl/forwarder/buffnetlink/server.go\nfunc OpenServer(wg *sync.WaitGroup, client *nl.Client, mux *nl.Mux) (*Server, error) {\n    s := &amp;Server{\n        client: client,\n        mux:    mux,\n    }\n\n    f, err := genl.GetFamily(s.client, \"gtp5g\")\n    if err != nil {\n        return nil, errors.Wrap(err, \"get family\")\n    }\n\n    s.conn, err = nl.Open(syscall.NETLINK_GENERIC, int(f.Groups[gtp5gnl.GENL_MCGRP].ID))\n    if err != nil {\n        return nil, errors.Wrap(err, \"open netlink\")\n    }\n\n    err = s.mux.PushHandler(s.conn, s)\n    if err != nil {\n        return nil, errors.Wrap(err, \"push handler\")\n    }\n\n    logger.BuffLog.Infof(\"buff netlink server started\")\n\n    // wg.Add(1)\n    return s, nil\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g","title":"GTP5G","text":"<ul> <li>Gtp5g utilizes a Linux kernel module to manage packet traffic. A Linux kernel module can be thought of as a small piece of code that is inserted into the Linux kernel, allowing users to customize the program according to the current hardware device</li> <li>In gtp5g, the primary function is gtp5g_init in gtp5g.c; it exposes most of the components and techniques provided by gtp5g. This article will choose the following concepts to investigate further:</li> <li>Network device -&gt; <code>net_device_ops</code></li> <li>Rtnetlink -&gt; <code>gtp5g_link_ops</code></li> <li>Generic Netlink -&gt; <code>gtp5g_genl_family</code></li> <li>Additionally, the article will present two functions in detail:</li> <li><code>rtnl_link_register()</code></li> <li><code>genl_register_family()</code></li> </ul> <pre><code>// src/gtp5g.c\nstatic int __init gtp5g_init(void)\n{\n    int err;\n\n    GTP5G_LOG(NULL, \"Gtp5g Module initialization Ver: %s\\n\", DRV_VERSION);\n\n    init_proc_gtp5g_dev_list();\n\n    // set hash initial value\n    get_random_bytes(&amp;gtp5g_h_initval, sizeof(gtp5g_h_initval));\n\n    err = rtnl_link_register(&amp;gtp5g_link_ops);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register rtnl\\n\");\n        goto error_out;\n    }\n\n    err = genl_register_family(&amp;gtp5g_genl_family);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register generic\\n\");\n        goto unreg_rtnl_link;\n    }\n\n    err = register_pernet_subsys(&amp;gtp5g_net_ops);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register namespace\\n\");\n        goto unreg_genl_family;\n    }\n\n    err = create_proc();\n    if (err &lt; 0) {\n        goto unreg_pernet;\n    }\n    GTP5G_LOG(NULL, \"5G GTP module loaded\\n\");\n\n    return 0;\n    ...\n}\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#net_device_ops","title":"<code>net_device_ops</code>","text":"<p>It is defined in dev.h and referenced in dev.c. The structure net_device_ops encompasses all operations related to network device, and free5GC inherits some of these operations to implement self-made netdev ops. <pre><code>// include/dev.h\nextern const struct net_device_ops gtp5g_netdev_ops;\n</code></pre></p> <p><pre><code>// src/gtpu/dev.c\nconst struct net_device_ops gtp5g_netdev_ops = {\n    .ndo_init           = gtp5g_dev_init,\n    .ndo_uninit         = gtp5g_dev_uninit,\n    .ndo_start_xmit     = gtp5g_dev_xmit,\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 11, 0)\n    .ndo_get_stats64    = dev_get_tstats64,\n#else\n    .ndo_get_stats64    = ip_tunnel_get_stats64,\n#endif\n};\n</code></pre> According to /include/linux/netdevice.h, you can find the definition of hooks of net_device_ops:</p> <ul> <li><code>.ndo_init</code>: This function is called once when a network device is registered. The network device can use this for any late stage initialization or semantic validation. It can fail with an error code which will be propagated back to register_netdev.</li> <li><code>.ndo_uninit</code>: This function is called when device is unregistered or when registration fails. It is not called if init fails.</li> <li><code>.ndo_start_xmit</code>: Called when a packet needs to be transmitted. Returns NETDEV_TX_OK. Can return NETDEV_TX_BUSY, but you should stop the queue before that can happen; it's for obsolete devices and weird corner cases, but the stack really does a non-trivial amount of useless work if you return NETDEV_TX_BUSY. Required; cannot be NULL. <pre><code>struct net_device_ops {\n  int           (*ndo_init)(struct net_device *dev);\n  void          (*ndo_uninit)(struct net_device *dev);\n  netdev_tx_t       (*ndo_start_xmit)(struct sk_buff *skb,\n                      struct net_device *dev);\n...\n}\n</code></pre> Gtp5g self-made structure: <pre><code>// include/dev.h\nstruct gtp5g_dev {\n    struct list_head list;\n    struct sock *sk1u; // UDP socket from user space\n    struct net_device *dev;\n    unsigned int role;\n    unsigned int hash_size;\n    struct hlist_head *pdr_id_hash;\n    struct hlist_head *far_id_hash;\n    struct hlist_head *qer_id_hash;\n    struct hlist_head *bar_id_hash;\n    struct hlist_head *urr_id_hash;\n\n    struct hlist_head *i_teid_hash; // Used for GTP-U packet detect\n    struct hlist_head *addr_hash;   // Used for IPv4 packet detect\n\n    /* IEs list related to PDR */\n    struct hlist_head *related_far_hash; // PDR list waiting the FAR to handle\n    struct hlist_head *related_qer_hash; // PDR list waiting the QER to handle\n    struct hlist_head *related_bar_hash;\n    struct hlist_head *related_urr_hash;\n\n    /* Used by proc interface */\n    struct list_head proc_list;\n};\n</code></pre></li> </ul> <p>It would find the private data address in network device by netdev_priv() and allocate the device statistics space for each CPU by netdev_alloc_pcpu_stats(): <pre><code>// src/gtpu/dev.c\nstatic int gtp5g_dev_init(struct net_device *dev)\n{\n    struct gtp5g_dev *gtp = netdev_priv(dev);\n\n    gtp-&gt;dev = dev;\n\n    dev-&gt;tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n    if (!dev-&gt;tstats) {\n        return -ENOMEM;\n    }\n\n    return 0;\n}\n</code></pre></p> <p>From /include/linux/netdevice.h, the return value would be times of 32: <pre><code>static inline void *netdev_priv(const struct net_device *dev)\n{\n    return (char *)dev + ALIGN(sizeof(struct net_device), NETDEV_ALIGN);\n}\n</code></pre></p> <p>Close the udp socket (sk1u) is used to receive uplink (N3) packet: <pre><code>// src/gtpu/dev.c\nstatic void gtp5g_dev_uninit(struct net_device *dev)\n{\n    struct gtp5g_dev *gtp = netdev_priv(dev);\n\n    gtp5g_encap_disable(gtp-&gt;sk1u);\n    free_percpu(dev-&gt;tstats);\n}\n</code></pre></p> <p>Utilized for the reception of downlink (N6) packets by a network device: <pre><code>// src/gtpu/dev.c\nstatic netdev_tx_t gtp5g_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n    unsigned int proto = ntohs(skb-&gt;protocol);\n    struct gtp5g_pktinfo pktinfo;\n    int ret = 0;\n\n    /* Ensure there is sufficient headroom */\n    if (skb_cow_head(skb, dev-&gt;needed_headroom)) {\n        goto tx_err;\n    }\n\n    skb_reset_inner_headers(skb);\n\n    /* PDR lookups in gtp5g_build_skb_*() need rcu read-side lock.\n     * */\n    rcu_read_lock();\n    switch (proto) {\n    case ETH_P_IP:\n        ret = gtp5g_handle_skb_ipv4(skb, dev, &amp;pktinfo);\n        break;\n    default:\n        ret = -EOPNOTSUPP;\n    }\n    rcu_read_unlock();\n\n    if (ret &lt; 0)\n        goto tx_err;\n\n    if (ret == FAR_ACTION_FORW)\n        gtp5g_xmit_skb_ipv4(skb, &amp;pktinfo);\n\n    return NETDEV_TX_OK;\n    ...\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g_link_ops","title":"<code>gtp5g_link_ops</code>","text":"<p>Ignore headder file here, structure defines Rtnetlink operations.</p> <pre><code>// src/gtpu/link.c\nstruct rtnl_link_ops gtp5g_link_ops __read_mostly = {\n    .kind         = \"gtp5g\",\n    .maxtype      = IFLA_GTP5G_MAX,\n    .policy       = gtp5g_policy,\n    .priv_size    = sizeof(struct gtp5g_dev),\n    .setup        = gtp5g_link_setup,\n    .validate     = gtp5g_validate,\n    .newlink      = gtp5g_newlink,\n    .dellink      = gtp5g_dellink,\n    .get_size     = gtp5g_get_size,\n    .fill_info    = gtp5g_fill_info,\n};\n</code></pre> <p>Definition is in /include/net/rtnetlink.h: - <code>.kind</code>: Identifier - <code>.maxtype</code>: Highest device specific netlink attribute number - <code>.policy</code>: Netlink policy for device specific attribute validation - <code>.priv_size</code>: sizeof net_device private space - <code>.setup</code>: net_device setup function - <code>.validate</code>: Optional validation function for netlink/changelink parameters - <code>.newlink</code>: Function for configuring and registering a new device - <code>.dellink</code>: Function to remove a device - <code>.get_size</code>: Function to calculate required room for dumping device specific netlink attributes - <code>.fill_info</code>: Function to dump device specific netlink attributes</p> <pre><code>struct rtnl_link_ops {\n    struct list_head    list;\n\n    const char      *kind;\n\n    size_t          priv_size;\n    void            (*setup)(struct net_device *dev);\n\n    unsigned int        maxtype;\n    const struct nla_policy *policy;\n    int         (*validate)(struct nlattr *tb[],\n                        struct nlattr *data[],\n                        struct netlink_ext_ack *extack);\n\n    int         (*newlink)(struct net *src_net,\n                       struct net_device *dev,\n                       struct nlattr *tb[],\n                       struct nlattr *data[],\n                       struct netlink_ext_ack *extack);\n    int         (*changelink)(struct net_device *dev,\n                          struct nlattr *tb[],\n                          struct nlattr *data[],\n                          struct netlink_ext_ack *extack);\n    void            (*dellink)(struct net_device *dev,\n                       struct list_head *head);\n\n    size_t          (*get_size)(const struct net_device *dev);\n    int         (*fill_info)(struct sk_buff *skb,\n                         const struct net_device *dev);\n\n    size_t          (*get_xstats_size)(const struct net_device *dev);\n    int         (*fill_xstats)(struct sk_buff *skb,\n                           const struct net_device *dev);\n    unsigned int        (*get_num_tx_queues)(void);\n    unsigned int        (*get_num_rx_queues)(void);\n\n    unsigned int        slave_maxtype;\n    const struct nla_policy *slave_policy;\n    int         (*slave_changelink)(struct net_device *dev,\n                            struct net_device *slave_dev,\n                            struct nlattr *tb[],\n                            struct nlattr *data[],\n                            struct netlink_ext_ack *extack);\n    size_t          (*get_slave_size)(const struct net_device *dev,\n                          const struct net_device *slave_dev);\n    int         (*fill_slave_info)(struct sk_buff *skb,\n                           const struct net_device *dev,\n                           const struct net_device *slave_dev);\n    struct net      *(*get_link_net)(const struct net_device *dev);\n    size_t          (*get_linkxstats_size)(const struct net_device *dev,\n                               int attr);\n    int         (*fill_linkxstats)(struct sk_buff *skb,\n                           const struct net_device *dev,\n                           int *prividx, int attr);\n};\n</code></pre> <p>Once rtnl link setting up, gtp5g would assign net_device_ops to device. <pre><code>static void gtp5g_link_setup(struct net_device *dev)\n{\n    dev-&gt;netdev_ops = &amp;gtp5g_netdev_ops;   &lt;---- network device assignment\n    dev-&gt;needs_free_netdev = true;\n\n    dev-&gt;hard_header_len = 0;\n    dev-&gt;addr_len = 0;\n    dev-&gt;mtu = ETH_DATA_LEN -\n        (sizeof(struct iphdr) +\n         sizeof(struct udphdr) +\n         sizeof(struct gtpv1_hdr));\n\n    /* Zero header length. */\n    dev-&gt;type = ARPHRD_NONE;\n    dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\n    dev-&gt;priv_flags |= IFF_NO_QUEUE;\n    dev-&gt;features |= NETIF_F_LLTX;\n    netif_keep_dst(dev);\n\n    /* TODO: Modify the headroom size based on\n     * what are the extension header going to support\n     * */\n    dev-&gt;needed_headroom = LL_MAX_HEADER +\n        sizeof(struct iphdr) +\n        sizeof(struct udphdr) +\n        sizeof(struct gtpv1_hdr);\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#rtnl_link_register","title":"<code>rtnl_link_register()</code>","text":"<ul> <li>Definition is in /net/core/rtnetlink.c</li> <li>This function should be used by drivers that create devices during module initialization. It must be called before registering the devices</li> <li>Using the kind property of rtnl_link_ops to search for the existence of ops in link_ops. If ops do not exist, then inserted it at the end of link_ops</li> <li>Once register sucess, UPF can create new network device (interface) using Rtnetlink socket <pre><code>int __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n    if (rtnl_link_ops_get(ops-&gt;kind))\n        return -EEXIST;\n\n    /* The check for setup is here because if ops\n     * does not have that filled up, it is not possible\n     * to use the ops for creating device. So do not\n     * fill up dellink as well. That disables rtnl_dellink.\n     */\n    if (ops-&gt;setup &amp;&amp; !ops-&gt;dellink)\n        ops-&gt;dellink = unregister_netdevice_queue;\n\n    list_add_tail(&amp;ops-&gt;list, &amp;link_ops);\n    return 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n</code></pre></li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g_genl_family","title":"gtp5g_genl_family","text":"<p>Gtp5g defines the genl (Generic Netlink) interface to facilitate communication between user and kernel space after register 'family'. As mentioned earlier, there is a Generic Netlink Controller responsible for bus allocation and dynamically assigns tunnel based on genl family id (name).</p> <p><pre><code>// src/genl/genl.c\nstruct genl_family gtp5g_genl_family __ro_after_init = {\n    .name       = \"gtp5g\",\n    .version    = 0,\n    .hdrsize    = 0,\n    .maxattr    = GTP5G_ATTR_MAX,\n    .netnsok    = true,\n    .module     = THIS_MODULE,\n    .ops        = gtp5g_genl_ops,\n    .n_ops      = ARRAY_SIZE(gtp5g_genl_ops),\n    .mcgrps     = gtp5g_genl_mcgrps,\n    .n_mcgrps   = ARRAY_SIZE(gtp5g_genl_mcgrps),\n};\n</code></pre> Definition is in /include/net/genetlink.h: - <code>.name</code>: name of family (exclusive) - <code>.version</code>: protocol version (usually is 1) - <code>.hdrsize</code>: length of user specific header in bytes - <code>.maxattr</code>: maximum number of attributes supported - <code>.netnsok</code>: set to true if the family can handle network namespaces and should be presented in all of them - <code>.ops</code>: the operations supported by this family - <code>.n_ops</code>: number of operations supported by this family - <code>.mcgrps</code>: multicast groups used by this family - <code>.n_mcgrps</code>: number of multicast groups</p> <pre><code>struct genl_family {\n    int         id;     /* private */\n    unsigned int        hdrsize;\n    char            name[GENL_NAMSIZ];\n    unsigned int        version;\n    unsigned int        maxattr;\n    bool            netnsok;\n    bool            parallel_ops;\n    const struct nla_policy *policy;\n    int         (*pre_doit)(const struct genl_ops *ops,\n                        struct sk_buff *skb,\n                        struct genl_info *info);\n    void            (*post_doit)(const struct genl_ops *ops,\n                         struct sk_buff *skb,\n                         struct genl_info *info);\n    struct nlattr **    attrbuf;    /* private */\n    const struct genl_ops * ops;\n    const struct genl_multicast_group *mcgrps;\n    unsigned int        n_ops;\n    unsigned int        n_mcgrps;\n    unsigned int        mcgrp_offset;   /* private */\n    struct module       *module;\n};\n</code></pre> <p>Gtp5g defines <code>gtp5g_genl_ops</code>, all operations are one-to-one match to Driver functions in UPF part: <pre><code>// src/genl/genl.c\nstatic const struct genl_ops gtp5g_genl_ops[] = {\n    {\n        .cmd = GTP5G_CMD_ADD_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_add_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    {\n        .cmd = GTP5G_CMD_DEL_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_del_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    {\n        .cmd = GTP5G_CMD_GET_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_get_pdr,\n        .dumpit = gtp5g_genl_dump_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    ...\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_register_family","title":"<code>genl_register_family()</code>","text":"<ul> <li>Definition is in /net/netlink/genetlink.c</li> <li>Registers the specified family after validating it first. Only one family may be registered with the same family name or identifier. The family's ops, multicast groups and module pointer must already be assigned. Return 0 on success or a negative error code</li> <li>Three functions within this method hold greater significance (all of them in /net/netlink/genetlink.c):</li> <li><code>genl_validate_ops()</code></li> <li><code>genl_family_find_byname()</code></li> <li><code>genl_validate_assign_mc_groups()</code></li> </ul> <pre><code>int genl_register_family(struct genl_family *family)\n{\n    int err, i;\n    int start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n    err = genl_validate_ops(family);\n    if (err)\n        return err;\n\n    genl_lock_all();\n\n    if (genl_family_find_byname(family-&gt;name)) {\n        err = -EEXIST;\n        goto errout_locked;\n    }\n\n    if (family == &amp;genl_ctrl) {\n        start = end = GENL_ID_CTRL;\n    } else if (strcmp(family-&gt;name, \"pmcraid\") == 0) {\n        start = end = GENL_ID_PMCRAID;\n    } else if (strcmp(family-&gt;name, \"VFS_DQUOT\") == 0) {\n        start = end = GENL_ID_VFS_DQUOT;\n    }\n\n    if (family-&gt;maxattr &amp;&amp; !family-&gt;parallel_ops) {\n        family-&gt;attrbuf = kmalloc_array(family-&gt;maxattr + 1,\n                        sizeof(struct nlattr *),\n                        GFP_KERNEL);\n        if (family-&gt;attrbuf == NULL) {\n            err = -ENOMEM;\n            goto errout_locked;\n        }\n    } else\n        family-&gt;attrbuf = NULL;\n\n    family-&gt;id = idr_alloc_cyclic(&amp;genl_fam_idr, family,\n                      start, end + 1, GFP_KERNEL);\n    if (family-&gt;id &lt; 0) {\n        err = family-&gt;id;\n        goto errout_free;\n    }\n\n    err = genl_validate_assign_mc_groups(family);\n    if (err)\n        goto errout_remove;\n\n    genl_unlock_all();\n\n    /* send all events */\n    genl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n    for (i = 0; i &lt; family-&gt;n_mcgrps; i++)\n        genl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n                &amp;family-&gt;mcgrps[i], family-&gt;mcgrp_offset + i);\n\n    return 0;\n\nerrout_remove:\n    idr_remove(&amp;genl_fam_idr, family-&gt;id);\nerrout_free:\n    kfree(family-&gt;attrbuf);\nerrout_locked:\n    genl_unlock_all();\n    return err;\n}\nEXPORT_SYMBOL(genl_register_family);\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_validate_ops","title":"<code>genl_validate_ops()</code>","text":"<p>This function will verify if there is defined function for the operations and will also compare whether any operation is reused by a command. Using gtp5g as an example, command can be considered as action such as add, del, modify PDR rules. <pre><code>static int genl_validate_ops(const struct genl_family *family)\n{\n    const struct genl_ops *ops = family-&gt;ops;\n    unsigned int n_ops = family-&gt;n_ops;\n    int i, j;\n\n    if (WARN_ON(n_ops &amp;&amp; !ops))\n        return -EINVAL;\n\n    if (!n_ops)\n        return 0;\n\n    for (i = 0; i &lt; n_ops; i++) {\n        if (ops[i].dumpit == NULL &amp;&amp; ops[i].doit == NULL)\n            return -EINVAL;\n        for (j = i + 1; j &lt; n_ops; j++)\n            if (ops[i].cmd == ops[j].cmd)\n                return -EINVAL;\n    }\n\n    return 0;\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_family_find_byname","title":"<code>genl_family_find_byname()</code>","text":"<p>Function would check every entry in genl_fam_idr whether exists the same family name.</p> <pre><code>static const struct genl_family *genl_family_find_byname(char *name)\n{\n    const struct genl_family *family;\n    unsigned int id;\n\n    idr_for_each_entry(&amp;genl_fam_idr, family, id)\n        if (strcmp(family-&gt;name, name) == 0)\n            return family;\n\n    return NULL;\n}\n</code></pre> <p>Here is the macro of <code>idr_for_each_entry()</code>: <pre><code>#define idr_for_each_entry(idr, entry, id)          \\\n    for (id = 0; ((entry) = idr_get_next(idr, &amp;(id))) != NULL; id += 1U)\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_validate_assign_mc_groups","title":"<code>genl_validate_assign_mc_groups()</code>","text":"<p>This changes the number of multicast groups that are available when ntensok is ture:</p> <pre><code>static int genl_validate_assign_mc_groups(struct genl_family *family)\n{\n    int first_id;\n    int n_groups = family-&gt;n_mcgrps;\n    int err = 0, i;\n    bool groups_allocated = false;\n\n    if (!n_groups)\n        return 0;\n\n    for (i = 0; i &lt; n_groups; i++) {\n        const struct genl_multicast_group *grp = &amp;family-&gt;mcgrps[i];\n\n        if (WARN_ON(grp-&gt;name[0] == '\\0'))\n            return -EINVAL;\n        if (WARN_ON(memchr(grp-&gt;name, '\\0', GENL_NAMSIZ) == NULL))\n            return -EINVAL;\n    }\n\n    /* special-case our own group and hacks */\n    if (family == &amp;genl_ctrl) {\n        first_id = GENL_ID_CTRL;\n        BUG_ON(n_groups != 1);\n    } else if (strcmp(family-&gt;name, \"NET_DM\") == 0) {\n        first_id = 1;\n        BUG_ON(n_groups != 1);\n    } else if (family-&gt;id == GENL_ID_VFS_DQUOT) {\n        first_id = GENL_ID_VFS_DQUOT;\n        BUG_ON(n_groups != 1);\n    } else if (family-&gt;id == GENL_ID_PMCRAID) {\n        first_id = GENL_ID_PMCRAID;\n        BUG_ON(n_groups != 1);\n    } else {\n        groups_allocated = true;\n        err = genl_allocate_reserve_groups(n_groups, &amp;first_id);\n        if (err)\n            return err;\n    }\n\n    family-&gt;mcgrp_offset = first_id;\n\n    /* if still initializing, can't and don't need to to realloc bitmaps */\n    if (!init_net.genl_sock)\n        return 0;\n\n    if (family-&gt;netnsok) {\n        struct net *net;\n\n        netlink_table_grab();\n        rcu_read_lock();\n        for_each_net_rcu(net) {\n            err = __netlink_change_ngroups(net-&gt;genl_sock,\n                    mc_groups_longs * BITS_PER_LONG);\n            if (err) {\n                /*\n                 * No need to roll back, can only fail if\n                 * memory allocation fails and then the\n                 * number of _possible_ groups has been\n                 * increased on some sockets which is ok.\n                 */\n                break;\n            }\n        }\n        rcu_read_unlock();\n        netlink_table_ungrab();\n    } else {\n        err = netlink_change_ngroups(init_net.genl_sock,\n                         mc_groups_longs * BITS_PER_LONG);\n    }\n\n    if (groups_allocated &amp;&amp; err) {\n        for (i = 0; i &lt; family-&gt;n_mcgrps; i++)\n            clear_bit(family-&gt;mcgrp_offset + i, mc_groups);\n    }\n\n    return err;\n}\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#about","title":"About","text":"<ul> <li>Jimmy Chang<ul> <li>Graduate student majoring in 5GC Research</li> <li>As I am a beginner in the Linux kernel, please feel free to send me an email if you find any errors.</li> <li>mail</li> <li>Linkin</li> </ul> </li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#reference","title":"Reference","text":"<ul> <li>https://bootlin.com</li> <li>https://www.linuxjournal.com/article/8498</li> <li>https://wiki.linuxfoundation.org/networking/generic_netlink_howto</li> <li>https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html</li> <li>https://www.cnblogs.com/ssyfj/p/16230540.html</li> <li>https://www.twblogs.net/a/5b81e5852b71772165aedd7a</li> <li>https://www.cnblogs.com/ssyfj/p/16230540.html</li> <li>IT blog by Ian Chen</li> <li>IT blog by 0xff07</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/","title":"Support of Time Sensitive Communication and Time Synchronization in 5G system - Introduction (Rel-17)","text":"<p>Note</p> <p>Author: Ya-shih Tseng Date: 2023/9/27</p> <p>Before you read the article, I suggest you to read  Time-Sensitive Networking over 5G system - Introduction (Rel-16).</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#overview","title":"Overview","text":"<p>This article will introduce TSN enhancements in 3GPP Release 17. We will start by discussing the new roles introduced in 5GS and their applicable scenarios. The architecture has been modified to accommodate a wider range of applications, and additional network functions have been added to offer a broader range of services.</p> <p></p> <p>Architcture to enable time sensitive communication and time synchronization</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#5gs-can-be-as-boundary-clock-and-transparent-clock","title":"5GS can be as Boundary Clock and Transparent Clock","text":"<p>Time Synchronization: describes how 5GS can operate as a PTP Relay (IEEE 802.1AS), as a Boundary Clock or as Transparent Clock (IEEE 1588) for PDU Session type Ethernet and IP.</p> <p>According to 3GPP TS 23.501 Release 17, 5GS's role in TSN goes beyond just acting as a bridge. It now extends to UDP/IP applications. In addition to its original support for Ethernet through IEEE 802.1AS Time-Aware System, it has been updated to include four types of PTP instances described in IEEE 1588.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#what-is-bc-and-tc","title":"What is BC and TC?","text":"<p>Difference types of PTP instances (clocks).</p> <ul> <li>For the BC, you can have a GM as a time source, and it can also act as a time source itself, allowing other slave clocks to synchronize their time with it.</li> <li>For the TC, it doesn't need to synchronize its time with other clocks. Its role is to receive time from one end, potentially adjust it, and then forward it to the next clock</li> </ul> <p>For more detail about PTP instance / Clock types, please check IEEE 1588v2 PTP Support.</p> <p>To support above applications, DS-TT and NW-TT have expanded their functionalities.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#capability-of-ds-tt-and-nw-tt","title":"Capability of DS-TT and NW-TT","text":"<p>With release 17 now supporting for the scenarios when Master clock is behind the UE (uplink time sync, UE \u2013 UE time sync), behind the network (downlink time sync) and support for multiple (g)PTP domains.</p> <p>Note</p> <p>In release 16, the roles of 5GS, DS-TT, and NW-TT are fixed. The Data Network side follows the TSN master, while the UE side follows the slave. When a packet enters, the entry time is first recorded in NW-TT, and the exit time is recorded in DS-TT. The difference between these two times determines the packet's resident time.</p> <p>In general case, when receiving PTP event messages from upstream PTP instances, the ingress TT (NW-TT or DS-TT) records an ingress timestamp (TSi) for each PTP event, such as Sync messages. Then, NW-TT determines whether to forward messages to DS-TT or discard it.</p> <p>Subsequently, the egress TT creates an egress timestamp (TSe) for PTP events (i.e., Sync messages) in the external PTP network and modifies the payload of the PTP message to add/update the resident time.</p> <ul> <li>As for 5GS operates as BC, NW-TT and DS-TT should support generate Sync, Follow_Up and Announce message. If DS-TT doesn't support it, NW-TT will take over.</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#ptp-transparent","title":"PTP transparent","text":"<p>TTs can support the following PTP transport modes described in IEEE 1588:</p> <ul> <li>over UDP/IPv4</li> <li>over UDP/IPv6</li> <li>over IEEE 802.3 (Ethernet)</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#delay-measurements","title":"Delay measurements","text":"<p>Different PTP instances have different measurements of path delay due to hardware limitations.</p> <p>TTs should support the following delay measurements as described in IEEE 1588:</p> <ul> <li>Delay request-response mechanism</li> <li>Peer-to-peer delay mechanism</li> <li>which we talked about it in previous article.</li> </ul> <p>Let's see what's the diference between them. </p> <p>Difference measurements of path delay</p> <ul> <li>For E2E (End-to-End) slaves send delay requests to the Master, passing through other devices in the network. Each TC (Transparent Clock) modifies the request to update the time it has spent locally. Finally, it reaches the Master, so the E2E measured delay represents the total time taken along the entire path.</li> <li>For P2P (Point-to-Point) devices, they send requests to nearby neighbors to measure the delay time between each other.</li> </ul> <p>By now, We introduce few supports for PTP instances. Then, How should these functionalities be managed?</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#time-sensitive-communication-and-time-synchronization-function","title":"Time Sensitive Communication and Time Synchronization Function","text":"<p>In release 16, TSN AF is used for exchanging messages to manage TSN bridges in conjunction with centralized network configuration (CNC). This means that TSN AF is responsible for managing the ports of DS-TT and NW-TT. Additionally, in release 17, TSCTSF is a new component introduced between PCF and NEF. To support AF requests related to time-sensitive communication.</p> <p>TSCTSF can check the PTP functionalities supported by DS-TT and NW-TT by retrieving the following port management information or user plane node management information:</p> <ul> <li>Supported PTP instance types;</li> <li>Supported transport types;</li> <li>Supported PTP delay mechanisms;</li> <li>Grandmaster capability;</li> <li>Supported PTP profiles;</li> <li>Number of supported PTP instances.</li> </ul> <p>AF can obtain the required services directly or indirectly through TSCTSF</p> <ul> <li>e.g. AF can provide traffic pattern parameters to NEF. NEF will forward the received traffic pattern parameters to TSCTSF.</li> <li>e.g. AF trusted by the operator can directly provide such traffic pattern parameters to TSCTSF.</li> </ul> <p>TSCTSF may support AF to</p> <ul> <li>Activate and deactivate the time syncgronization services</li> <li>Control the time synchronization service for target UE.</li> <li>Configure the TTs to operate on AF-selected method</li> <li>Managing the DS-TT and NW-TT via exchange of PMIC and UMIC</li> <li>Provide specific QoS traffic pattern</li> <li>Creating the TSC Assistance Container based on individual traffic pattern parameters from the NEF/AF and providing it to the PCF.</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#abbreviation","title":"Abbreviation","text":"TSN Time-Sensitive network TT TSN Translator NW-TT Network-Side TSN Translator DS-TT Device-Side TSN Translator PTP Precision Time Protocol BC Boundary Clock E2E-TC End-to-End Transparent Clock P2P-TC Peer-to-Peer Transparent Clock GM Grand Master AF Application Function TSCTSF Time Sensitive Communication and Time Synchronization Function PMIC Port Management Information Container UMIC User Plane Node Management Information Container"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#conclusion","title":"Conclusion","text":"<p>Release 17 expanded and improved the integration with IEEE TSN. This included enabling uplink synchronization through the 5G System (5GS), enhancing End-to-End Quality of Service (QoS) across multiple clock domains, and facilitating direct communication between UE within the 5GS network.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#reference","title":"Reference","text":"<ul> <li>IEEE Std 802.1AS-2020: \u201cIEEE Standard for Local and metropolitan area networks--Timing and Synchronization for Time-Sensitive Applications\u201d.</li> <li>IEEE Std 1588: \u201cIEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems\u201d, Edition 2019.</li> <li>3GPP TS 23.501 v16.6.0: \"System Architecture for the 5G System\"</li> <li>3GPP TS 23.501 v17.8.0: \"System Architecture for the 5G System\"</li> <li>3GPP TS 23.502 v17.4.0: \"Procedures for the 5G System\"</li> <li>Time-Sensitive Networking (TSN) Task Group | - IEEE 802.1</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#about","title":"About","text":"<p>Hi, This is Ya-shih Tseng. I am currently researching the implementation of 5G TSN as part of my master's studies. Feel free to discuss with me.</p> <ul> <li>Here is my linkedin profile</li> </ul>"},{"location":"blog/20231004/20231004/","title":"Introduction of MPTCP","text":"<p>Note</p> <p>Author: \u5f35\u54f2\u777f (Jerry) Date: 2023/10/04</p> <p>MPTCP (multipath TCP) is a set of extensions to regular TCP that allows a connection to use many paths to transport data simultaneously. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network, and if one path is blocked, it can use another path to transport data, improving resilience to network failure. A common use of mptcp is: Most mobile phones today have the ability to connect to wifi or mobile networks (4G/5G), but regular TCP can't use two network resources simultaneously, and if the network we were originally using (for example, wifi) is disconnected, it cannot automatically switch to using the mobile network. Therefore, the connection at the application layer will also be disconnected. In this article, I will introduce MPTCP, including how to establish an MPTCP connection, how to start a new subflow, the ack mechanism, and the congestion control algorithm it uses.</p>"},{"location":"blog/20231004/20231004/#initiating-an-mptcp-connection","title":"Initiating an MPTCP Connection","text":"<p>MPTCP implements multi-path transmission by creating multiple subflows; each subflow is similar to a general TCP connection. Use the 3-way handshaking to establish the connection. But instead of a separate connection, the subflow is bound into an existing MPTCP session. MPTCP uses SYN, SYN/ACK, and ACK packets to establish connections. But these sockets also carry the MP_CAPABLE option (in the optional field of the tcp header), which is used to verify whether the remote host supports MPTCP and exchange some information to authenticate the establishment of additional subflows.</p> <p></p> <p>RFC8684 3.1</p> <p>The above figure shows the structure of MP_CAPABLE. First, the initiator sends only 4 octets. If the listener also supports MPTCP v1, it will respond SYN/ACK, and the listener's key will be included in MP_CAPABLE. Then the initiator replies ACK, which contains the sender's key and the receiver's key. These keys are used to authenticate the addition of future subflows to this connection; all future subflows will identify the connection using a 32-bit \"token\". This token is a cryptographic hash of this key. The use of flags in the fourth octets are as follow:</p> <ul> <li>A: Indicate \"Checksum required\".</li> <li>B: It is an extensibility flag, must be set to 0.</li> <li>C: Indicate that the sender of this option will not accept additional MPTCP subflows to the source address and port.</li> <li>D through H: The flags D through H, are used for crypto algorithm negotiation. In MPTCP v1, only the rightmost bit, labeled H, is assigned. Bit H indicates the use of HMAC-SHA256.</li> </ul>"},{"location":"blog/20231004/20231004/#starting-a-new-subflow","title":"Starting a New Subflow","text":"<p>Once an MPTCP connection has begun with the MP_CAPABLE exchange, further subflows can be added to the connection. A new subflow is started as a normal TCP SYN/ACK exchange. But these packets contain the Join Connection option.</p> <p></p> <p>RFC8684 3.2</p> <p>This is the first Join Connection (MP_join) Option for the initial SYN. The token is a cryptographic hash of the receiver's key. The MP_join also contains an \"Address ID\", which is used to identify the source address of this packet. This mechanism allows addresses to be removed even if they are changed by NAT. The last bit of the third byte (flag B) indicates that the sender (1) wishes this subflow to be used as a backup path (B=1) in the event of failure of other paths or (2) wants the subflow to be used as part of the connection immediately. MP_JOIN also contains a random number to prevent replay attacks. If MP_JOIN contains a valid token, the recipient will respond with a SYN/ACK also containing an MP_JOIN option containing a random number and a truncated (leftmost 64-bit) HMAC. Transport HMAC is to have previously exchanged random data (in the first two SYN packets) that is used as the \"message\".</p> <p></p> <p>RFC8684 3.2</p> <p>If the HMAC in SYN/ACK is valid, then the initiator will send its authentication in the third packet (ACK). This data needs to be sent reliably since it is the only time this HMAC is sent. Therefore, receipt of this packet triggers a regular TCP ACK in response, and the packet will be retransmitted if this ACK is not received.</p> <p></p> <p>RFC8684 3.2</p> <p></p> <p>RFC8684 3.2</p> <p>This is total handshake procedure.</p>"},{"location":"blog/20231004/20231004/#mptcp-operation-and-data-transfer","title":"MPTCP Operation and Data Transfer","text":"<p>MPTCP takes one input data stream and splits it into subflows. It then uses a 64-bit data sequence number to number all the data and let the data be reassembled at the receiver. Each subflow has its own 32-bit sequence number space, utilizing the regular TCP sequence number header, and an MPTCP option (Data Sequence Signal optional) maps the subflow sequence space to the data sequence space. MPTCP uses the Data Sequence Signal optional to carry the Data Sequence Mapping, which consists of the subflow sequence number, data sequence number, and length for which this mapping is valid. The Data Sequence Number is the starting sequence number for the subflow, and the Subflow Sequence Number is the sequence number only relevant to the subflow. The Data Ack in the Data Sequence Signal optional is used to ACK for the connection, indicating how much data has been successfully received.</p> <p></p> <p>RFC8684 3.3</p>"},{"location":"blog/20231004/20231004/#coupled-congestion-control-algorithm","title":"Coupled Congestion Control Algorithm","text":"<p>There are two goals that MPTCP congestion control needs to meet: 1.   A multipath flow should perform at least as well as a single-path flow would on the best of the paths available to it. 2.   A multipath flow should take no more capacity on any path or collection of paths than if it were a single-path TCP flow using the best of those paths.</p> <p>The second goal is to prevent MPTCP traffic from occupying too many resources and harming other TCP flows on the bottleneck link. So if we combine the first goal and the second goal, it means that the total capacity that MPTCP occupies should equal the capacity that the best path can transport. (In the situation where there is some competitive TCP flow, if there is no other competitive flow, then MPTCP will occupy all the capacity it can use.)</p> <p>The algorithm rule: * Each ACK on subflow r, increase the window  by . * Each loss on subflow r, decrease the window  by .</p> <p> </p> <p>  is the current window size on path r,  is equilibrium window size on path r, and similarly for the total window size.</p> <p>And how  derived? Here I write down some of my thoughts after reading the paper. There may be errors. If you find any, please tell me directly. First, we assume that , so if the transmission speed of subflow r is slower than tcp, then the increments of the window size r is . Because the increase and decrease of the window in the equilibrium state are equal to each other, so we have the fallowing equation.</p> <p> </p> <p>  is the loss rate of subflow r.Then we assume loss rate is small.</p> <p> </p> <p>Now assume that there is tcp on this subflow, then we have:</p> <p> </p> <p>p is the loss rate. Here, assume p is equal to .(But actually, they would not be equal if there was no other competitive flow.  is smaller, so we measure a better tcp performence.) Substitute  with p, then we have:</p> <p> </p> <p>And we want the total capacity MPTCP occupies to equal the capacity that the best path can transport using TCP. So we have the equation:</p> <p> </p> <p>Window size divide by RTT is the traffic send on path per second.</p> <p> </p> <p> </p> <p>Finally, we can derive .</p> <p> </p> <p>Because tcp performance on path r is measured by loss rate , if there is no competitive flow, mptcp can use more resources, and the increments of the window finally bounded by . So if we only run mptcp on many paths, it's like we have many TCP connecion, the total traffic is sum of every subflow's max transmission capability.</p>"},{"location":"blog/20231004/20231004/#how-to-use-mptcp","title":"How to use MPTCP","text":"<p>As for how to use mptcp under Linux system, you can refer to this article. It describes how to use mptcpize to change the original tcp connection to mptcp.</p>"},{"location":"blog/20231004/20231004/#about","title":"About","text":"<p>Hello! My name is \u5f35\u54f2\u777f, and my current research topic is ATSSS (Access Traffic Steering, Switching and Splitting).  If you find any mistakes in my articles, please contact me.</p> <ul> <li>Linkedln</li> </ul>"},{"location":"blog/20231004/20231004/#reference","title":"Reference","text":"<ul> <li>RFC 8684</li> <li>RFC 6356</li> <li>Coupled Congestion Control Algorithm</li> <li>MPTCP congestion control</li> <li>How to use MPTCP</li> </ul>"},{"location":"blog/20231018/20231018/","title":"LTE Authentication Introduction: EPS-AKA'","text":"<p>Note</p> <p>Author: Wilson Date: 2023/10/18</p>"},{"location":"blog/20231018/20231018/#abstract","title":"Abstract","text":"<p>In this article, I will delve into the topic of EPS-AKA', a subject closely related to 4G network security. The article is structured as follows:</p> <ol> <li>An introduction to EPS-AKA'.</li> <li>An explanation of the concept of authentication.</li> <li>An exploration of key hierarchy generation in the 4G network, emphasizing its relevance to the EPS-AKA' procedure.</li> <li>A detailed examination of the EPS-AKA' procedure.</li> <li>A comparison between 4G AKA and 5G AKA, highlighting both their similarities and differences.</li> </ol>"},{"location":"blog/20231018/20231018/#introduction","title":"Introduction","text":"<p>Every day, people use apps like Line to send messages, watch videos on YouTube, and send emails via Gmail. To do any these activities, a connection to the Internet must be established. However, once a connection is made, the data packets transmitted are at risk of being intercepted. To ensure the confidentiality of the data and to verify its integrity, the LTE Security Procedure is initiated whenever a mobile phone goes online or sends a message.</p> <p>The LTE Security Procedure is categorized into three stages :</p> <ul> <li>EPS-AKA'</li> <li>NAS Security</li> <li>AS Security</li> </ul> <p>EPS-AKA' stands for \"Evolved Packet System-Authentication and Key Agreement\". As suggested by its full name, AKA primarily involves two key actions:</p> <ul> <li>Authentication</li> <li>Key Agreement</li> </ul> <p>The focus of this article will be on EPS-AKA', which is further divided into two main steps:</p> <ol> <li>In the first step, the network generate an authentication vector. Some of the information within this vector is used for authentication.</li> <li>The second step involves mutual authentication between the user and the network.</li> </ol>"},{"location":"blog/20231018/20231018/#understanding-the-definition-of-authentication","title":"Understanding the Definition of Authentication","text":"<p>Most people have come across the term \"authentication\", and its definition varies depending on context and interpretation. For the purposes of this article, and based on my own understanding, I'll use an everyday analogy to explain the concept of authentication.</p> <p>Imagine during summer of winter vacation, your family decides to travel abroad. Before you board the plane, you must clear customs. The customs officier determines if you can proceed by examining your passport. This procedure resembles the process of authentication. As illustrated in Figure 1, a traveler presents their passport to a customs officer who then compares the passport details with information on their computer. If the passport's contents match the computer's records, you are granted passage. At the heart of authentication is this act of verification.</p> <p>In the context of the EPS-AKA' procedure, authentication occurs twice:</p> <ol> <li>Initially, the HSS provides the  to the UE. The UE then compares the received  whith its . If the  mathes the , it indicates sucessful authentication. This step verifies the authenticity of the HSS and, by extension, the network.</li> <li>In the second instance, the UE forwards the RES to the MME. The MME then compares the provided RES with the XRES. If the RES aligns with the XRES, authentication is successful. This stage confirms the authenticity of the UE.</li> </ol> <p> Figure 1. The Definition of Authentication</p>"},{"location":"blog/20231018/20231018/#key-hierarchy-generation-in-4g","title":"Key Hierarchy Generation in 4G","text":"<p>The Figure 2 is the key hierarchy generation in 4G. When an UE is generated, the <code>IMSI</code> and <code>K</code> value are stored in the USIM card, and the <code>IMSI</code> and <code>K</code> value are regarded as the permanent value. When an UE subscribes to the operator's network, the HSS will get the permanent value of the UE's <code>IMSI</code> and <code>K</code>.</p> <p>The USIM and HSS use the <code>K</code> as the base to generate the <code>CK</code> and <code>IK</code> in the EPS-AKA' stage of the LTE Security Procedure. The HSS uses the <code>CK</code> and <code>IK</code> as the base to generate the  and transmits the  to the MME. The USIM transmits the <code>CK</code> and <code>IK</code> to the UE, and UE uses the <code>CK</code> and <code>IK</code> as the base to generate the .</p> <p>The UE and MME use the  as the base and generate separately three keys in the NAS Security stage of the LTE Security Procedure. Three keys are the , , and . The  and  are used in the NAS Security stage, and the  is transmitted to the eNodeB.</p> <p>The UE and eNodeB use the  as the base and generate separately three keys in the AS Security stage of the LTE Security Procedure. Three keys are the , , and .</p> <p> Figure 2. Key Hierarchy Generation in 4G</p>"},{"location":"blog/20231018/20231018/#eps-aka-procedure","title":"EPS-AKA' Procedure","text":"<p> Figure 3. EPS-AKA' Procedure</p>"},{"location":"blog/20231018/20231018/#the-ue-sends-the-attach-request-to-the-mme","title":"The UE sends the <code>Attach Request</code> to the MME","text":"<p>The Figure 3 shows the entire EPS-AKA' procedure. The UE sends the <code>Attach Request</code> to the MME. The <code>Attach Request</code> contains the <code>IMSI</code>, <code>UE Network Capability</code>, and . The <code>IMSI</code> is like the ID number of this UE. The <code>UE Network Capability</code> is what encryption and integrity protection algorithms the UE supports. The UE sends <code>UE Network Capability</code> to tell MME. The content of <code>UE Network Capability</code> is like EEA0=on, EEA1=on, EEA2=off, ..., EIA1=on, EIA2=on, ... The on and off symbols are represented by one bit. The  represents the number corresponding to the . The  is represented by 3 bits. The value of  is 7, which means that the UE does not have the  yet.</p>"},{"location":"blog/20231018/20231018/#the-mme-sends-the-authentication-information-request-to-the-hss","title":"The MME sends the <code>Authentication Information Request</code> to the HSS","text":"<p>The MME sends the <code>Authentication Information Request</code> to the HSS after receiving the <code>Attach Request</code>. The <code>Authentication Information Request</code> contains the <code>IMSI</code>, <code>SN ID</code>, <code>n</code>, and <code>Network Type</code>. The full English name of <code>SN ID</code> is Serving Network ID, which refers to the network that the user wants to connect to. The value of <code>SN ID</code> is usually composed of the MCC and MNC (PLMN ID). The <code>n</code> represents how many verifcation vectors are sent to the HSS. The <code>Network Type</code> is what kind of wireless network the user wants to connect to the Internet from my understanding.</p>"},{"location":"blog/20231018/20231018/#the-hss-sends-the-authentication-information-answer-to-the-mme","title":"The HSS sends the <code>Authentication Information Answer</code> to the MME","text":"<p>The HSS automatically generates the <code>RAND</code> and <code>SQN</code> after receiving the <code>Authentication Information Request</code>. The HSS inputs the <code>K</code>, <code>SQN</code>, and <code>RAND</code> into the Cryptographic Function. The Cryptographic Function uses the EPS AKA algorithm and outputs the <code>XRES</code>, , <code>CK</code>, and <code>IK</code>. The HSS inputs the <code>CK</code>, <code>IK</code>, <code>SQN</code>, and <code>SN ID</code> into the KDF (Key Derivation Function). The KDF outputs . Then, the <code>RAND</code> that is generated by the HSS itself, the  and <code>XRES</code> that are generated by the Cryptographic Function, and the  that is generated by KDF are combined into the AV. The <code>Authentication Information Answer</code> includes AV and is sent to the MME.</p>"},{"location":"blog/20231018/20231018/#the-mme-sends-the-authentication-request-to-the-ue","title":"The MME sends the <code>Authentication Request</code> to the UE","text":"<p>The MME selects an AV among multiple AVs and sends the <code>Authentication Request</code> to the UE after receiving the <code>Authentication Information Answer</code>. The <code>Authentication Request</code> contains the <code>RAND</code>, , and .</p>"},{"location":"blog/20231018/20231018/#the-ue-sends-the-authentication-response-to-the-mme","title":"The UE sends the <code>Authentication Response</code> to the MME","text":"<p>The UE receives the <code>Authentication Request</code>. Why do you see the <code>SQN</code> is generated by the HSS in the Figure 3? The  carries the <code>SQN</code>. The UE can find the <code>SQN</code> in the . The USIM inputs the <code>K</code>, <code>SQN</code>, and <code>RAND</code> into the Cryptographic Function. The Cryptographic Function uses the EPS AKA algorithm and outputs the <code>RES</code>, , <code>CK</code>, and <code>IK</code>. When the UE gets , it compares the  with the . If the authentication is successful, the UE will generate the <code>RES</code>. The <code>Authentication Response</code> contains the <code>RES</code> and is returned to the MME.</p>"},{"location":"blog/20231018/20231018/#the-mme-receives-the-authentication-response","title":"The MME receives the <code>Authentication Response</code>","text":"<p>The MME compares the <code>XRES</code> with <code>RES</code> after receiving the <code>Authentication Response</code>. If the content of the <code>XRES</code> and <code>RES</code> are the same, it means that the authentication is successful. The authentication stage has come to an end.</p> <p>Finally, the UE inputs the <code>CK</code>, <code>IK</code>, <code>SQN</code>, and <code>SN ID</code> into the KDF. The KDF outputs . The UE and MME have the same . The  doesn't be transmitted between the UE and MME. The  is transmitted in the form of the  to prevent the  from being stolen by a third party.</p>"},{"location":"blog/20231018/20231018/#4g-vs-5g-aka-a-comparison","title":"4G vs. 5G AKA: A Comparison","text":"<p>Similarities:</p> <ol> <li>Both 4G and 5G UEs utilize the same Universal Subscriber Identity Module (USIM).</li> <li>Both systems rely on shared symmetric keys for authentication.</li> </ol> <p>Differences:</p> <ol> <li> <p>Authentication Mechanism:</p> <ul> <li>4G: EPS-AKA'</li> <li>5G: 5G-AKA and EAP-AKA'</li> </ul> </li> <li> <p>Serving Network:</p> <ul> <li>4G: MME</li> <li>5G: SEAF</li> </ul> </li> <li> <p>Home Network:</p> <ul> <li>4G: HSS</li> <li>5G: AUSF, UDM, ARPF, and SIDF</li> </ul> </li> <li> <p>Network Function for Authentication Vector Generation:</p> <ul> <li>4G: HSS</li> <li>5G: UDM and ARPF</li> </ul> </li> <li> <p>Network Function to Verify UE Identity:</p> <ul> <li>4G: MME</li> <li>5G<ul> <li>5G-AKA: SEAF and AUSF</li> <li>EAP-AKA': AUSF</li> </ul> </li> </ul> </li> <li> <p>Key Hierarchy Generation:</p> <ul> <li>4G: K -&gt; CK + IK -&gt;  </li> <li>5G<ul> <li>5G-AKA: K -&gt; CK + IK -&gt;  -&gt;  </li> <li>EAP-AKA': K -&gt; CK + IK -&gt; CK' + IK' -&gt;  -&gt;  </li> </ul> </li> </ul> </li> </ol>"},{"location":"blog/20231018/20231018/#reference","title":"Reference","text":"<ul> <li>LTE Security I: Concept and Authentication</li> <li>LTE Security II: NAS and AS Security</li> <li>https://kknews.cc/zh-tw/code/65y6x9l.html</li> <li>https://nccnews.com.tw/202010/ch4.html</li> </ul>"},{"location":"blog/20231018/20231018/#about","title":"About","text":"<p>Hi, my name is Wilson. I am a master\u2019s student. My main area of research is network slicing. In the future, I will introduce more information about 5G. Hope you enjoy it.</p>"},{"location":"blog/20231108/20231108/","title":"Introduction of IP Multimedia Subsystem Part 1","text":"<p>Note</p> <p>Author: Elisa Lee Date: 2023/11/08</p> <p>The IMS is a framework for delivering multimedia and voice services over IP networks. It plays a crucial role in enabling communication services like voice, video, and messaging to be delivered in a converged, efficient, and scalable manner.</p>"},{"location":"blog/20231108/20231108/#definition-and-overview-of-ims","title":"Definition and Overview of IMS","text":""},{"location":"blog/20231108/20231108/#introduction-to-ims","title":"Introduction to IMS","text":"<p>A standardized, open architectural framework that allows multimedia services to be delivered over IP networks. It is defined by the 3GPP (3rd Generation Partnership Project) and widely used in mobile networks.</p>"},{"location":"blog/20231108/20231108/#purpose-and-significance-of-ims","title":"Purpose and Significance of IMS","text":""},{"location":"blog/20231108/20231108/#purpose-of-ims","title":"Purpose of IMS","text":""},{"location":"blog/20231108/20231108/#multimedia-services","title":"Multimedia Services","text":"<p>IMS is designed to support a wide range of multimedia services such as voice, video, messaging, and data services over IP networks.</p>"},{"location":"blog/20231108/20231108/#interoperability","title":"Interoperability","text":"<p>It provides a standardized architecture that allows different network elements and applications from various vendors to work together seamlessly. This promotes interoperability, which is vital in a diverse telecommunications ecosystem.</p>"},{"location":"blog/20231108/20231108/#service-convergence","title":"Service Convergence","text":"<p>IMS allows the convergence of various services like voice, video, and data onto a single IP network. This makes it possible for users to access multiple services through a unified interface.</p>"},{"location":"blog/20231108/20231108/#quality-of-service-qos","title":"Quality of Service (QoS)","text":"<p>IMS enables network operators to prioritize and manage different types of traffic, ensuring that services like voice and video receive the necessary bandwidth and low latency for a high-quality user experience.</p>"},{"location":"blog/20231108/20231108/#session-management","title":"Session Management","text":"<p>It manages sessions for different types of services, ensuring that sessions are established, maintained, and terminated appropriately.</p>"},{"location":"blog/20231108/20231108/#mobility-management","title":"Mobility Management","text":"<p>IMS allows for seamless mobility across different access networks (e.g., Wi-Fi, LTE, 5G), ensuring continuity of services as users move between different coverage areas.</p>"},{"location":"blog/20231108/20231108/#security","title":"Security","text":"<p>IMS incorporates security features and protocols to protect the confidentiality, integrity, and authenticity of communication sessions.</p>"},{"location":"blog/20231108/20231108/#billing-and-charging","title":"Billing and Charging","text":"<p>It supports real-time charging and billing capabilities, allowing operators to accurately charge users for the services they consume.</p>"},{"location":"blog/20231108/20231108/#significance-of-ims","title":"Significance of IMS","text":""},{"location":"blog/20231108/20231108/#transition-to-all-ip-networks","title":"Transition to All-IP Networks","text":"<p>IMS is a key enabler in the shift from traditional circuit-switched networks to all-IP networks. This transition is essential for supporting advanced multimedia services.</p>"},{"location":"blog/20231108/20231108/#facilitates-4g-and-5g-technologies","title":"Facilitates 4G and 5G Technologies","text":"<p>IMS is a critical component for the deployment and operation of 4G LTE and 5G networks, providing the infrastructure for delivering high-speed data services and advanced multimedia applications.</p>"},{"location":"blog/20231108/20231108/#enhances-user-experience","title":"Enhances User Experience","text":"<p>By enabling the delivery of high-quality multimedia services, IMS significantly enhances the user experience, particularly for applications like video calling, streaming, and real-time gaming.</p>"},{"location":"blog/20231108/20231108/#enables-next-generation-services","title":"Enables Next-Generation Services","text":"<p>IMS is foundational for emerging technologies like IoT (Internet of Things) and Industry 4.0, enabling a wide range of applications and services across various industries.</p>"},{"location":"blog/20231108/20231108/#promotes-innovation","title":"Promotes Innovation","text":"<p>IMS's standardized architecture encourages innovation by allowing developers to create new services and applications that can run on IMS-enabled networks.</p>"},{"location":"blog/20231108/20231108/#global-standardization","title":"Global Standardization","text":"<p>IMS is based on international standards defined by organizations like 3GPP and ETSI (European Telecommunications Standards Institute), ensuring global compatibility and uniformity in telecommunications networks.</p>"},{"location":"blog/20231108/20231108/#key-components-of-ims","title":"Key Components of IMS","text":""},{"location":"blog/20231108/20231108/#sip-session-initiation-protocol","title":"SIP (Session Initiation Protocol)","text":"<p>SIP is a signaling protocol used for initiating, maintaining, modifying, and terminating real-time sessions that involve video, voice, messaging, and other communications applications and services over the internet. It operates at the application layer of the OSI model and is widely used for VoIP (Voice over Internet Protocol) and other multimedia communication applications.</p>"},{"location":"blog/20231108/20231108/#role-of-sip-in-ims","title":"Role of SIP in IMS","text":"<p>In the context of IMS, SIP serves as the primary signaling protocol.</p>"},{"location":"blog/20231108/20231108/#session-establishment","title":"Session Establishment","text":"<p>SIP is used to initiate communication sessions between devices or applications. When a user wants to make a call, send a message, or establish a multimedia session, SIP is responsible for setting up the connection.</p>"},{"location":"blog/20231108/20231108/#user-location-and-registration","title":"User Location and Registration","text":"<p>SIP allows devices to register their location on the network. This information is crucial for routing calls and messages to the correct destination.</p>"},{"location":"blog/20231108/20231108/#call-control","title":"Call Control","text":"<p>SIP handles the signaling for call control functions such as call setup, call hold, call transfer, and call release. It defines how these operations should be communicated between endpoints.</p>"},{"location":"blog/20231108/20231108/#service-invocation","title":"Service Invocation","text":"<p>It enables the invocation of various services within IMS, like call forwarding, call waiting, and supplementary services.</p>"},{"location":"blog/20231108/20231108/#session-modification-and-termination","title":"Session Modification and Termination","text":"<p>SIP is also responsible for modifying existing sessions (e.g., adding participants to a call) and terminating sessions when the user ends the communication.</p>"},{"location":"blog/20231108/20231108/#media-negotiation","title":"Media Negotiation","text":"<p>While SIP is responsible for signaling, it doesn't handle the actual media (audio, video, etc.) transfer. It works in conjunction with protocols like RTP (Real-time Transport Protocol) for media transmission.</p>"},{"location":"blog/20231108/20231108/#signaling-for-establishing-modifying-and-terminating-sessions","title":"Signaling for establishing, modifying, and terminating sessions","text":""},{"location":"blog/20231108/20231108/#session-establishment_1","title":"Session Establishment:","text":"<ul> <li> <p>Caller's Request: The caller's device sends a SIP INVITE message to the SIP server, indicating the intention to establish a session with the callee.</p> </li> <li> <p>SIP Server Processing: The SIP server processes the INVITE message. It checks the user's location and forwards the request to the recipient's SIP server.</p> </li> <li> <p>Recipient's Response: The recipient's SIP server delivers the INVITE message to the callee's device. If the recipient is available and agrees to the session, their device sends a SIP 200 OK response back.</p> </li> <li> <p>Session Establishment: Once the caller's device receives the 200 OK response, it acknowledges the establishment of the session. The media streams (audio, video, etc.) can then begin.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#session-modification","title":"Session Modification","text":"<p>If a user wants to modify an ongoing session, such as adding another participant to a call, the SIP signaling is used to send an UPDATE request. This request is processed by the SIP servers and communicated to the affected parties.</p>"},{"location":"blog/20231108/20231108/#session-termination","title":"Session Termination","text":"<p>When a user decides to end a session, their device sends a SIP BYE message. This message is processed by the SIP servers, and the appropriate responses are sent to indicate the termination of the session. It's important to note that SIP is a text-based protocol, and it uses URLs similar to those used on the web to identify users and services. This makes it versatile and easy to integrate into existing internet infrastructure.</p>"},{"location":"blog/20231108/20231108/#sdp-session-description-protocol","title":"SDP (Session Description Protocol)","text":"<p>The SDP is a protocol used in multimedia communications to negotiate and describe sessions between participants. It provides a concise and human-readable way to convey information about the characteristics of a multimedia session.</p>"},{"location":"blog/20231108/20231108/#role-of-sdp-in-session-negotiation-and-description","title":"Role of SDP in session negotiation and description","text":""},{"location":"blog/20231108/20231108/#session-negotiation","title":"Session Negotiation","text":"<ul> <li> <p>Media Types: This includes information about the type of media (e.g., audio, video, application data) that will be exchanged during the session.</p> </li> <li> <p>Codecs and Formats: SDP specifies which codecs (compression/decompression algorithms) and formats will be used for media encoding and decoding.</p> </li> <li> <p>Transport Protocols: It describes the transport protocol and ports that will be used for sending and receiving media packets.</p> </li> <li> <p>Network Addresses: SDP provides information about the IP addresses and ports where media should be sent.</p> </li> <li> <p>Timing and Synchronization: SDP can include information about timing aspects like session start and end times, as well as synchronization of different media streams.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#session-description","title":"Session Description","text":"<p>SDP accomplishes session description by providing a structured text-based format that includes information about the session parameters mentioned above. This description is typically conveyed in the form of an SDP message.</p>"},{"location":"blog/20231108/20231108/#negotiating-capabilities","title":"Negotiating Capabilities","text":"<ul> <li> <p>Establishing Media Streams: SDP is crucial for establishing media streams. It specifies how media should be encoded, transported, and synchronized between participants. This ensures that audio, video, and other data are transmitted and received correctly.</p> </li> <li> <p>Interoperability: SDP is a standardized format, allowing devices and applications from different vendors to communicate effectively. This promotes interoperability, which is crucial in diverse multimedia environments.</p> </li> <li> <p>Dynamic Adaptation: SDP can be updated dynamically during a session. For example, if network conditions change, SDP can be used to renegotiate parameters like codecs or bitrates to ensure the best possible quality.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#hss-home-subscriber-server","title":"HSS (Home Subscriber Server)","text":"<p>The HSS is a crucial component within the IMS architecture. It serves as a central database that stores and manages subscriber-related information for users in a telecommunications network.</p>"},{"location":"blog/20231108/20231108/#definition-and-function-of-hss-in-ims","title":"Definition and function of HSS in IMS","text":""},{"location":"blog/20231108/20231108/#definition","title":"Definition","text":"<p>The HSS is a core network element in the IMS architecture. It is a centralized database that contains essential information about subscribers, including their identities, services, and authentication credentials. The HSS plays a pivotal role in facilitating various services and functions within IMS.</p>"},{"location":"blog/20231108/20231108/#function-of-hss-in-ims","title":"Function of HSS in IMS","text":"<ul> <li> <p>Subscriber Profile Management: The HSS stores detailed information about each subscriber, including their IMS public user identity, contact information, allocated services, and preferences. This data is used for session setup, authorization, and routing decisions.</p> </li> <li> <p>Authentication and Authorization: HSS is responsible for authenticating users when they attempt to access IMS services. It verifies the subscriber's credentials (such as username and password) before granting access. Additionally, it provides information about the services and capabilities available to each subscriber.</p> </li> <li> <p>Subscriber Location: It keeps track of the location of subscribers within the network. This information is crucial for routing calls and messages to the appropriate serving network element.</p> </li> <li> <p>Security Functions: The HSS plays a role in the security architecture of IMS. It stores security-related keys and information necessary for secure communication between the subscriber's device and the IMS network.</p> </li> <li> <p>Policy and Charging Control (PCC): HSS may also be involved in policy control and charging decisions. It provides information about the subscriber's subscription and policy rules that dictate how services are delivered and charged.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#managing-subscriber-data-and-authentication","title":"Managing subscriber data and authentication","text":""},{"location":"blog/20231108/20231108/#managing-subscriber-data","title":"Managing Subscriber Data","text":"<ul> <li> <p>Subscriber Registration: When a subscriber logs into the network, the HSS is involved in the registration process. It verifies the subscriber's identity and allocates necessary resources and services.</p> </li> <li> <p>Profile Updates: The HSS is responsible for updating subscriber profiles. This includes adding or removing services, updating contact information, or changing authentication credentials.</p> </li> <li> <p>Roaming Support: In the case of roaming, the HSS plays a key role in managing the subscriber's information, ensuring that services can be delivered seamlessly across different networks.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#authentication","title":"Authentication","text":"<ul> <li> <p>Challenge-Response Mechanism: When a subscriber attempts to access IMS services, the HSS challenges the subscriber's device for authentication credentials.</p> </li> <li> <p>Verifying Credentials: The HSS verifies the subscriber's credentials using authentication algorithms and keys. This ensures that only authorized users can access the network.</p> </li> <li> <p>Generating Security Tokens: After successful authentication, the HSS generates security tokens that are used to secure the communication sessions between the subscriber's device and the network.</p> </li> <li> <p>Subscriber Privacy and Security: The authentication process ensures that subscriber information and communication sessions are protected from unauthorized access and interception.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#cscf-call-session-control-function","title":"CSCF (Call Session Control Function)","text":"<p>The CSCF is a crucial element in the IMS architecture, responsible for handling call/session control and routing within the network. There are three types of CSCFs, each serving specific roles in the IMS framework.</p>"},{"location":"blog/20231108/20231108/#proxy-cscf-p-cscf","title":"Proxy CSCF (P-CSCF)","text":"<p>The P-CSCF is a vital component within the IMS architecture. It serves as the initial point of contact for UE (User Equipment) when establishing communication sessions. The P-CSCF behaves as a proxy, managing incoming requests by either processing them internally or forwarding them to appropriate destinations. It does not modify the Request URI in the SIP INVITE message. In certain scenarios, the P-CSCF may also act as a User Agent, independently generating SIP transactions. Additionally, the P-CSCF's address is discovered by UEs following PDP context activation, allowing for seamless initiation of sessions.</p>"},{"location":"blog/20231108/20231108/#key-functions","title":"Key Functions","text":"<ul> <li> <p>Forwarding SIP register requests from the UE to the appropriate I-CSCF based on the UE's home domain.</p> </li> <li> <p>Relaying SIP messages received from the UE to the designated SIP server (e.g., S-CSCF) obtained during the registration process.</p> </li> <li> <p>Forwarding SIP requests or responses to the UE.</p> </li> <li> <p>Detecting and handling emergency session establishment requests according to specified error handling procedures.</p> </li> <li> <p>Generating Call Detail Records for transaction records.</p> </li> <li> <p>Establishing and maintaining Security Associations with each UE.</p> </li> <li> <p>Performing SIP message compression and decompression.</p> </li> <li> <p>Authorizing bearer resources and managing QoS</p> </li> </ul>"},{"location":"blog/20231108/20231108/#interrogating-cscf-i-cscf","title":"Interrogating CSCF (I-CSCF)","text":"<p>The I-CSCF functions as the initial entry point within an operator's network for all incoming connections directed to a user of that network operator or to a roaming user currently situated within the operator's service area. An operator's network may incorporate multiple I-CSCFs to manage these incoming connections effectively.</p>"},{"location":"blog/20231108/20231108/#key-functions_1","title":"Key Functions","text":"<ul> <li>Assigning a Serving-CSCF (S-CSCF) to a user during the SIP registration process.</li> <li>Routing SIP requests received from other networks to the appropriate S-CSCF.</li> <li>Retrieving the S-CSCF address from the HSS.</li> <li>Forwarding SIP requests or responses to the determined S-CSCF.</li> <li>Generating Call Detail Records to maintain transaction records.</li> </ul>"},{"location":"blog/20231108/20231108/#serving-cscf-s-cscf","title":"Serving CSCF (S-CSCF)","text":"<p>The S-CSCF is a pivotal component in the IMS architecture. Its primary role involves providing session control services for the UE. The S-CSCF maintains a session state essential for supporting various services as required by the network operator. It's worth noting that different S-CSCFs within an operator's network may have varying functionalities tailored to specific requirements.</p>"},{"location":"blog/20231108/20231108/#key-functions_2","title":"Key Functions","text":"<ul> <li>May act as a Registrar, accepting registration requests and making its information available through the location server (e.g., HSS).</li> <li>Controls sessions for registered endpoints, including rejecting IMS communication to/from barred public user identities.</li> <li>May behave as a Proxy Server, handling requests internally or forwarding them.</li> <li>May behave as a User Agent, capable of terminating and independently generating SIP transactions.</li> <li>Provides endpoints with service event-related information, such as notification of tones/announcements and location of additional media resources, along with billing notifications.</li> <li>Obtains the Address of the I-CSCF for the network operator serving the destination user and forwards SIP requests/responses accordingly.</li> <li>Routes SIP requests/responses based on the type of procedure.</li> </ul>"},{"location":"blog/20231108/20231108/#cscfs-role-in-callsession-control-and-routing","title":"CSCFs Role in Call/Session Control and Routing","text":""},{"location":"blog/20231108/20231108/#session-setup-and-control","title":"Session Setup and Control","text":"<ul> <li> <p>P-CSCF: Acts as the first point of contact for UE and handles initial session signaling. It forwards requests to the appropriate destination, facilitating session establishment.</p> </li> <li> <p>I-CSCF: Serves as the entry point within the operator's network for connections directed to a user. It assigns a S-CSCF during SIP registration and routes requests/responses accordingly.</p> </li> <li> <p>S-CSCF: Manages session control services for the UE. It maintains a session state as required by the network operator and controls sessions for registered endpoints.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ul> <li> <p>P-CSCF: May perform Registrar functions, accepting registration requests from the UE and making information available through the location server (e.g., HSS).</p> </li> <li> <p>S-CSCF: Manages authentication and authorization for the UE, ensuring secure access to network services.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#routing-and-interrogation","title":"Routing and Interrogation","text":"<ul> <li>I-CSCF: Routes SIP requests received from other networks towards the appropriate S-CSCF. It retrieves the S-CSCF address from the HSS and forwards requests/responses accordingly.</li> </ul>"},{"location":"blog/20231108/20231108/#service-enforcement","title":"Service Enforcement","text":"<ul> <li>S-CSCF: Enforces services by providing endpoints with service event-related information, such as notification of tones/announcements, location of additional media resources, and billing notifications.</li> </ul>"},{"location":"blog/20231108/20231108/#interworking-with-other-networks","title":"Interworking with Other Networks","text":"<ul> <li>S-CSCF: Depending on operator policy, may forward SIP requests or responses to SIP servers located within an ISP domain outside of the IMS Core Network. It can also forward requests for call routing to the PSTN or CS Domain.</li> </ul>"},{"location":"blog/20231108/20231108/#architecture-and-interfaces-of-ims","title":"Architecture and Interfaces of IMS","text":""},{"location":"blog/20231108/20231108/#architecture-of-ims","title":"Architecture of IMS","text":""},{"location":"blog/20231108/20231108/#mgcfmedia-gateway-control-function","title":"MGCF(Media Gateway Control Function)","text":"<p>The MGCF is a crucial component within the IMS architecture. Its primary role is to facilitate the interconnection between the IMS network and circuit-switched networks, such as the Public Switched Telephone Network (PSTN) or the Circuit-Switched domain.</p>"},{"location":"blog/20231108/20231108/#asapplication-server","title":"AS(Application Server)","text":"<p>An AS in the context of the IMS is a critical component responsible for providing various value-added services to users within the IMS network. The AS hosts and executes applications that deliver a wide range of services, enriching the user experience with multimedia capabilities.</p>"},{"location":"blog/20231108/20231108/#tas-telephony-application-server","title":"TAS (Telephony Application Server)","text":"<p>The TAS is a critical component within the IMS architecture. It plays a key role in delivering advanced telephony services and features in a multimedia-rich environment. The TAS is responsible for the provisioning, execution, and control of telephony-related applications and services within the IMS network.</p>"},{"location":"blog/20231108/20231108/#p-cscf","title":"P-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#i-cscf","title":"I-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#s-cscf","title":"S-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#hss","title":"HSS","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#interfaces-of-ims","title":"Interfaces of IMS","text":""},{"location":"blog/20231108/20231108/#gm-interface","title":"Gm Interface","text":"<ul> <li>Description: The Gm Interface plays a pivotal role in all user-based communications. It serves as the link between the UE and the P-CSCF, facilitating various functions such as registration, de-registration, handling incoming and outgoing calls, managing SIP signaling, and enabling any form of communication between the user and the IMS network. To ensure security, the Gm and Mw Interfaces are physically isolated. This interface is responsible for authentication, encryption, and comprehensive session control. Gm utilizes SIP and SDP protocols.</li> <li>Function: Facilitates connectivity between the UE and the IMS network for tasks including registration, authentication, encryption, and session control.</li> </ul>"},{"location":"blog/20231108/20231108/#mw-interface","title":"Mw Interface","text":"<ul> <li>Description: The Mw Interface facilitates communication between CSCF nodes within the IMS core network. Usually, the Session Border Controller (SBC) hosts the P-CSCF, establishing a connection to the I/S-CSCF through the Mw Protocol. Mw employs SIP and SDP Protocols to enable this connectivity.</li> <li>Function: Facilitates message exchange between CSCFs (e.g., from P-CSCF to S-CSCF)</li> </ul>"},{"location":"blog/20231108/20231108/#isc-interface","title":"ISC Interface","text":"<ul> <li>Description: The ISC interface establishes connectivity between the S-CSCF and TAS (Telephony Application Server). This interface engages with the MMTel supplementary services deployed on the TAS, utilizing the IMS Service Control Interface to request services. Additionally, it accommodates TAS-initiated requests to the IMS.</li> <li>Function: The S-CSCF interacts with the MMTel supplementary services integrated into the TAS.</li> </ul>"},{"location":"blog/20231108/20231108/#sh-interface","title":"Sh Interface","text":"<ul> <li>Description: The Sh Interface is employed between the TAS and HSS to facilitate the exchange of User Profile information, encompassing service-related details, user location information, and charging function data. It enables the transmission of service and subscriber-related information from the HSS to the TAS. This operation is akin to a Location Update between the HSS and TAS. Sh operates using the Diameter protocol.</li> <li>Function: The TAS retrieves user profiles from the HSS and activates services for the user.</li> </ul>"},{"location":"blog/20231108/20231108/#cx-interfaces","title":"Cx Interfaces","text":"<ul> <li>Description:The Cx Interface is utilized between the I/S-CSCF and HSS to download subscriber data from the HSS to the S-CSCF. It enables IMS registration and the transfer of subscriber data to the S-CSCF. Cx operates on the Diameter protocol.</li> <li>Function: The I/S-CSCF communicates with the HSS to retrieve user profiles, assisting in user registration and authentication.</li> </ul>"},{"location":"blog/20231108/20231108/#rx-interface","title":"Rx Interface","text":"<ul> <li>Description: The Rx interface serves as a bridge between the IMS Network and the Packet Core. It operates between the P-CSCF and the PCRF, enabling the request of an appropriate policy for session establishment, including both incoming and outgoing voice calls. The Rx Interface plays a crucial role in controlling the setup of various call types, thereby authorizing and managing resource usage in the access networks. It operates on the Diameter protocol.</li> <li>Function: Establishing a suitable policy for incoming or outgoing calls on the network through PCRF.</li> </ul>"},{"location":"blog/20231108/20231108/#mg-interface","title":"Mg Interface","text":"<ul> <li>Description: The Mg Interface facilitates the transmission of SIP messages between an S/I-CSCF and an MGCF for signaling purposes. It is utilized for the exchange of signaling between the CSCF and Media Gateway for calls coming and going towards circuit core networks.</li> <li>Function: Facilitates interworking with the circuit-switched network for the CSCF.</li> </ul>"},{"location":"blog/20231108/20231108/#reference","title":"Reference","text":"<p>3GPP TS 29 163: \"Interworking between the IP Multimedia (IM) Core Network (CN) subsystem and Circuit Switched (CS) networks\"</p> <p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 24.229: \"IP multimedia call control protocol based on Session Initiation Protocol (SIP) and Session Description Protocol (SDP) - Stage 3\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20231108/20231108/#about","title":"About","text":"<p>Hello, I am Elisa Lee. My ongoing research revolves around VoNR (Voice over New Radio). I encourage any inquiries or identification of errors within the article, as they are welcomed for correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/","title":"Introduction to free5GC OAuth2 Procedure","text":"<p>Note</p> <p>Author: Andy Chen (CTFang, Tsung-Fang Chen) Date: 2023/11/15 Update: 2024/02/21</p> <p></p> <p>Description</p> <p>[0-0]. NF_Registration: See TS 29.510 Section5.2.2.2 NFRegister for more details.</p> <p>[0-1]. When an NF registers with NRF using NFProfile, NRF adds <code>CustomInfo.oauth2=true</code> to NFProfile and replies to NF upon successful registration. (See TS29.510 for more detailed information about CustomInfo.)</p> <p>[1]. The <code>GetTokenCtx()</code> function generates a context and inserts the access token into the request header.</p> <p>[2]. If the token has expired, the NF would use <code>SendAccTokenReq()</code> to obtain a new token from NRF.</p> <p>[3]. NRF would verify the request NFType and the requested service for authorization, and issue the token if authorized.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#note","title":"Note","text":"<p>The OAuth2 functions had been relased in free5GC v3.4.0.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#pull-requests","title":"Pull Requests","text":"<ul> <li>free5gc/NRF PR#27</li> <li>free5gc/free5gcPR#525</li> <li>There would be related Pull Request for each NF.</li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#future-work","title":"Future Work","text":"<ul> <li> <p><code>allowedNfTypes</code>: TS 29.510 Section6.1.6.2.2 Definition of type NFProfile</p> <p>When NRF verifies the scope during the AccessTokenRequest, it checks the target NF's NFProfile allowedNfTypes to determine whether the NF consumer is in the allowedNfType or not.</p> </li> <li> <p>TLS Mutual Authentication: TS 33.501 Section13.3.1 Authentication &amp; Authorization between NF and NRF</p> <p>Authentication and authorization between NF and NRF are completed if PLMN uses protection at the transport layer with mutual authentication.</p> </li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#about","title":"About","text":"<p>Hello, I am Andy Chen. I have just started making contributions to the free5GC core network. This post is my first blog, so if there are any inquiries or identification of errors within, we welcome discussion and correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#connect-with-me","title":"Connect with Me","text":"<ul> <li> <p>Linkedin: https://www.linkedin.com/in/tsung-fang-chen-437a71191/</p> </li> <li> <p>Github: https://github.com/andy89923</p> </li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#appendix","title":"Appendix","text":"<p>Additionally, I have provided the graph with a dark background.</p> <p></p>"},{"location":"blog/20231122/20231122/","title":"Nephio: a Cloud Native Network Automation Linux Foundation Project","text":"<p>Note</p> <p>Author: Brian Chen (\u9673\u715c\u76db) Date: 2023/11/08</p> <p>As a free5GC maintainer, I'm excited to see a Linux Foundation project that utilizes our open-source software. Let's explore what Nephio can do. I will briefly introduce what is Nephio and then demonstrate how to install the free5gc-operator.</p>"},{"location":"blog/20231122/20231122/#nephios-goal","title":"Nephio's Goal","text":"<p>Nephio delivers carrier-grade, simple, open, Kubernetes-based cloud native intent automation and common automation templates that materially simplify the deployment and management of multi-vendor cloud infrastructure and network functions across large-scale edge deployments. It brings zero-touch provisioning of cloud infrastructure and network functions, which can offer increased network availability and resiliency while reducing maintenance downtime.</p>"},{"location":"blog/20231122/20231122/#what-problem-does-nephio-solve","title":"What Problem Does Nephio Solve?","text":"<p>Distributed cloud technologies facilitate edge access through on-demand, API-driven mechanisms. Regrettably, prevailing imperative, fragile, and fire-and-forget orchestration techniques face challenges in fully exploiting the dynamic capabilities inherent in these innovative infrastructure platforms. To achieve success in this domain, Nephio employs novel methodologies capable of navigating the intricacies associated with provisioning and overseeing a distributed, multi-vendor, multi-site deployment of interconnected network functions within on-demand distributed cloud environments.</p> <p>The objective of the solution is to handle the initial provisioning of network functions and the underlying cloud infrastructure. Additionally, it incorporates Kubernetes-enabled reconciliation to ensure network resilience amid failures, scaling occurrences, and alterations within the distributed cloud.</p>"},{"location":"blog/20231122/20231122/#benefits-of-kubernetes-based-cloud-native-automation","title":"Benefits of Kubernetes Based Cloud Native Automation","text":"<p>It enables multi-vendor support, faster onboarding, easier lifecycle management, embedded control-loop, active reconciliation, and service assurance, reducing costs through efficiency and agility. A common cloud-based automation framework, based on well-proven Kubernetes technology, minimizes the need for custom automation solutions for each application. Multi-vendor integration is enabled, improving customer experience.</p>"},{"location":"blog/20231122/20231122/#kubernetes-as-a-uniform-automation-control-plane","title":"Kubernetes as a Uniform Automation Control Plane","text":"<p>We can broadly think of three layers in the stack:</p> <ol> <li> <p>cloud infrastructure Nephio releases Custom Resource Definitions (CRDs) and operators built on Kubernetes for automation in both public and private cloud infrastructures, aligning with industry standards like the O-RAN O2 interface. These CRDs and operators have the capability to leverage established projects within the Kubernetes ecosystem as interchangeable southbound interfaces (such as Google Config Connector, AWS Controllers for Kubernetes, and Azure Service Operator). This establishes an open integration point, ensuring a more consistent approach to automation across various service providers.</p> </li> <li> <p>workload (network function) resources It covers configuring the provisioning of network function containers and the associated requirements for nodes and network fabric. This encompasses native Kubernetes primitives and industry extensions like multi-network Pods, SR-IOV, and similar technologies. Currently, efficient utilization of these features demands intricate Infrastructure-as-Code templates tailored to specific network functions. Nephio aims to simplify this process by adopting a Configuration-as-Data approach, utilizing Kubernetes CRDs and well-structured schemas to enable robust, standards-based automation for network function configuration.</p> </li> <li> <p>workload (network function) configuration. Nephio starts by offering tools and libraries to support vendors in merging their current Yang and other industry models with Nephio, complying with standards (e.g., 01, 3GPP interface specs). To completely grasp the advantages of cloud-native automation, these models must transition to Kubernetes CRDs since these configurations are closely linked to those elucidated in (2). Nephio furnishes identical tooling across each stratum, facilitating the automation of interconnected configurations amidst these layers.</p> </li> </ol> <p></p> <p>Configuration Layers</p>"},{"location":"blog/20231122/20231122/#nephio-release-1","title":"Nephio Release 1","text":"<p>Project Nephio announced the availability of Release 1 (R1) on August, 2023.</p> <p>Nephio R1 brings revolutionary advancements in deployment, life cycle management and scaling of telecom cloud infrastructure and network functions by using Kubernetes cloud native technologies and intent-based automation.</p> <p>For more details, see Learning Nephio R1.</p> <p>Release 1 highlights:</p> <ul> <li>A framework to orchestrate cloud native network functions (CNF), infrastructure, and cross-domain lifecycle management</li> <li>Core Nephio principles and Kubernetes integration with custom resource definitions (CRDs).</li> <li>Enhanced user experience and sandbox environment.</li> </ul>"},{"location":"blog/20231122/20231122/#prove-of-concept-free5gc-operator","title":"Prove-of-Concept: free5gc-operator","text":"<p>You can refer to the PowerPoint presentations and YouTube videos they have posted to fully grasp the entire concept and architecture. Here, I attach some architectural diagrams of free5gc-operator below, but for more detailed information, I recommend watching the videos.</p> <p></p> <p>Nephio project utilizes KPT, a toolkit develop by Google, which help you manage, manipulate, customize, and apply Kubernetes Resource configuration data files. KPT supports management of Configuration as Data, which is an approach to management of configuration which</p> <ul> <li>makes configuration data the source of truth, stored separately from the live state</li> <li>uses a uniform, serializable data model to represent configuration</li> <li>separates code that acts on the configuration from the data and from packages / bundles of the data</li> <li>abstracts configuration file structure and storage from operations that act upon the configuration data; clients manipulating configuration data don't need to directly interact with storage (git, container images)</li> </ul> <p></p> <p></p>"},{"location":"blog/20231122/20231122/#what-does-nephio-free5gc-operator-do","title":"What does Nephio free5gc-operator do?","text":"<ol> <li>Reconciles {AMF,SMF,UPF}Deployment CustomResources (CRs)</li> <li>For all three NFs, they each have a Deployment and a ConfigMap Kubernetes object, and for AMF and SMF, they also have a Service resource<ul> <li>Determines resource needs based on capacity input</li> <li>Builds these K8s objects with XXXDeployment CRs fields as input</li> </ul> </li> <li>Manages dependencies<ul> <li>Ensures that the corresponding NADs exist in namespace</li> <li>Creates ConfigMap before applying Deployment</li> </ul> </li> <li>Associates objects with CR</li> <li>Updates status for XXXDeployment</li> <li>Ensures ConfigMap updates will lead to Deployment update</li> </ol>"},{"location":"blog/20231122/20231122/#environment-setup","title":"Environment Setup","text":"<p>Before cloning and launching a free5gc-operator, you need to setup an environment which matches the official demonstration. The official recommendation includes two installation methods:</p> <ul> <li>through the Google Compute Engine (GCE) to set up the environment with an account of Google Cloud Platform,</li> <li>directly preparing a Pre-Provisioned VM to set up the environment required for free5gc-operator.</li> </ul> <p>Warning</p> <p>Due to the mandatory hardware resource requirements set by the official guidelines, which include an 8-core CPU, 16 GB of memory, 200 GB disk, the resources needed are quite &gt;substantial. If you operate on the Google Cloud Native platform, you may incur significant charges on your credit card. Therefore, I recommend installing the environment on a virtual &gt;machine (VM) on your local machine for follow-on exercises.</p>"},{"location":"blog/20231122/20231122/#installation-on-pre-provisioned-vm","title":"Installation on Pre-Provisioned VM","text":"<p>After completing the Ubuntu 20.04 focal installation, you need to get a sudo passwordless permissions. Edit <code>/etc/sudoers</code>: <pre><code>$ sudo vim /etc/sudoers\n</code></pre></p> <p>Add 2 lines:</p> <pre><code>&lt;linux username&gt;   ALL=(ALL:ALL) NOPASSWD:ALL\nsudo    ALL=(ALL:ALL) NOPASSWD:ALL\n</code></pre>"},{"location":"blog/20231122/20231122/#kick-off-an-installation-on-vm","title":"Kick Off an Installation on VM:","text":"<p><pre><code>wget -O - https://raw.githubusercontent.com/nephio-project/test-infra/v1.0.1/e2e/provision/init.sh |  \\\nsudo NEPHIO_DEBUG=false   \\\n     NEPHIO_BRANCH=v1.0.1 \\\n     NEPHIO_USER=&lt;linux username&gt;   \\\n     bash\n</code></pre> The next step is to wait for Ansible to automatically set up the environment. The entire process may take approximately 10 minutes, so please be patient. Once it is completed, ssh in and port forward the port to the UI (7007) and to Gitea's HTTP interface, if desired (3000):</p> <p><pre><code>ssh &lt;user&gt;@&lt;vm-address&gt; \\\n                -L 7007:localhost:7007 \\\n                -L 3000:172.18.0.200:3000 \\\n                kubectl port-forward --namespace=nephio-webui svc/nephio-webui 7007\n</code></pre> You can now navigate to:</p> <ul> <li> <p>http://localhost:7007/config-as-data to browse the Nephio Web UI </p> </li> <li> <p>http://localhost:3000/nephio to browse the Gitea UI </p> </li> </ul>"},{"location":"blog/20231122/20231122/#free5gc-amfsmfupf-deployments-prerequisite-automatically-done-in-environment-setup","title":"free5GC AMF/SMF/UPF Deployment's Prerequisite (automatically done in environment setup)","text":"<ol> <li>Install multus</li> <li>Install CNI binary (macvlan) on all hosts that can possibly run free5gc AMF, SMF, or UPF</li> <li>Install gtp5g on nodes that could run UPF</li> <li>Install sctp on nodes that could run AMF</li> <li>Connectivity:     a. IP address allocation and reachability</li> <li>Network Attachment Definitions (NADs) for all the secondary interfaces</li> <li>3GPP related configs (PLMN, S-NSSAI info)</li> <li>free5gc SMF config requires connected UPF information</li> <li>Client (such as UERANSIM) set up with corresponding IP addresses and 3GPP info</li> </ol>"},{"location":"blog/20231122/20231122/#quick-start-exercises","title":"Quick Start Exercises","text":"<p>You can follow the tutorial steps in this page. I won't show all detail in this article. I only list the action of all steps:</p> <ul> <li>Step 1: Create the Regional cluster</li> <li>Step 2: Check the Regional cluster installation</li> <li>Step 3: Deploy two Edge clusters</li> <li>Step 4: Deploy Free5GC Control Plane Functions</li> <li>Step 5: Deploy Free5GC Operator in the Workload clusters</li> <li>Step 6: Check Free5GC Operator Deployment</li> <li>Step 7: Deploy the AMF, SMF and UPF NFs</li> <li>Step 8: Deploy UERANSIM</li> <li>Step 9: Change the Capacities of the UPF and SMF NFs</li> </ul>"},{"location":"blog/20231122/20231122/#reference","title":"Reference","text":"<ul> <li>https://nephio.org/</li> <li>https://nephio.org/about/</li> <li>https://github.com/nephio-project/docs/blob/main/install-guide/README.md#demonstration-environment-installation</li> <li>https://github.com/nephio-project/docs/blob/main/user-guide/exercises.md</li> <li>https://pkg.go.dev/github.com/GoogleContainerTools/kpt#section-readme</li> </ul>"},{"location":"blog/20231122/20231122/#about","title":"About","text":"<p>Hello everyone, I'm Brian Chen (\u9673\u715c\u76db). Currently, I am pursuing a master's degree and have been interning at Saviah for 10 months. My current role involves maintaining free5GC and reviewing issues and PR. Additionally, I am researching Kubernetes with the aim of improving the efficiency of deployment experiences for free5GC. There is still a lot of knowledge for me to acquire, so please feel free to contact me if you have any questions or would like to discuss anything.</p> <ul> <li>My GitHub</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20231129/20231129/","title":"Basic concept of RCU: Read, Copy, Update","text":"<p>Note</p> <p>Author: Lin Poyi Date: 2023/11/29</p>"},{"location":"blog/20231129/20231129/#what-is-rcu","title":"What is RCU","text":"<p>RCU is a lock-free synchronization mechanism in Linux kernel, and we use it in gtp5g. RCU is a way of making changes to data structures that are mostly read by many threads but rarely updated by a few threads. RCU stands for \u201cRead, Copy, Update\u201d, which means that the updater thread first makes a copy of the data item, modifies the copy, and then replaces the original with the copy. It works very well and has great scalability under read-heavy use cases. Compared with Reader-Writer lock (RWlock) and other lock-based approaches, RCU is a lot faster but does not provide strong consistency over data.</p> <p>In RCU, there's nothing blocking readers from entering the critical section. The reader can access the protected data at all times. Also, the updater can modify the data whenever it wants (assume only 1 updater) no matter if there are still readers using the data.</p>"},{"location":"blog/20231129/20231129/#drawbacks-of-reader-writer-lock-rwlock","title":"Drawbacks of Reader-Writer lock (RWlock)","text":"<ol> <li>It is expensive and complex to implement, especially for fine-grained locking of individual data items.</li> <li>It can cause contention and scalability issues, especially when the number of readers is large or the lock is held for a long time.</li> <li>It can introduce deadlocks and livelocks, especially when the locking order is not well-defined or the lock is nested or reentrant.</li> </ol>"},{"location":"blog/20231129/20231129/#benefits-of-rcu","title":"benefits of RCU","text":"<ol> <li>It is faster and more scalable for read-intensive workloads because the readers do not need to wait for the updaters or contend for shared resources.</li> <li>It is simpler and more reliable for avoiding deadlocks because the readers do not need to acquire any locks or follow any ordering rules.</li> <li>It is more flexible and adaptable for different scenarios because there are many variants of RCU that can handle different types of updates and readers.</li> </ol>"},{"location":"blog/20231129/20231129/#how-to-use-rcu","title":"How to use RCU","text":"<p>While using RCU, there are some rules to be followed: 1. You need to mark the sections of code where you access the RCU-protected data structures as \u201cRCU read-side critical sections\u201d, using the appropriate RCU primitives, such as rcu_read_lock() and rcu_read_unlock(). 2. You need to mark the sections of code where you modify the RCU-protected data structures as \u201cRCU update-side critical sections\u201d, using the appropriate RCU primitives, such as call_rcu() and synchronize_rcu(). 3. You need to ensure that the RCU read-side critical sections are short and do not block, switch to user mode, or enter the idle loop unless you use a special variant of RCU that allows blocking, such as SRCU or preemptible RCU. 4. You need to ensure that the RCU update-side critical sections wait for a \u201cgrace period\u201d to elapse before freeing or reusing the old versions of the data items and that the grace period is long enough that all the readers have finished accessing the old versions.</p> <p>Note</p> <p>Grace period is the time between the data being changed by the updater and the time when all readers are using the new data. During the grace period, some readers may be using the old data, some may be using the new data.</p>"},{"location":"blog/20231129/20231129/#main-rcu-apis","title":"main RCU APIs","text":"<ol> <li>rcu_read_lock(): Inform others the reader is entering the critical section, does not actually block anyone from entering the critical section.</li> <li>rcu_read_unlock(): Inform others the reader has exit critical section.</li> <li>rcu_assign_pointer(): Using this API instead of directly assign pointer with \"=\" can avoid pointer been assigned before the update_data() been done due to CPU's out-of-order execution.</li> <li>syncronize_rcu(): Wait for readers who are already in the critical section and haven't left yet. Used after updating the data and before the old data has been released.</li> <li>call_rcu(): this function is the asyncronized version of syncronize_rcu(), it will return right after it scedules a handler (clean up the old data) to be performed after all previous readers left C.S.(critical section) We use this instead of the syncronized version in gtp5g.</li> </ol>"},{"location":"blog/20231129/20231129/#pseudo-code-for-reader-and-updater","title":"pseudo code for reader and updater","text":"<p><pre><code>void Reader(){\n    rcu_read_lock();    //enter C.S. (critical section)\n    item *data = Item_A;\n    access_data(data);\n    rcu_read_unlock();  //leave C.S.\n    return;\n}\n</code></pre> <pre><code>void Updater(){\n    item *old_data = Item_A;  //save the old location\n    item *new_data = new(item);    //make a new item\n    update_data(new_data);   //modify the data in new item\n    rcu_assign_pointer(Item_A, new_data);   //now the global pointer points to the new item\n    syncronize_rcu();   //wait for all readers using old_data to leave C.S.\n    kfree(old_data);  //now we can safely release the old_data\n    return;\n}\n</code></pre> </p>"},{"location":"blog/20231129/20231129/#another-version-of-updater-with-call_rcu","title":"another version of Updater with call_rcu()","text":"<p><pre><code>void item_free(item *data){\n    kfree(data);\n    return;\n}\nvoid Updater(){\n    item *old_data = Item_A;  //save the old location\n    item *new_data = new(item);    //make a new item\n    update_data(new_data);   //modify the data in new item\n    rcu_assign_pointer(Item_A, new_data);   //now the global pointer points to the new item\n    call_rcu(old_data, item_free);   //schedule item_free(old_data) to be performed after all previous readers left C.S. and return immediately\n    return;\n}\n</code></pre> </p> <p>When the updater tries to update the data, the data doesn't get replaced instantly. The pointer will point to new data, but the old data still exists in the memory. This method prevents readers who are still accessing the old data from accessing the released memory and also allows updates before all readers leave the critical section.</p>"},{"location":"blog/20231129/20231129/#comparison-between-rcu-and-rwlock","title":"Comparison between RCU and RWlock","text":"<p>scalability of RWlock and RCU </p> <p>The graph above shows that RCU not only has better scalability with CPUs but also has better overall performance, which is not surprising when we look at the CPU utilization difference between RWlock and RCU in the graph shown below. But keep in mind that RCU does not guarantee that all readers running simultaneously have the same version of data, but RWlock does. Also if there's more than one updater, you might need some locks to prevent multiple updates been performed at the same time.</p> <p>What it might look like in the CPUs while running these two methods </p>"},{"location":"blog/20231129/20231129/#reference","title":"Reference","text":"<p>https://www.kernel.org/doc/html/next/RCU/whatisRCU.html</p> <p>https://hackmd.io/@cccccs100203/So-What-Has-RCU-Done-Lately</p> <p>Linux kernel design: RCU synchronization mechanism</p> <p>So What Has RCU Done Lately?</p>"},{"location":"blog/20231206/20231206/","title":"Introduction of IP Multimedia Subsystem Part 2","text":"<p>Note</p> <p>Author: TzuChieh Huang Date: 2023/12/06</p> <p>In the rapidly evolving landscape of telecommunications, the IP Multimedia Subsystem (IMS) stands as a linchpin for delivering advanced multimedia and voice services over IP networks. As explored in the preceding introduction (IMS Part 1), IMS serves as a standardized and open architectural framework defined by the 3rd Generation Partnership Project (3GPP). Its role in facilitating seamless communication services, including voice, video, messaging, and data, highlights its pivotal position in modern network infrastructures. Building upon the foundational knowledge established in IMS Part 1, this section will delve into the IMS registration.</p>"},{"location":"blog/20231206/20231206/#interaction-and-flow-of-registration","title":"Interaction and flow of Registration","text":""},{"location":"blog/20231206/20231206/#procedures-related-to-proxy-cscf-discovery","title":"Procedures related to Proxy-CSCF discovery","text":"<p>P-CSCF(Proxy-Call Session Control Function) is the initial point of contact for UE when establishing communication sessions. Therefore, P-CSCF discovery is a crucial step in IMS architecture. It involves the process of determining the network address of P-CSCF that the UE(User Equipment) should contact during the initiation of the communication session.</p> <p>The Proxy-CSCF discovery shall be performed using the following mechanisms:</p> <ul> <li>During the establishment of connectivity to the IP-Connectivity Access Network, provided that the IP-Connectivity Access Network supports such procedures.</li> <li>Alternatively, the P-CSCF discovery may take place after the IP connectivity has been established. To enable P-CSCF discovery after the establishment of IP connectivity, the IP-Connectivity Access Network shall provide the following P-CSCF discovery option to the UE:<ul> <li>Utilizing DHCP to furnish the UE with the domain name and/or IP address of a Proxy-CSCF, along with the address of a Domain Name Server (DNS) capable of resolving the Proxy-CSCF name</li> <li>The UE may be configured (e.g., during initial provisioning or via a 3GPP IMS Management Object (MO), or in the ISIM) to be aware of the fully qualified domain name (FQDN) of the P-CSCF or its IP address. If the domain name is known, DNS resolution is employed to obtain the IP address.</li> </ul> </li> </ul>"},{"location":"blog/20231206/20231206/#dhcpdns-procedure-for-p-cscf-discovery","title":"DHCP/DNS procedure for P-CSCF discovery","text":"<p>When DNS is employed to retrieve the IP address of the P-CSCF, the name-address resolution mechanism is permitted to take the load information of the P-CSCFs. This load information, obtained through network management procedures, is factored in when determining the address of the P-CSCF for the UE.</p> <p></p> <ol> <li> <p>Initiate the establishment of an IP-Connectivity Access Network bearer, utilizing the procedures available in the IP-Connectivity Access Network, if it is not already in place.</p> </li> <li> <p>The UE initiates a request to a DHCP server, seeking the domain name and/or IP address of the P-CSCF, along with the IP addresses of DNS servers. This may involve multiple DHCP Query/Response message exchanges to obtain the necessary information.</p> </li> <li> <p>The UE conducts a DNS query to retrieve a list of IP addresses for the P-CSCF(s), from which one is selected. If the response lacks IP addresses, an additional DNS query becomes necessary to resolve a FQDN to an IP address.</p> <ul> <li>If the UE is aware of multiple P-CSCF addresses, the selection process is determined based on the home operator's configured policy for P-CSCF selection. The policy dictates the criteria or rules according to which one P-CSCF address is chosen over others in such scenarios.</li> <li>Depending on the policy set by the home operator, the UE chooses the Home Proxy-CSCF by using a preconfigured Home P-CSCF FQDN. This selection can be made without P-CSCF discovery procedure.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#assigning-a-serving-cscf-for-a-user","title":"Assigning a Serving-CSCF for a user","text":"<p>When an UE attaches itself and becomes available for access to IMS services through explicit registration within the IMS, a S-CSCF (Serving-Call Session Control Function)shall be assigned to serve the UE. The S-CSCF plays a central role in call control and service execution for the registered UE within the IMS network.</p> <p>The assignment of a S-CSCF is carried out within the I-CSCF (Interrogating-Call Session Control Function). The selection of the S-CSCF requires the following information:</p> <ol> <li> <p>Required capabilities for user services:</p> <ul> <li>Provided by the HSS (Home Subscriber Server), this information outlines the necessary capabilities for the user's services.</li> </ul> </li> <li> <p>Operator preference on a per-user basis:</p> <ul> <li>Also provided by the HSS, this information reflects the operator's preferences specific to each user.</li> </ul> </li> <li> <p>Capabilities of individual S-CSCFs in the home network:</p> <ul> <li>This internal information within the operator's network, pertaining to the capabilities of individual S-CSCFs, may influence the S-CSCF selection.</li> </ul> </li> <li> <p>Topological (i.e. P-CSCF) information of where the user is located</p> <ul> <li>This internal information within the operator's network, concerning the topological details of the user's location, may be utilized in the S-CSCF selection process. The P-CSCF name is received in the registration request.</li> </ul> </li> <li> <p>Topological information of where the S-CSCF is located</p> <ul> <li>Another internal aspect within the operator's network, this information regarding the topological details of the S-CSCF's location may play a role in S-CSCF selection.</li> </ul> </li> <li> <p>Availability of S-CSCFs</p> <ul> <li>Internal to the operator's network, information about the availability of S-CSCFs may be considered in the S-CSCF selection process.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#registration-flow","title":"Registration Flow:","text":"<ol> <li> <p>UE to P-CSCF:</p> <ul> <li>After establishing IP connectivity, the UE, such as a mobile device, initiates IM registration by sending a SIP (Session Initiation Protocol) REGISTER request to the P-CSCF. This flow includes essential details such as the Public User Identity, Private User Identity, home network domain name, UE IP address, Instance Identifier, and GRUU (Globally Routable User Agent URI) Support Indication.</li> <li>Upon receiving the Register information flow, the P-CSCF examines the \"home domain name\" to identify the entry point to the home network, which is the I-CSCF.</li> </ul> </li> <li> <p>P-CSCF to I-CSCF:</p> <ul> <li>The P-CSCF forwards the Register information flow to the I-CSCF, including details such as the P-CSCF address/name, Public User Identity, Private User Identity, P-CSCF network identifier, and UE IP address.</li> </ul> </li> <li> <p>I-CSCF to HSS:</p> <ul> <li>The I-CSCF initiates the Cx-Query/Cx-Select-Pull information flow, sending relevant information to the HSS to perform user authentication and retrieve the user's location information. This flow includes the Public User Identity, Private User Identity, and P-CSCF network identifier.<ul> <li>The HSS verifies if the user is already registered and assesses whether the user is permitted to register in the specified P-CSCF network based on user subscription and operator limitations/restrictions.</li> </ul> </li> <li>Upon receiving Cx-Query Resp/Cx-Select-Pull Resp from the HSS, which includes the S-CSCF name or capabilities, the I-CSCF constructs a name from the capabilities, if necessary. The registration attempt is rejected if the HSS checking is unsuccessful.</li> </ul> </li> <li> <p>I-CSCF to S-CSCF:</p> <ul> <li> <p>The I-CSCF, using the S-CSCF name, determines the address of the S-CSCF through a name-address resolution mechanism. The load information of the S-CSCFs is considered in the resolution process. The I-CSCF also identifies the name of a suitable home network contact point, potentially based on information received from the HSS. The I-CSCF then sends the register information flow (P-CSCF address/name, Public User Identity, Private User Identity, P-CSCF network identifier, UE IP address) to the selected S-CSCF.</p> </li> <li> <p>The S-CSCF rejects the registration if the number of registered contact addresses for a Public User Identity exceeds the configured limit. The S-CSCF stores the P-CSCF address/name supplied by the visited network, representing the address/name that the home network uses to forward subsequent terminating session signaling to the UE. The S-CSCF stores the P-CSCF Network ID information.</p> </li> </ul> </li> <li> <p>S-CSCF to HSS:</p> <ul> <li>The S-CSCF communicates with the HSS to retrieve user profiles and perform tasks like registration and authentication.<ul> <li>The S-CSCF sends Cx-Put/Cx-Pull (Public User Identity, Private User Identity, S-CSCF name) to the HSS.</li> <li>The HSS stores the S-CSCF name for the user and returns the information flow Cx-Put Resp/Cx-Pull Resp (user information) to the S-CSCF. The user information includes one or more names/addresses that can be used to access the platforms used for service control while the user is registered. Security information may also be sent for use within the S-CSCF.</li> </ul> </li> </ul> </li> <li> <p>S-CSCF to AS (Application Server):</p> <ul> <li>The S-CSCF may interact with Application Servers for additional services.</li> </ul> </li> <li> <p>S-CSCF to TAS (Telephony Application Server):</p> <ul> <li>The S-CSCF interfaces with the TAS for services related to MMTel (MultiMedia Telephony) supplementary services.</li> </ul> </li> <li> <p>S-CSCF to MGCF (Media Gateway Control Function):</p> <ul> <li>The S-CSCF may communicate with the MGCF for signaling purposes.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#conclusion","title":"Conclusion","text":"<p>IMS registration is a fundamental process in the IMS that establishes connectivity for UE to access advanced multimedia and voice services over IP networks. The IMS operates as a standardized and open architectural framework defined by the 3GPP. Through standardized protocols, IMS ensures secure and seamless communication services, making it a crucial framework in modern telecommunications.</p>"},{"location":"blog/20231206/20231206/#reference","title":"Reference","text":"<p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20231206/20231206/#about","title":"About","text":"<p>Hello, I am TzuChieh Huang. My ongoing research focuses on VoNR (Voice over New Radio). Feel free to reach out and share any inquiries or point out errors in the article. I welcome corrections and value your feedback. Please don't hesitate to contact me via email to contribute your insights.</p>"},{"location":"blog/20231213/20231213/","title":"Article Sharing: Evaluating Dedicated Slices of Different Configurations in 5G Core","text":"<p>Note</p> <p>Author:Leon Sawada(\u6fa4\u7530\u535a\u4e45) Date: 2023/12/13</p>"},{"location":"blog/20231213/20231213/#overview","title":"Overview","text":"<p>Network slicing is a new concept born after the emergence of 5G. Network slicing and edge computing (Multi-access Edge) are both key technologies in 5G networks. Network slicing uses virtualization technology to cut the network into multiple virtual end-to-end networks, and the equipment, access, transmission, and core network between each virtual network are all independent. Dynamic demand, resource adjustment, and improved network flexibility can also reduce the construction cost of hardware resources and network construction time, and achieve hardware resource sharing. Since one of the characteristics of network slicing is its flexibility, this article verifies this very well. In this article, the author uses free5GC, ETSI NFV MANO framework, and other tools, and designs three different slices to show how different configurations of dedicated slices will affect the performance of the 5G core. Finally, discussed which slice should be used in different situations to provide the best service to users.</p>"},{"location":"blog/20231213/20231213/#nfv-mano","title":"NFV MANO","text":"<p>The management and scheduling of the core network mainly uses NFV MANO (Management and Orchestration) technology, which is an architecture proposed by the European Telecom Standards Institute (ETSI) and later adopted by 3GPP to manage 5G core network virtualization. Network function (Virtual Network Function, VNF) specification, NFV MANO allows the core network to adopt a fully virtualized VNF design and better schedule various network slicing functions. MANO of the 5G core network has the ability to manage and schedule VNFs belonging to different slices for different slice services. As shown in the figure, NFV MANO can manage and schedule VNFs of the 5G core network such as AMF, NSSF, NRF, AUSF, and PCF, SMF, UDM, UPF, etc. This will also be paired with the core network in free5GC that we will only use. As you can see: NFV Orchestrator (NFVO), VNF Management (VNFM), and Virtualized Infrastructure Managers (VIM) are three major components in the MANO architecture framework.</p> <p>*NFV Orchestrator: Responsible for supporting new network services (NS) suites and virtual network functions (VNF). Nuclear submarine life cycle management. Global resource management. Review and approve requests for Network Functions Virtualization Infrastructure (NFVI) resources.</p> <p>*VNF Manager: Controls the life cycle management of VNF instances. Performs the function of coordinating and coordinating configuration and event reporting between the NFV infrastructure (NFVI) and network element/network management systems.</p> <p>*Virtualization Infrastructure Manager (VIM): Monitors and manages NFVI compute, storage, and network resources.</p> <p> Figure 1. NFV MANO architecture</p> <p>According to the definition of 3GPP, network slices are composed of multiple network slice sub-networks such as core network, access network, and transport network. NFV MANO plays an important role in mapping each network slice network to network services.</p>"},{"location":"blog/20231213/20231213/#free5gc","title":"free5GC","text":"<p>free5GC is an open-source project for fifth-generation (5G) mobile networks. The ultimate goal of this project is to implement the 5G Core Network (5GC) defined in 3GPP Release 15 (R15) and later.</p> <p>As shown in the figure, NYCU free5GC provides all the functions of a 5G network and is divided into the control plane and the user plane. The control plan includes NSSF, NRF, UDM, PCF, NEF, AUSF, AMF, SMF, UDR, and AF. In the user plane, there is only one network function called UPF. The separation of the user plane and the control plane allows each aircraft to be deployed and evolved independently. NYCU free5GC has also modulated its functional design to make the deployment of network functions in an NFV environment more flexible and efficient.</p> <p> Figure 2. free5GC architecture</p> <p>In addition to free5GC, use MANO open source including OpenStack and Tacker. OpenStack is an open-source cloud operating system that virtualizes resources such as storage, computing, and networking. Most of these virtualized resources are deployed in the cloud as Infrastructure-as-a-service (IaaS). OpenStack provides a web-based interface dashboard. This dashboard allows us to efficiently configure, manage and monitor our virtualization resources. Tacker is an OpenStack project that provides NFVO and VNFM functionality to configure, deploy, manage, and schedule NS and VNFs on NFV infrastructure platforms such as OpenStack. The Tacker API can be used not only by NFV Orchestrator but also by OSS/BSS to deploy VNFs.</p>"},{"location":"blog/20231213/20231213/#three-different-types-of-slice","title":"Three different types of slice","text":""},{"location":"blog/20231213/20231213/#free5gc-stage-3-with-upf-dedicated-slices","title":"free5GC Stage 3 with UPF Dedicated Slices","text":"<p>The image below shows the architecture of free5GC Stage 3, each dedicated slice consisting of only UPF. It uses three dedicated slices to handle three different types of test traffic. Each dedicated slice is connected to a specific data network (DN) server. These UPFs in different dedicated slices share the same SMF in the common slice.</p> <p> Figure 3. free5GC with different configurations of dedicated slices</p> <p>Three traffic generators are provided to simulate the packets that will be sent to the 5GC by the 5G UEs and RAN. Each traffic generator will transmit two types of packets: UDP and ICMP (Internet Control Message Protocol). Each traffic generator Each traffic generator sends UDP packets at different rates: high, medium, and low. All traffic generators send both UDP packets and ICMP packets. This can estimate the throughput of UDP traffic and calculate the response time of ICMP packets. Each network cutter routes packets to a different data network (DN) server. (DN) servers so that can verify successful transmission through the selected UPF.</p> <p>Firstly, the UE will be connected to the RAN within the traffic generator. Secondly, the traffic generator transmits the NGAP Initial UE message to the AMF. This message carries the registration request and the UE information (including UE address IP, SST (Slice/Service Type), and SD (Slice Differentiator)). Thirdly, AMF requests UE authentication from AUSF. If the UE is a valid user, the AUSF accepts the request and transmits the response to the AMF. After that, the AMF transmits the UE information to the NSSF, which then provides a list of available SMFs to the AMF based on the information received. Next, AMF will select a suitable SMF for UE and create a smContext for SMF to establish a new session. Finally, the SMF will select a suitable UPF and establish a PDU (Protocol Data Unit) session between the UE and the selected UPF.</p> <p> Figure 4. Registration workflow of free5GC Stage 3</p> <p>After the registration is complete, the UE can start transmitting packets to its DN server. The transmission workflow is shown in the following figure. First, the UE sends UDP packets and ICMP packets to the UPF through its PDU session. Second, the UPF will forward these packets to a specific DN. Third, the DN will calculate the throughput of the UDP packets received from the UPF. Fourth, when the DN receives an ICMP packet, it will send the ICMP response back to the UPF. Finally, the UPF will forward this ICMP response to the UE; this will allow the UE to calculate the ICMP response time.</p> <p> Figure 5. Transmission workflow</p>"},{"location":"blog/20231213/20231213/#free5gc-stage-3-with-smfupf-dedicated-slices","title":"free5GC Stage 3 with SMF/UPF Dedicated Slices","text":"<p>The architecture of this slice is similar to the previous one, as shown in part b of the figure. Each dedicated slice is composed of SMF and UPF It also uses three dedicated slices to handle different data rate requirements, each connected to a specific DN server. All VNFs use the same resources as the previous VNF. Unlike the previous one, we move the SMF from the common slice to the dedicated slice. Each UPF connects to an SMF in the same dedicated slice and both need to share resources. The traffic generators and DN servers are the same as those used in the previous architecture. The registration workflow is also similar to Fig. 4; the only difference is that in the last step, the SMFs do not need to select the UPFs because the UPFs have already been assigned to each SMF. The SMFs only need to set up PDU sessions between the UEs and the UPFs. After the registration is completed, the transmission workflow is also the same as the previous architecture, as shown in the above figure.</p> <p> Figure 3.free5GC with different configurations of dedicated slices</p>"},{"location":"blog/20231213/20231213/#free5gc-stage-2-with-upf-dedicated-slice","title":"free5GC Stage 2 with UPF Dedicated Slice","text":"<p>The architecture of this slice, with each dedicated shard consisting only of UPFs, is the same as that shown in Figure 3 part(a). The only difference is that the VNF version in this architecture is free5GC Stage 2. VNFs in Stage 2 are less optimized than in Stage 3 The traffic generator and DN server are also the same as in free5GC Stage 3. However, the registration workflow is very different from Stage 3. This is because, in free5GC Stage 2, the NSSF is not utilized to select a dedicated and exclusive slice to serve the requesting UE. It is assumed that the UE will deliver the traffic directly to the allocated slice as shown in Fig. 6. First, the UE will connect to the RAN within the traffic generator. Second, the traffic generator will send a registration request and assign the UPF. Third, the AMF requests the UE authentication from the AUSF. If the UE is a valid user, the AUSF accepts the request and transmits the response to the AMF. Next, the AMF transmits the UE message to the SMF. Finally, the SMF locates the UPF specified by the UE and establishes a PDU session between the UE and the UPF. The transmission workflow in Stage 2 is the same as that in Stage 3, as shown in Fig. 5.</p> <p> Figure 6. Registration workflow of free5GC Stage 2</p>"},{"location":"blog/20231213/20231213/#experiment","title":"Experiment","text":"<p>There are two sumptions: 1st, all the dedicated slices are allocated with the same amount of resources, i.e., to use the same number of vCPU and the same amount of memory and storage. 2nd, all three systems under evaluation are allocated the same amount of resources. We use two identical rack servers, one for OpenStack and one for Tacker. Follow the ETSI MANO framework to build this slicing environment.</p> <p>For the first assumption, the specification of VNFs is divided into two parts:  common slice and dedicated slice. For the common slice, the specifications of all VNFs in the common slice are the same for different systems. As shown in Table 2. For the dedicated slices, we show the VNFs with different specifications in Table 3. Three traffic generators and three DN servers are configured with 2 vCPUs, 1 GB RAM, and 10 GB disks, and mirrored with Ubuntu 18.04.</p> <p> Table 1. Specification of implementation environment</p> <p> Table 2. Specification of VNF in a common slice for the first assumption</p> <p> Table 3. Specification of VNF in the dedicated slice for the first assumption</p> <p>For the second assumption, the specification of VNFs is also divided into two parts: common slices and dedicated slices. For common slices, the resource specifications of VNFs other than SMFs are the same as in Table 2. On the other hand, the resource specifications of SMFs in different configurations are shown in Table 4. Correspondingly, the resource specifications of UPFs in different configurations are shown in Table 5.</p> <p> Table 4. Specification of SMF for second assumption</p> <p> Table 5. Specification of UPF for second assumption</p>"},{"location":"blog/20231213/20231213/#result-and-conclusion","title":"Result and conclusion","text":"<p>Figures 7 and 8 show the average throughput results for three different systems at three UDP packet data rates: low (80 Mbps), medium (200 Mbps), and high (400 Mbps).</p> <p> Figure 7. Average throughput under the first assumption</p> <p> Figure 8. Average throughput under the second assumption</p> <p>Based on the graph, we can see that under the first assumption, free5GC Stage 3 with UPF-specific cuts provides higher throughput than free5GC Stage 3 with SMF/UPF-specific cuts because the former has more vCPU resources than the latter. Compared with free5GC Stage 2, the free5GC Stage 3 system is more optimized.</p> <p>Figures 9 and 10 show the average response time of the three different systems under the two assumptions. As the design of our proposed system is more complicated than that of the comparator system, the average response time becomes more modest. Under the second assumption, both systems have similar response times. However, under the first assumption, the response time of free5GC Stage 3 with UPF-specific slice is shorter because UPF has more vCPU resources.</p> <p> Figure 9. Average response time under the first assumption</p> <p> Figure 10. Average response time under the second assumption</p> <p>Figures 11 and 12 show the average CPU utilization of the two free5GC Stage 3 systems at the three data rates. Under the second assumption, there is no difference in CPU usage between the two free5GC Stage 3 systems. However, under the first assumption, the CPU usage rate is almost the same even if the number of vCPUs used in the UPF is different. However, in both assumptions, if we send more packets from the traffic generator, the CPU usage rate will be higher. This is because CPU usage depends only on the number of packets transmitted. On the other hand, the CPU usage of free5GC Stage 3 with the UPF dedicated cutter is slightly higher than that of free5GC Stage 3 with the SMF/UPF dedicated cutter, because the use of more vCPU resources results in more competitive conditions among CPUs.</p> <p> Figure 11. Average response time under the second assumption</p> <p> Figure 12. Average CPU utilization under the first assumption</p> <p>Figures 13 and Figures 14 show the average registration time in our proposed system. In free5GC Stage 3 with SMF/UPF dedicated slices, SMF does not require the choice of UPF, and thus the registration time is lower under both assumptions. Even though we provide more powerful SMF and UPF dedicated slices in free5GC Stage 3 under the second assumption, the registration process still takes longer. This is because SMF takes extra time to select UPF.</p> <p> Figure 13. Average registration time under the first assumption</p> <p> Figure 14. Average registration time under the second assumption</p> <p>Based on these results lead to the following conclusions: Under the first assumption, moving the SMF from the common slice to the dedicated slice will shorten the registration time, but it will deteriorate the performance of the UPF because fewer resources are allocated to the UPF than before. However, under the second assumption, only the registration time is affected; the performance of the UPF is not affected. This is because the functions in the control plane are no longer involved in the operation when the transfer starts. Therefore, if a large number of connections are required in a short period, moving the SMF from the common slice to the dedicated slice will be a better choice because the registration time of the system is shorter; it can handle a large number of registrations more efficiently. In addition, if users want to get better throughput and shorter response time under the first assumption, it is recommended to keep the SMF in the common slice so that more resources can be allocated to the UPF for better performance. Therefore we know we need to use different network slices based on different scenarios, which is the best proof of the convenience of network slicing.</p> <p>Network slicing is a crucial concept in 5G networks, allowing virtual network functions to form interconnected network services, with dedicated slices being evaluated to determine the best-performing configuration based on various factors. Fuchun Joseph Lin and Yu-Herng Chai described evaluating dedicated slices of different configurations in the 5G core. The text discusses the creation of a common slice and three dedicated slices in a network architecture. The performance of these systems is evaluated based on throughput, response time, CPU utilization, and registration time. The deployment of dedicated slices is experimented with using open-source projects. Moving the SMF from the common slice to the dedicated slice is recommended for handling a large number of connections efficiently. Different resource allocations to dedicated slices are also considered. The performance of the three systems is compared based on registration time, response time, throughput, resource cost, and CPU utilization. The testbed is built using the ETSI NFV MANO framework, free5GC, OpenStack, and Tacker. The goal is to evaluate the performance of different configurations of 5G core dedicated slices. The response time of free5GC Stage 3 with UPF dedicated slice is shorter under the first assumption, while a more powerful SMF in free5GC Stage 3 still takes longer during registration under the second assumption.</p>"},{"location":"blog/20231213/20231213/#about","title":"About","text":"<p>Leon Sawada</p> <p>NYCU CS Graduate student, today I introduce an article written by my professor Fuchun Joseph Lin. I hope this article could help you understand more about the attributes of different network slices.</p>"},{"location":"blog/20231213/20231213/#reference","title":"Reference","text":"<p>What Is NFV MANO -SDxCentral Studios</p> <p>free5GC Offical website</p> <p>Li, X., et al. (2017) Network Slicing for 5G: Challenges and Opportunities. IEEE Internet Computing, 21, 20-27</p> <p>V. K. Choyi, A. Abdel-Hamid, Y. Shah, S. Ferdi, and A. Brusilovsky, \"Network slice selection, assignment and routing within 5G Networks,\" 2016 IEEE Conference on Standards for Communications and Networking (CSCN), Berlin, Germany, 2016, pp. 1-7, doi: 10.1109/CSCN.2016.7784887.</p> <p>Liao, C.W., Lin, F.J. and Sato, Y. (2020) Evaluating NFV-enabled Network Slicing for 5G Core. 2020 21st Asia-Pacific Network Operations and Management Symposium (APNOMS), Daegu, Korea (South), 22-25 September 2020, 401-404.</p> <p>Chai, Y.-H. and Lin, F.J. (2021) Evaluating Dedicated Slices of Different Configurations in 5G Core. Journal of Computer and Communications, 9, 55-72</p>"},{"location":"blog/20240103/20240103/","title":"UE-initiated PLR Measurement Procedure in PMFP Procedure","text":"<p>Note</p> <p>Author: Samuel Lin Date: 2024/01/03</p>"},{"location":"blog/20240103/20240103/#introduction","title":"Introduction","text":"<p>Performance measurement function protocol (PMFP) procedures are performed between a performance measurement function (PMF) in a UE and a PMF in the UPF.</p> <p>The PMF can measure Round-Trip Time (RTT) and Packet Loss Rate (PLR) by exchanging information through PMFP messages to perform these calculations.</p> <p>In this document, we solely introduce the UE-initiated Packet Loss Rate (PLR) Measurement Procedure.</p> <p></p>"},{"location":"blog/20240103/20240103/#description","title":"Description","text":"<p>Counting start:</p> <ul> <li>[1-4] UE initiates measurement by sending a <code>PMFP PLR Count Request message</code> to the UPF. UE and UPF commence respective packet counting processes.</li> </ul> <p>Reporting and Potential Restart:</p> <ul> <li>[5, 6-2] UE sends a <code>PMFP PLR Report Request message</code> to request UPF's counted packets and may optionally request counting restart.</li> <li>[7-2, 8] UPF responds with a <code>PMFP PLR Report Response message</code> containing counted packets and potentially restarts counting if requested and accepted.</li> </ul> <p>PLR Calculation and Procedure Termination:</p> <ul> <li>[6-1, 7-1] Procedure terminates if restart is not requested or not accepted.</li> <li>[9] UE calculates the UL PLR (Uplink PLR) based on local and reported packet counts.</li> <li>[10-14] Counting can be restarted multiple times upon mutual agreement between UE and UPF, enabling continuous measurement.</li> </ul>"},{"location":"blog/20240103/20240103/#key-considerations","title":"Key Considerations","text":"<p>Message Transport: All PMFP messages are transported over the same QoS flow on the same access.</p> <p>PLR Calculation: UE derives the UL PLR using its own transmitted packet count and the UPF's reported received packet count.</p> <p>Compliance: The procedure adheres to 3GPP specifications for packet loss management.</p>"},{"location":"blog/20240103/20240103/#additional-notes","title":"Additional Notes","text":"<p>QoS Flow Selection: The specific QoS flow for message transmission is contingent upon the measurement type (default or non-default QoS rule).</p> <p>Continuous Measurement: The restart capability facilitates ongoing packet loss monitoring.</p>"},{"location":"blog/20240103/20240103/#conclusion","title":"Conclusion","text":"<p>This UE-initiated PLR measurement procedure provides a standardized and coordinated approach to assess UL packet loss within 5G networks. Its adherence to 3GPP specifications ensures interoperability and consistency across network implementations.</p> <p>Note</p> <p>The network-initiated PLR measurement procedure is to enable UPF to measure the PLR of DL traffic access to the UE through the MA PDU session. The process is the same as the UE-initiated PLR measurement, except that the objects are reversed.</p>"},{"location":"blog/20240103/20240103/#reference","title":"Reference","text":"<ul> <li>3GPP TS 24.193: 5G System; Access Traffic Steering, Switching and Splitting (ATSSS); Stage 3</li> <li>3GPP TS 23.501: System architecture for the 5G System (5GS)</li> </ul>"},{"location":"blog/20240103/20240103/#about","title":"About","text":"<p>Hello, I am Samuel Lin. I have just started making contributions to the free5GC core network. This post is my first blog, so if there are any inquiries or identification of errors within, we welcome discussion and correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20240103/20240103/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/pin-fan-lin-464201290/</li> <li>Github: https://github.com/pf-lin</li> </ul>"},{"location":"blog/20240103/20240103/#appendix","title":"Appendix","text":"<p>Additionally, I have provided the graph with the network-initiated PLR measurement procedure.</p> <p></p>"},{"location":"blog/20240110/20240110/","title":"PacketRusher: A new UE/gNB simulator and CP/UP load tester","text":"<p>Note</p> <p>Author: Michael Chien (newb1er) Date: 2024/1/10</p>"},{"location":"blog/20240110/20240110/#introduction","title":"Introduction","text":"<p>PacketRusher is an innovative open-source project developed by Hewlett Packard, drawing inspiration from my5G-RANTester and leveraging multiple libraries created by free5GC. Its primary objective is to establish automated and high-performance UE/RAN testing suites.</p> <p>In this blog, we will guide you through the setup process and some experiment results.</p>"},{"location":"blog/20240110/20240110/#quick-start","title":"Quick Start","text":""},{"location":"blog/20240110/20240110/#overview","title":"Overview","text":"<p>We are going to create two VMs here. We run free5GC core on one machine and run PacketRusher on the other.</p> <p>Here is the VM spec,</p> <ul> <li>Platform: VirtualBox</li> <li>OS: Ubuntu 20.04</li> <li>CPUs: 2</li> <li>RAM: 2048</li> </ul> <p>and the host spec,</p> <ul> <li>OS: Ubuntu 22.04</li> <li>CPU: Intel Core i5-12400</li> <li>RAM: 32GB</li> </ul>"},{"location":"blog/20240110/20240110/#free5gc-setup","title":"free5GC setup","text":"<p>You can follow the tutorials to install free5GC. Here, we will create a VM and run CP and UP on the same VM.</p>"},{"location":"blog/20240110/20240110/#packetrusher-setup","title":"PacketRusher Setup","text":"<p>They provides a very thorough installation guide on their wiki. Please follow the official instructions in case of any updates.</p> <p>We will lead you through installation that helps you get hand-on experice more quickly. First, create a new VM that runs Ubuntu 20.04. Then, follow the instruction below to install all the dependencies.</p> <pre><code>sudo apt install build-essential linux-headers-generic make git wget tar linux-modules-extra-$(uname -r)\n\nsudo rm -rf /usr/local/go\n# PacketRusher requires Go 1.20 or newer version, \n# we choose 1.21.3 as it's the latest patch version at the moment.\n# Kindly refer to the official Golang changelog should you \n# seek additional information on new features or bug fixes.\nwget https://go.dev/dl/go1.21.3.linux-amd64.tar.gz -O - | sudo tar -C /usr/local -zxvf -\necho \"export PATH=$PATH:/usr/local/go/bin\" &gt;&gt; $HOME/.profile\nsource $HOME/.profile\n</code></pre> <p>After that, we can now clone the repo and build the PacketRusher.</p> <pre><code>git clone https://github.com/HewlettPackard/PacketRusher\ncd PacketRusher\nPACKETRUSHER=$PWD\n\n# Install gtp5g kernel module\ncd $PACKETRUSHER/lib/gtp5g &amp;&amp; make clean &amp;&amp; make &amp;&amp; sudo make install\n\n# build PacketRusher binary\ncd $PACKETRUSHER &amp;&amp; go mod download &amp;&amp; go build cmd/packetrusher.go\n</code></pre>"},{"location":"blog/20240110/20240110/#packetrusher-gnbue-config","title":"PacketRusher gNB/UE config","text":"<p>All the configuration about gNodeB and UE is located in <code>$PACKETRUSHER/config/config.yml</code> file.</p> <p>Here is the example,</p> <pre><code>gnodeb:\n  controlif:\n    ip: \"192.168.56.11\"\n    port: 9487\n  dataif:\n    ip: \"192.168.56.11\"\n    port: 2152\n  plmnlist:\n    mcc: \"208\"\n    mnc: \"93\"\n    tac: \"000001\"\n    gnbid: \"000008\"\n  slicesupportlist:\n    sst: \"01\"\n    sd: \"010203\" # optional, can be removed if not used\n\nue:\n  msin: \"0000000003\"\n  key: \"8baf473f2f8fd09487cccbd7097c6862\"\n  opc: \"8e27b6af0e692e750f32667a3b14605d\"\n  amf: \"8000\"\n  sqn: \"000000000023\"\n  dnn: \"internet\"\n  routingindicator: \"0000\"\n  hplmn:\n    mcc: \"208\"\n    mnc: \"93\"\n  snssai:\n    sst: 01\n    sd: \"010203\" # optional, can be removed if not used\n  integrity:\n    nia0: false\n    nia1: false\n    nia2: true\n    nia3: false\n  ciphering:\n    nea0: true\n    nea1: false\n    nea2: true\n    nea3: false\namfif:\n  ip: \"192.168.56.10\"\n  port: 38412\nlogs:\n    level: 4\n</code></pre> <p>Feel free to customize the configuration to suit your preferences. Make sure it corresponds to your 5GC config.</p>"},{"location":"blog/20240110/20240110/#register-a-set-of-gnb-and-ue","title":"Register a set of gNB and UE","text":"<p>Now, we are ready to rock! Go ahead and runs this command,</p> <pre><code># Make sure to run PacketRusher as root\n# because it will create a gtp5g tunnel.\nsudo ./packetrusher ue\n</code></pre> <p>Now a new GTP tunnel is created and a new PDU session has established. Open another shell and ping google DNS.</p> <pre><code># You can find VRF name on the output of `./packetrusher ue`\nsudo ip vrf exec &lt;vrf_name&gt; ping 8.8.8.8\n</code></pre>"},{"location":"blog/20240110/20240110/#experiment","title":"Experiment","text":""},{"location":"blog/20240110/20240110/#multi-ue-registration-load-test","title":"Multi-UE Registration Load Test","text":""},{"location":"blog/20240110/20240110/#bandwidth-test","title":"Bandwidth Test","text":"<p>We use iperf3 to perform this test.</p> <p>iperf3 server runs on the VM-5GC.</p> <p>iperf3 client send traffic through the GTP tunnel we just created on VM-RAN/UE.</p> <p>The GTP-U tunnel traffic is forwarded by VirtualBox host-only NICs.</p> <pre><code># `iperf3 -c 192.168.56.10`\n\n[ ID]   Interval        Transfer     Bitrate         Retr\n[  6]   0.00-10.00 sec  2.17 GBytes  1.86 Gbits/sec  679             sender\n[  6]   0.00-10.00 sec  2.17 GBytes  1.86 Gbits/sec                  receive\n</code></pre>"},{"location":"blog/20240110/20240110/#about","title":"About","text":"<p>Hey there, I'm Michael! I hopped on board with the free5GC team last summer, diving into the exciting world of 5G. This is my first shot of sharing my experiences, and I'm stoked about it. Any advise or discussion are welcome!</p> <p> </p>"},{"location":"blog/20240119/20240119/","title":"Registration procedures","text":"<p>Note</p> <p>Author: Tim Lin (tim1207) Author: Donald Shih (donald1218) Date: 2024/1/19</p>"},{"location":"blog/20240119/20240119/#introduction","title":"Introduction","text":"<p>The purpose of registration procedures is to allow UEs to register for specific service access rights in 5G. They can be divided into four main type:</p> <p>1. Initial Registration is a mandatory procedure that UEs must execute when they are first powered on. After completing this procedure, the core network will allocate the corresponding resources to the UE. If the UE is in the Idle state (CM-Idle) for a long period of time, causing the core network to lose the UE Context, the UE must also initiate this procedure. 2. Mobility Registration is a procedure that UEs must initiate when they move to a new Tracking Area (TA) that is not included in the UE's TAI List. This procedure is used to update the TA information. 3. Periodic Registration is similar to the Periodic TAU in 4G. 4. Emergency Registration is a procedure that UEs can use to register for emergency services, even if they do not have a valid 5G subscription.</p>"},{"location":"blog/20240119/20240119/#registration-procedure-with-new-amf","title":"Registration Procedure with New AMF","text":""},{"location":"blog/20240119/20240119/#description","title":"Description","text":"<ul> <li> <p>[1] The UE initiates a Registration Request to the (R)AN, which includes an (R)AN message.  </p> <ul> <li>AN message has:  <ul> <li>Registration Type </li> <li>SUCI or 5G-GUTI or PEI</li> <li>Last visited TAI (if available)</li> <li>Security parameters</li> <li>Requested NSSAI</li> <li>Mapping of Requested NSSAI</li> <li>PDU Session status</li> <li>List of PDU Sessions To Be Activated</li> </ul> </li> </ul> </li> <li> <p>[2] The base station selects the AMF that will service the UE based on the GUAMI information.If the UE does not provide a GUAMI, the core network uses the Requested NSSAI to find an AMF that supports those needs.</p> </li> <li> <p>[3] Ran will send N2 Message to New AMF:</p> <ul> <li>N2 Message with :<ul> <li>N2 parameters</li> <li>Registration Request</li> <li>UE Policy Container <p>If the Registration type is Periodic Registration Update, then steps 4 to 20 may be omitted.</p> </li> </ul> </li> </ul> </li> <li> <p>[4] [Conditional] In step 4, the following actions are taken depending on the deployment status of UDSF:  </p> <ul> <li> <p>UDSF is deployed: The new AMF does not need to get data from the old AMF. Instead, the new AMF can call the Nudsf_UnstructuredDataManagement_Query service to directly retrieve the UE's SUPI and UE context from the UDSF.</p> </li> <li> <p>UDSF is not deployed: The new AMF will invoke the Namf_Communication_UEContextTransfer message provided by the old AMF, to request the UE's SUPI and UE context.</p> </li> </ul> </li> <li> <p>[5] [Conditional] </p> <ul> <li> <p>UDSF is deployed: The UDSF responds to the new AMF for the Nudsf_Unstructured_Data_Management_Query invocation with the related contexts.</p> </li> <li> <p>UDSF is not deployed: Old AMF responds to the new AMF for the Namf_Communication_UEContextTransfer invocation by including the UE's SUPI and UE Context.</p> <ul> <li>UE Context with :<ul> <li>information about established PDU Session(s)</li> <li>information about active NGAP UE-TNLA bindings to N3IWF</li> <li>information about AM Policy Association</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>[6] [Conditional] If the SUCI is not provided by the UE, and it is not retrieved from the old AMF, then the new AMF will send an Identity Request message to the UE to obtain the SUCI.</p> </li> <li> <p>[7] [Conditional] The UE uses the HPLMN-provided public key and SUPI to derive the SUCI. The UE then includes the SUCI in the Identity Response message to the new AMF.</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_1","title":"Description","text":"<ul> <li> <p>[8] UEs can initiate UE authentication by calling AUSF. In this example, the AMF will use the SUPI or SUCI to select the AUSF.</p> </li> <li> <p>[9] Authentication and Security Due to the complexity of this section of the process, it will be described in detail in another section.</p> </li> <li> <p>[10] [Conditional] If the conversion of AMF is completed, New AMF will call Namf_Communication_RegistrationCompleteNotify to notify Old AMF registration is completed.</p> <p>If the S-NSSAIs used in the old Registration Area cannot be served in the target Registration Area, the new AMF determines which PDU Session cannot be supported in the new Registration Area.The new AMF invokes the Namf_Communication_RegistrationCompleteNotify service operation to notify the old AMF.Then the new AMF modifies the PDU Session Status.  </p> <p>If new AMF received in the UE context transfer in step 2 the information about the AM Policy Association, It will inform the old AMF that the AM Policy Association in the UE context is no longer in use.</p> </li> <li> <p>[11] [Conditional] If the PEI is not provided by the UE nor obtained from Old AMF, New AMF will obtain the PEI by sending an Identity Request message to the UE to initiate the Identity Request procedure.</p> </li> <li> <p>[12] [Optional] The new AMF initiates ME identity check by invoking the N5g-eir_EquipmentIdentityCheck_Get service operation</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_2","title":"Description","text":"<ul> <li> <p>[13] If Step 14 is to be executed, New AMF will select the UDM based on the SUPI and the UDM will select a UDR Instance.</p> </li> <li> <p>[14a] If the AMF changes, or the SUPI provided by the UE is invalid, or the UE registers to the same AMF but this AMF is already registered for non-3GPP access, the new AMF is registered with the UDM using Nudm_UECM_Registration, and subscribes to be notified when the UDM deregisters this AMF, the UDM stores the AMF identity assciated to the Access Type, and the UDM can store the information in the UDR via Nudr_DM_Update.</p> </li> <li> <p>[14b] The AMF retrieves the SMF Selection Subscription data and Access and Mobility Subscription data and UE context using Nudm_SDM_Get, and the UDM retrieves that information from the UDR via Nudr_DM_Query.</p> </li> <li> <p>[14c] After receiving a successful response, AMF calls Nudm_SDM_Subscribe to subscribe to the notification when the requested data has been modified, and UDM can subscribe to the UDR via Nudr_DM_Subscribe.</p> </li> <li> <p>[14d] [Conditional] After the UDM stores the Access type information, it causes the UDM to initiate a Nudm_UECM_DeregistrationNotification to the Old AMF so that the Old AMF deletes the corresponding UE context.      </p> <ul> <li> <p>If the UDM indicates the deletion reason is Initial Registration, the old AMF will send a Nsmf_PDUSession_ReleaseSMContext message to all the SMFs associated with the UE to notify them that the UE has deregistered from the old AMF. The SMFs will then release the PDU sessions after receiving this notification.</p> </li> <li> <p>If the Old AMF has an N2 connection against that UE, the Old AMF will perform an (R)AN Release indicating that the UE has locally released the RRC Connection for the NG-RAN.</p> </li> </ul> </li> <li> <p>[14e] The Old AMF unsubscribes with the UDM for subscription data using Nudm_SDM_unsubscribe.</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_3","title":"Description","text":"<ul> <li> <p>[15] The New AMF can be contacted to the (V-)PCF using the PCF ID in the UE context received in Step 5.</p> </li> <li> <p>[16] [Optional] If the New AMF contacts (V-)PCF using the PCF ID in the UE context received in Step 5. the New AMF shall put the PCF ID(s) in the call to Npcf_AMPolicyControl Create operation.</p> </li> <li> <p>[17] [Conditional]</p> <ul> <li>Nsmf_PDUSession_UpdateSMContext The AMF invokes the Nsmf_PDUSession_UpdateSMContext in the following scenario(s):<ul> <li>If the registration request in Step 1 contains List Of PDU Sessions To Be Activated, the AMF sends an Nsmf_PDUSession_UpdateSMContext request to the SMFs associated with the PDU Session(s) to activate the User Plane connections of these PDU Session(s). </li> </ul> </li> <li>Nsmf_PDUSession_ReleaseSMContext The AMF invokes the Nsmf_PDUSession_ReleaseSMContext service operation towards the SMF in the following scenario:<ul> <li>If any PDU Session status indicates that it has been released on the UE side, the AMF will use this to notify the SMF to release the resources associated with that PDU Session.</li> </ul> </li> </ul> </li> <li> <p>[18-19] If the AMF has changed and the Old AMF indicates a pre-existing NGAP UE association to the N3IWF, the New AMF creates an NGAP UE association to the N3IWF to which the UE is already connected and automatically releases the previous NGAP UE associations of the Old AMF and the N3IWF , and N3IWF will response to AMF.</p> </li> <li> <p>[20] [Optional] If the Old AMF previously initiated a Policy Association for the PCF and the Old AMF did not transfer the PCF ID(s) to the New AMF, the Old AMF performs an AMF-initiated Policy Association Termination to remove the association with the PCF.</p> </li> <li> <p>[21] The AMF sends a Registration Accept message to the UE indicating that the registration request has been accepted. If the AMF assigns a new 5G-GUTI, it will include the 5G-GUTI.</p> </li> <li> <p>[22] [Conditional] After receiving any of [Configured NSSAI for the Serving PLMN], [Mapping Of Configured NSSAI] and Network Slicing Subscription Change Indication in Step 21, the UE sends a Registration Complete message (to confirm whether the new 5G-GUTI is allocated) to the AMF. sends a Registration Complete message (to confirm whether the new 5G-GUTI has been allocated).</p> <ul> <li>If the List Of PDU Sessions To Be Activated is not included in the Registration Request, the AMF releases the signalling connection with the UE.</li> <li>If Follow-on request is included in the Registration Request, AMF shall not release the signalling connection after completing the registration process.</li> <li>If AMF knows that there is a pending signalling in AMF or between UE and 5GC, AMF shall not release the signalling connection immediately after completing the registration process.</li> </ul> </li> <li> <p>[23] [Conditional] The AMF also uses Nudm_SDM_Info to confirm to the UDM that the UE has received and acted upon the Network Slicing Subscription Change Indication (see Step 21 and step 22).</p> <ul> <li>If the Access and Mobility Subscription data provided by the UDM to the AMF in Step 14b includes Steering of Roaming information with an indication that the UDM is requesting to receive an acknowledgement of that information from the UE, the AMF uses Nudm_SDM_Info to provide a UE acknowledgement to the UDM. AMF uses Nudm_SDM_Info to provide a UE acknowledgement to the UDM.</li> </ul> </li> <li> <p>[24] [Conditional] This step occurs after Step 14a will send Homogeneous Support of IMS Voice over PS Sessions to the UDM using Nudm_UECM_Update.  </p> <ul> <li>If the AMF has evaluated the support of IMS Voice over PS Sessions, see TS 23.501.</li> <li>If the AMF determines that it needs to update the Homogeneous Support of IMS Voice over PS Sessions, see TS 23.501.</li> </ul> </li> </ul>"},{"location":"blog/20240119/20240119/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Registration Management procedures</li> </ul>"},{"location":"blog/20240119/20240119/#about","title":"About","text":"<p>Thank you for reading.We are members of the free5GC team who joined last year. This post is our first blog.If you find any errors in the article or have any questions about the content, don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20240119/20240119/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: Donald</li> <li>Github: https://github.com/donald1218</li> <li>Linkedin: Tim</li> <li>Github: https://github.com/tim1207</li> </ul>"},{"location":"blog/20240221/20240221/","title":"Effective Network Management for Cloud-Native 5G Networks with eBPF","text":"<p>Note</p> <p>Author: LEE KUN LIN Date: 2024/02/21</p>"},{"location":"blog/20240221/20240221/#introduction","title":"Introduction","text":"<p>With the rapid development of 5G technology in recent years, the demand for high-performance networks has increased. Therefore, a new technology has emerged that decomposes traditional telecommunications network services into a group or multiple independent, reusable, and elastic microservices (lightweight network functions), called CNF (Cloud native Network Function). Currently, telecommunications operators have begun to accelerate the adoption of cloud-native technologies. In addition to valuing their self-healing capabilities, they also hope that microservice architectures can accelerate and promote the development of new network services, while also providing a high level of granularity. However, the increasing complexity of microservices begets a challenge to traditional network performance monitoring solutions. First, the rapid development of microservices makes the utilization and maintenance of tracing frameworks increasingly burdensome. Second, microservices increase the complexity of network maintenance and create more blind spots on the network level. Therefore, it is becoming increasingly important to build new low-cost tracing frameworks and increase the observability of cloud-native 5G networks. This blog article will share the framework for effective network management proposed by Abderaouf KHICHANE, a PhD candidate at Orange Labs and Universit\u00e9 Paris-Saclay, and his team.</p>"},{"location":"blog/20240221/20240221/#description","title":"Description","text":"<p>Dr. Abderaouf's Team Proposed 5GC-Observer as a Non-Intrusive Observability Framework for Cloud-Native 5G Network Services. The framework utilizes eBPF technology to observe the 5G core network and generate rich telemetry data, which can be used for real 5G end-users\u2019 QoS degradation detection. - [1, 2, 3] Dr. Abderaouf made use of a Kubernetes cluster composed of 3 nodes. As shown in the figure above, there is 1 master node as the control plane [1], and 2 worker nodes as the data plane [2, 3]. - In addition, they setup a VM having access to the Kubernetes cluster is dedicated to the simulation of UEs to ensure the E2E 5G workflow. Here is a brief explanation of the different parts of the figure above (We would not explain the components in detail. Please refer to the team's paper for more information.): Controller: It is used to discover the 5G microservices and their networks by periodically interacting with the Kubernetes API. it can also retrieve for each Kubernetes Pod belonging to the 5G network service, such as its name, the high level Kubernetes resources managing it, its network interfaces, and their IP addresses, etc. And it is communicated to the 5GC-Observer\u2019s Agent using a Kubernetes Custom Resource (CR). Agent: As shown in the figure above, the agents use the eBPF technology to monitor network traffic between 5G microservices. The agents are deployed on Kubernetes worker nodes and runs in privileged mode. And because of the utilization of eBPF, their solution is agnostic to the observed 5G core network and allows to retrieve rich telemetry data without having to know or access the source code of 5G CNFs. Log Server\uff1a They utilize \u201dGrafana Loki\u201d as a log aggregation system, allowing to collect, store and expose logs with HTTP API. Anomaly Detector\uff1a It is responsible for detecting anomalies in critical metrics stored in the Metric Server, including service level metrics (reported by the Agent) and system level metrics (reported by the Infra Exporter). They Proposed \u201cZscore\u201c as critical metrics for quantifying the distance between a point and the average of the dataset in function of the standard deviation. The formula of is as follow: </p> \u2200t, \u01b5score(m,t)=m(t)-avg(m,W)sd(m,W) <p>Where the \u201csd(m, W)\u201d is the standard deviation of metric m over a sliding time window W. Anomaly alerts would be triggered once the value of \u201cZscore\u201c is higher than a threshold \u03c7. They set W and \u03c7 to 10 minutes and 2 respectively. Their goals for the new framework are as follow: 1.Collect enough and rich telemetry data. 2.Use the acquired metrics to accurately detect anomalies.</p>"},{"location":"blog/20240221/20240221/#conclusion","title":"Conclusion","text":"<ul> <li>Dr. Abderaouf's team proposed the \"5GC-Observer\" framework and successfully used the eBPF technology to observe telemetry data generated by the 5G core network.</li> <li>In fact, the team used a chaos engineering tool that consists in simulating network delay. They also proposed a statistically-based anomaly detection solution that can efficiently detect network performance degradation, while their proposed \"5GC-Observer\" framework can effectively detect performance degradation phenomena.</li> <li>This article focuses on introducing the \"5GC-Observer\" framework, so the process of simulating network delay and detection would not be described in detail. In the future, traditional telecommunications network services will move towards being decomposed into lightweight microservices. The observation of cloud-native 5G networks will become increasingly important. Therefore, this article introduces the achievements of Dr. Abderaouf's team and uses this article to briefly discuss eBPF observation technology. We will discuss eBPF technology in more detail in the future.</li> </ul>"},{"location":"blog/20240221/20240221/#reference","title":"Reference","text":"<ul> <li>*A Khichane, I. Fajjari, N. Aitsaadi, and M. Gueroui, \u201c5GC-Observer: a Non-intrusive Observability Framework for Cloud Native 5G System\u201d in NOMS 2023-2023 IEEE/IFIP Network Operations and Management Symposium, 2023.</li> <li>*Junxian Shen, Han Zhang, Yang Xiang, et al., \u201cNetwork-Centric Distributed Tracing with DeepFlow:Troubleshooting Your Microservices in Zero Code\u201d in Proceedings of the ACM SIGCOMM 2023 Conference</li> </ul>"},{"location":"blog/20240221/20240221/#about","title":"About","text":"<p>Hi There! Thank you for reading. I am LEE KUN LIN. I joined the free5GC team last summer and have been learning and growing with the team members and all of you who love the free5GC platform. This is my first article, sharing a framework from a team in France who are passionate about developing new 5G core network technologies. I hope you would derive some benefits from the content. There may be some shortcomings or errors in my article. If you have any questions, please feel free to contact me and share your thoughts.</p>"},{"location":"blog/20240221/20240221/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: www.linkedin.com/in/kunlin-lee-53b129282/</li> <li>Github: https://github.com/KunLee76</li> </ul>"},{"location":"blog/20240327/20240327/","title":"Introduction of IP Multimedia Subsystem Part 3","text":"<p>Note</p> <p>Author: TzuChieh Huang Date: 2024/03/27</p> <p>Continuing our exploration of the IP Multimedia Subsystem (IMS), Part 1 and Part 2 have provided a comprehensive understanding of the architecture, key components, and registration processes within the IMS framework. In Part 3, we delve into the intricate procedures of IMS call handling and look toward the future developments and innovations expected within this dynamic telecommunications landscape.</p>"},{"location":"blog/20240327/20240327/#media-flow-call-procedure","title":"Media Flow / Call Procedure","text":"<p>After successful registration, the following steps will be processed when a user initiates a communication session (e.g., make a call).</p> <p></p>"},{"location":"blog/20240327/20240327/#sip-invite-and-100-trying","title":"SIP INVITE and 100 Trying","text":"<p>A SIP INVITE message aims to initiate a session between two endpoints. When a user wants to make a call, their SIP client sends an INVITE request to the SIP server, specifying the desired recipient and various parameters such as the media types (audio, video, etc.) and codecs for encoding the media.</p> <p>The 100 Trying response in the context of the SIP is an informational response indicating that the request has been received and the server is working on a response. It serves as an interim response while the server processes the INVITE request or performs other tasks related to call setup.</p> <ul> <li> <p>Caller to Orig P-CSCF</p> <ul> <li>The caller sends the SIP INVITE request, including an initial SDP, to the P-CSCF, which is determined via the CSCF discovery mechanism. </li> <li>The initial SDP may encompass one or more media streams for a multi-media session.</li> </ul> </li> <li> <p>Orig P-CSCF to Orig S-CSCF</p> <ul> <li>The originating P-CSCF knows the next hop CSCF since the UE has been registered.</li> <li>The originating P-CSCF determines whether the INVITE message needs priority treatment based on the user profile saved during registration, the priority specified by the user, and/or the MPS code/identifier contained in the INVITE message.</li> <li>If the session needs priority handling, the originating P-CSCF inserts or replaces the priority indication and forwards the INVITE to the originating S-CSCF. </li> </ul> </li> <li> <p>Orig S-CSCF to Term I-CSCF</p> <ul> <li>The originating S-CSCF validates the service profile and, if a Globally Routable User Agent URI (GRUU) is received as the contact, ensures that the Public User Identity associated with the served user in the request matches the Public User Identity linked to the GRUU, both belonging to the same service profile. </li> <li> <p>Then the originating S-CSCF triggers any origination service logic necessary for this user</p> <ul> <li>e.g., Authorization of the requested SDP based on the user's subscription for multi-media services. </li> </ul> </li> <li> <p>The originating S-CSCF analyzes the destination address, identifies the network operator the subscriber is affiliated with and forwards the SIP INVITE request. </p> </li> <li>When the INVITE message contains a priority indication, the originating S-CSCF forwards the INVITE along with the Service User's priority level if available.</li> <li>If the destination is local, the request is directed to a local I-CSCF for further processing.</li> </ul> </li> <li> <p>Term I-CSCF to Term S-CSCF</p> <ul> <li>The terminated I-CSCF forwards the INVITE request to the terminated S-CSCF.</li> <li>The S-CSCF validates the service profile and triggers any termination service logic required for this user. <ul> <li>e.g., Authorization of the requested SDP based on the user's subscription for multi-media services.</li> </ul> </li> </ul> </li> <li> <p>Term S-CSCF to Term P-CSCF</p> <ul> <li>The terminated S-CSCF knows the next hop CSCF for this UE and forwards the INVITE to the terminated P-CSCF in the visited network.</li> </ul> </li> <li> <p>Term P-CSCF to Callee</p> <ul> <li>If the terminated P-CSCF identifies that the termination is for a Multimedia Priority Service (MPS) session, it extracts the session information. It initiates dynamic policy enforcement by transmitting the derived session details to the Policy and Charging Rules Function (PCRF) or Policy Control Function (PCF). </li> <li>The terminated P-CSCF recalls (from the registration procedure) the UE address and forwards the INVITE to the UE.</li> </ul> </li> </ul>"},{"location":"blog/20240327/20240327/#180-ringing","title":"180 ringing","text":"<ul> <li>If the UE needs user input before finalizing the session setup, it may alert the user and await their response. In such cases, it notifies the originating party with a provisional response, specifically indicating \"Ringing.\" </li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the originating endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#200-ok","title":"200 OK","text":"<ul> <li>The 200 OK response indicates that the callee has accepted the call invitation and has successfully established the session. It contains essential information such as session parameters, codecs, and media descriptions for both parties to begin communication.</li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the originating endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#ack","title":"ACK","text":"<ul> <li>After receiving the 200 OK response from the callee, the caller sends an ACK message to confirm the successful reception of the acceptance. The ACK message acknowledges the receipt of the 200 OK response and finalizes the call setup process. </li> <li>It ensures that both ends of the call are synchronized and ready to proceed with the communication session.</li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the terminated endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#rtp-streams","title":"RTP Streams","text":"<ul> <li>RTP streams are designed to deliver media in real-time with minimal delay, which is essential for IMS voice and video communication. They use UDP to transport media data, providing a continuous stream of packets representing the media content. The RTP protocol also supports mechanisms for synchronizing audio and video streams, handling packet loss, and ensuring media quality during the call.</li> <li>Once the SIP handshake is complete, RTP streams are established between the caller and the callee. </li> <li>These streams carry the actual media (voice, video, etc.) over the network.</li> </ul>"},{"location":"blog/20240327/20240327/#ims-in-convergence-and-next-generation-networks","title":"IMS in Convergence and Next-Generation Networks","text":""},{"location":"blog/20240327/20240327/#integration-with-4g5g-networks","title":"Integration with 4G/5G Networks","text":""},{"location":"blog/20240327/20240327/#1-role-of-ims-in-lte-and-5g-architectures","title":"1. Role of IMS in LTE and 5G Architectures","text":"<p>In LTE and 5G networks, IMS is pivotal in enabling multimedia services over IP networks. It serves as the framework for delivering services like voice and video calls, multimedia messaging, and other IP-based communication services. </p> <p>In both LTE and 5G architectures, IMS is responsible for:</p> <ul> <li> <p>Session Control: IMS handles the setup, modification, and termination of multimedia sessions, ensuring seamless communication.</p> </li> <li> <p>Service Functionality: It hosts Application Servers (AS) that provide various services like Voice over LTE (VoLTE), Video over LTE (ViLTE), Video over New Radio (VoNR), instant messaging, presence, and more.</p> </li> <li> <p>Interoperability: IMS ensures that different types of devices (smartphones, tablets, IoT devices, etc.) can communicate effectively, regardless of the access network (Wi-Fi, cellular, etc.).</p> </li> </ul>"},{"location":"blog/20240327/20240327/#2-enhancements-for-low-latency-and-high-throughput","title":"2. Enhancements for Low Latency and High Throughput","text":"<p>In the context of 5G integration, IMS undergoes several enhancements to leverage the capabilities of the new network:</p> <ul> <li> <p>Low Latency: IMS is optimized to work with the ultra-low latency capabilities of 5G networks. This is particularly crucial for applications like real-time gaming, augmented reality (AR), virtual reality (VR), and other time-sensitive services.</p> </li> <li> <p>High Throughput: 5G networks provide significantly higher data rates than previous generations. IMS is enhanced to maximize this increased throughput, ensuring high-quality multimedia experiences.</p> </li> </ul>"},{"location":"blog/20240327/20240327/#cross-device-and-cross-network-communication","title":"Cross-device and Cross-Network Communication","text":""},{"location":"blog/20240327/20240327/#1-enabling-seamless-communication-across-various-devices-and-networks","title":"1. Enabling Seamless Communication Across Various Devices and Networks","text":"<p>IMS enables users to communicate seamlessly across various devices, regardless of their form factor or operating system. This includes smartphones, tablets, laptops, IoT devices, and more. The key components facilitating this include:</p> <ul> <li> <p>P-CSCF and S-CSCF: These elements ensure that SIP-based signaling messages can be appropriately routed to and from different devices.</p> </li> <li> <p>Application Servers (AS): AS plays a critical role in providing services that can adapt to various device capabilities, ensuring a consistent user experience.</p> </li> <li> <p>IMS Profile Management:  IMS profiles associated with a user are stored in the HSS and can be retrieved dynamically, allowing services to adapt to the device's capabilities.</p> </li> </ul>"},{"location":"blog/20240327/20240327/#2-support-for-volte-vilte-vonr-and-other-multimedia-services","title":"2. Support for VoLTE, ViLTE, VoNR, and Other Multimedia Services","text":"<p>IMS is instrumental in delivering various multimedia services over LTE and 5G networks:</p> <ul> <li> <p>VoLTE (Voice over LTE):  IMS enables high-quality voice calls over LTE networks. It ensures that voice calls are treated as data sessions, allowing simultaneous voice and data usage.</p> </li> <li> <p>ViLTE (Video over LTE):  This service extends VoLTE's capabilities to include high-definition video calling.</p> </li> <li> <p>VoNR (Voice over New Radio):  With the introduction of 5G, IMS facilitates voice calls over the new radio interface, taking advantage of 5G's enhanced capabilities.</p> </li> <li> <p>Multimedia Messaging:  IMS supports multimedia messaging services, allowing users to exchange images, videos, and other media in real time.</p> </li> </ul> <p>These services are made possible by interacting with various IMS components, including P-CSCF, I-CSCF, S-CSCF, and Application Servers, working together to establish and manage multimedia sessions.</p>"},{"location":"blog/20240327/20240327/#conclusion","title":"Conclusion","text":"<p>The IMS call flow is a sophisticated signaling and media transfer orchestration that enables seamless multimedia communication across various devices and networks. The entire process involves several network components, including P-CSCF, S-CSCF, and I-CSCF, which collaborate to support quality of service, security, and reliability. Meanwhile, the convergence of IMS with Next-Generation Networks marks a significant evolution in telecommunications, allowing for the integration of traditional telephony with modern IP-based services. This convergence promises enhanced efficiency, more decadent service offerings, and a robust platform for innovation, paving the way for a future where communication is more versatile, integrated, and ubiquitous. Together, they represent the ongoing commitment to advancing connectivity and creating a more cohesive and flexible communication ecosystem for users worldwide.</p>"},{"location":"blog/20240327/20240327/#reference","title":"Reference","text":"<p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20240327/20240327/#about","title":"About","text":"<p>Hello, I am TzuChieh Huang. My ongoing research focuses on VoNR (Voice over New Radio). Feel free to reach out and share any inquiries or point out errors in the article. I welcome corrections and value your feedback. Please do not hesitate to contact me via email to contribute your insights.</p>"},{"location":"blog/20240521/20240521/","title":"Introduction to ONOS","text":"<p>Note</p> <p>Author: HanHung Chen Date: 2024/05/21</p> <p>The way we manage networks is undergoing a revolution. Traditional, hardware-centric approaches are giving way to a software-defined future.</p>"},{"location":"blog/20240521/20240521/#traditional-network-vs-software-defined-networkingsdn","title":"Traditional Network vs. Software Defined Networking(SDN)","text":""},{"location":"blog/20240521/20240521/#traditional-network","title":"Traditional Network","text":"<ul> <li>Traditional networks typically have an integrated control and data plane and use distributed control.</li> <li>The control plane is responsible for routing and forwarding traffic.</li> <li>The data plane is responsible for transmitting traffic. </li> <li>The advantage</li> <li>Well-established and widely used: Traditional networks have been around for a long time. This means there's a vast pool of knowledge and expertise available for managing and troubleshooting them. Organizations likely already have the necessary tools and personnel in place.</li> <li>Predictable performance: Traditional networks are designed with dedicated hardware and software for specific purposes. This allows for consistent and predictable performance because the behavior of the network is well-understood.</li> <li>The disadvantage</li> <li>Less flexible: Traditional networks have a rigid, hierarchical architecture that is difficult to modify or adapt to changing business needs.</li> <li>Limited automation: Because traditional network is highly depending on hardware, it requires manual intervaention.</li> <li>Limited scalability: Traditional networks have limited scalability due to the dependence on physical hardware devices.</li> </ul>"},{"location":"blog/20240521/20240521/#sdn","title":"SDN","text":"<ul> <li>Software-defined networking (SDN) is a new network architecture that separates the control plane from the data plane. </li> <li>SDN Architecture typically consist of the following components:</li> <li>Controller: The controller is responsible for controlling the routing and forwarding of traffic across the entire network.</li> <li>Switches: Switches are responsible for transmitting traffic.</li> <li>Southbound API: The southbound API is the interface that the controller uses to control switches.</li> <li>Northbound API: The northbound API is the interface that applications use to interact with the controller.</li> <li>The advantage</li> <li>Centralized provisioning: SDN virtualizes both the data and control planes allowing the user much easier to provision physical and virtual elements. This is useful as traditional infrastructure can be challenging to monitor especially if there are many disparate systems that need to be managed individually.</li> <li>Good scalability: A good side effect of centralized provisioning is that SDN gives the user more scalability. By having the ability to provision resources at will you can change your network infrastructure at a moment\u2019s notice.</li> <li>The disadvantage</li> <li>High latency: SDN has high latency, due to both software implementation inefficiencies and interactions between switch hardware properties and the control operation workload.</li> </ul>"},{"location":"blog/20240521/20240521/#open-network-operating-system-onos","title":"Open Network Operating System (ONOS)","text":""},{"location":"blog/20240521/20240521/#what-is-onos","title":"What is ONOS ?","text":"<ul> <li> <p>Open Network Operating System (ONOS) is an open source network operating system (OS) from the Open Networking Lab (ON.Lab), which released the ONOS source code, written in Java, to the open source community in December 2014. The goal of the project is to create a software-defined networking (SDN) operating system for communications service providers that is designed for scalability, high performance and high availability.</p> </li> <li> <p>ONOS platform includes:</p> </li> <li>A platform and a set of applications that act as an extensible, modular, distributed SDN controller.</li> <li>Manages entire network (rather than a single device)</li> <li>Simplified management, configuration and deployment of software, hardware and services.</li> <li>A scale-out architecture to provide resiliency and scalability</li> <li>Required to meet the rigors of production carrier environments.</li> </ul>"},{"location":"blog/20240521/20240521/#onos-feature","title":"ONOS feature","text":"<ul> <li>Performance at Scale</li> <li>ONOS has been architected and built to provide the highest performance possible for scaled network operations. ONOS scales as needed by adding new instances when more control plane capacity is needed. capacity is needed.</li> <li>Modular Software</li> <li>Software is easier to read, test, and maintain. Most importantly, it allows more easily to customize the software.</li> <li>Northbound Abstractions</li> <li>ONOS provides northbound abstractions that simplify the creation, deployment, and operation of configuration, management and control applications.</li> <li>Southbound Abstractions</li> <li>ONOS abstracts device characteristics so that the core operating system does not have to be aware of the particular protocol being used to control or configure a device.</li> </ul>"},{"location":"blog/20240521/20240521/#onos-distributed-architecture","title":"ONOS Distributed Architecture","text":""},{"location":"blog/20240521/20240521/#distributed-core","title":"Distributed Core","text":"<ul> <li>This part is protocol-Agnostic</li> <li>Interact with Network-facing modules via a southbound (provider) API</li> <li>Interact with Applications via the northbound (consumer) API</li> </ul>"},{"location":"blog/20240521/20240521/#applicationsapps","title":"Applications(Apps)","text":"<ul> <li>Applications take and react base on the information provided by the core.</li> </ul>"},{"location":"blog/20240521/20240521/#providers-protocols","title":"Providers &amp; Protocols","text":"<ul> <li>These two parts are protocol-aware network-facing modules.</li> <li>Acquire network state information through protocol-specific means.</li> <li>Interact with the core via a southbound (provider) API.</li> </ul>"},{"location":"blog/20240521/20240521/#subsystems-of-the-core","title":"Subsystems of the Core","text":"<ul> <li>The ONOS core comprises several subsystems, each responsible for a particular aspect of network state (e.g. topology, host tracking, packet intercept, flow programming). Each subsystem maintains its \u00a0service abstraction, where its implementation is responsible for propagating the state throughout the cluster.</li> <li>Example subsystems</li> <li>Device Subsystem: Manages inventory of infrastructure devices. (Device and Port)</li> <li>Link Subsystem: Manages inventory of infrastructure links.</li> <li>Host Subsystem: Manages inventory of end-station hosts and their locations.</li> <li>Topology Subsystem: Manages time-ordered snapshots of network graph views.</li> <li>PathService: Computes/finds paths between infrastructure devices or between end-station hosts (using the most recent topology graph snapshot).</li> <li>FlowRule Subsystem: Manages inventory of match/action flow rules installed on  infrastructure devices and provides flow metrics.</li> <li>Packet Subsystem: Allows applications to listen for   data packets received from network devices and to emit data packets out onto the  network via one or more network devices.</li> <li>Driver Subsystem: Isolate device-specific code from rest of the system</li> </ul>"},{"location":"blog/20240521/20240521/#subsystem-structure","title":"Subsystem Structure","text":""},{"location":"blog/20240521/20240521/#manager","title":"Manager","text":"<ul> <li>The Manager is located in the core</li> <li>Gathers data from Providers</li> <li>Delivers information to applications and other services.</li> <li>NB Service Interface: allows applications or other core components to access specific network state information.</li> <li>NB AdminService Interface: used for receiving administrative commands and implementing them in the network state or system.</li> <li>SB ProviderRegistry Interface: enables Providers to register with the Manager, allowing interaction between Providers and the Manager.</li> <li>SB ProviderService Interface: available to registered Providers, allowing them to exchange information with the Manager.</li> </ul>"},{"location":"blog/20240521/20240521/#providers","title":"Providers","text":"<ul> <li>Providers are protocol-aware and register with the core to be recognized.</li> <li>ProviderRegistry Interface: Providers register their presence with the core.</li> <li>Provider Interface: Providers receive control commands from the core.</li> <li>using protocol-specific methods: Providers interact with network elements.</li> <li>ProviderService Interface: Providers deliver service-specific sensory data to the core.</li> </ul>"},{"location":"blog/20240521/20240521/#application","title":"Application","text":"<ul> <li>Users of the Manager's service interface</li> <li>Can obtain information in both synchronous and asynchronous manners</li> <li>Synchronous: by making queries to the service</li> <li>Asynchronous: by acting as an event listener<ul> <li>By implementing an EventListener interface to handle events</li> <li>Register events through the ListenerService interface</li> <li>The ListenerService interface is integrated into each Service interface</li> </ul> </li> </ul>"},{"location":"blog/20240521/20240521/#conclusion","title":"Conclusion","text":"<p>Combining SDN with ONOS and free5GC enables a powerful platform for experimenting with next-generation network technologies, offering enhanced flexibility and control over network management and 5G services.</p>"},{"location":"blog/20240521/20240521/#reference","title":"Reference","text":"<ul> <li>ONOS - Wikipedia</li> <li>ONOS Official Website</li> <li>ONOS Wiki</li> <li>Difference between Software Defined Network and Traditional Network </li> </ul>"},{"location":"blog/20240521/20240521/#about-me","title":"About me","text":"<p>Hi, I am Han-Hung Chen, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240521/20240521/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/HanHongChen</li> </ul>"},{"location":"blog/20240626/20240626/","title":"NTN Overview","text":"<p>Note</p> <p>Author: Samuel Lin (pflin) Date: 2024/06/26</p>"},{"location":"blog/20240626/20240626/#introduction","title":"Introduction","text":"<p>Non-Terrestrial Network (NTN) is an important component of future B5G and 6G networks. It can provide extensive coverage, enhanced connectivity for terrestrial networks, and establish the necessary satellite backhaul links to connect with the core network.</p> <p>The global organization 3GPP extends existing terrestrial mobile communications to a satellite-based non-terrestrial network architecture. The aim is to integrate satellite and terrestrial networks. In the Release 16 TR 22.822 document, 3GPP proposes three main NTN application types: Service Continuity, Service Scalability, and Service Ubiquity. These applications can provide stable and flexible network services in areas difficult for terrestrial networks to cover, such as oceans, remote areas, or conflict zones. In Release 17, 3GPP plans to incorporate NTN into the 5G cellular ecosystem, significantly accelerating the commercialization of NTN.</p>"},{"location":"blog/20240626/20240626/#ntn-architecture","title":"NTN Architecture","text":""},{"location":"blog/20240626/20240626/#transparent-mode","title":"Transparent mode","text":"<p>Initially, in Release 17, NTN primarily relies on the reception and forwarding of signals from satellites to ground receiving stations in a Transparent mode. A ground receiving station can cover an area with a radius of approximately 800 kilometers.</p> <p>Note</p> <p>Feeder links: Wireless link between <code>NTN Gateway</code> and <code>satellite</code> \"Uu\" Service links: Radio link between <code>satellite</code> and <code>mobile devices (UE)</code></p>"},{"location":"blog/20240626/20240626/#service-link-types","title":"Service Link Types","text":"<p>3GPP standards support three types of satellite service links, allowing support for any type of orbit.</p> <ul> <li>Earth-fixed: The beam continuously covers the same geographic area, remaining stationary relative to the Earth's surface. A typical example is the Global Positioning System (GPS), which uses multiple geosynchronous satellites to provide precise global positioning services.</li> <li>Quasi-Earth-fixed: In this coverage mode, the beam covers a geographic area for a specific period but shifts to cover other geographic areas over time. This method provides efficient geographic coverage for a specific time but lacks continuity.</li> <li>Earth-moving: The beam coverage moves along the Earth's surface, typically achieved by Low Earth Orbit (LEO) satellites. It is suitable for applications requiring dynamic global coverage, such as LEO satellite communication systems needing real-time updates and extensive geographic coverage.</li> </ul>"},{"location":"blog/20240626/20240626/#current-research","title":"Current Research","text":""},{"location":"blog/20240626/20240626/#constellation-routing","title":"Constellation Routing","text":"<p>Constellation routing is a routing decision method for inter-satellite communication technology (Inter-Satellite Link, ISL) used in dynamically changing but periodically predictable satellite subnetworks. Its goal is to ensure high performance and reliability in message transmission while minimizing network delay and packet loss rates.</p> <p>NTN develops ISL technology to replace submarine cables and achieve cross-regional communication. Compared to ground stations, LEO satellites have lower average latency, around 20 milliseconds, but ISL subnetworks may face challenges such as network congestion and link failures, increasing latency. Since NTN systems integrate with the 5G cellular network, which is sensitive to end-to-end delay, developing efficient, reliable, and low-complexity constellation routing solutions is a priority.</p> <p>Research focuses on developing routing algorithms that achieve minimum hop count, high reliability, and efficiency in ISL subnetworks, enhancing the overall performance and reliability of satellite communication systems.</p>"},{"location":"blog/20240626/20240626/#reference","title":"Reference","text":"<ul> <li>3GPP TR 22.822: Study on using satellite access in 5G</li> <li>3GPP TS 38.821: Solutions for NR to support Non-Terrestrial Networks (NTN)</li> <li>MediaTek Inc. (2023). MediaTek 6G Technology White Paper - Satellite and Terrestrial Network Convergence</li> </ul>"},{"location":"blog/20240626/20240626/#about","title":"About","text":"<p>Hello, I\u2019m Samuel Lin. I am currently conducting research related to NTN. If there are any inaccuracies, please feel free to let me know.</p>"},{"location":"blog/20240626/20240626/#connect-with-me","title":"Connect with Me","text":""},{"location":"blog/20240628/20240628/","title":"Introduction to 5G Quality of Service (QoS)","text":"<p>Note</p> <p>Author: Ting-Yuan Chou Date: 2024/06/28</p>"},{"location":"blog/20240628/20240628/#introduction","title":"Introduction","text":"<p>5G networks revolutionize connectivity with their ability to support high-speed data, low latency, and massive device connectivity. A key element in this innovation is Quality of Service (QoS), which ensures that diverse network demands are met with precision, whether for broadband, critical communications, or IoT. Understanding QoS is crucial for leveraging 5G\u2019s full potential in catering to varied digital needs.</p>"},{"location":"blog/20240628/20240628/#5g-qos-architecture","title":"5G QoS Architecture","text":"<p> This diagram illustrates the relationship between PDU sessions and QoS flows within a 5G network, involving the User Equipment (UE), gNodeB (gNB), and User Plane Function (UPF). Each PDU session can encompass multiple QoS flows, each tailored to a specific type of service, ensuring that different data streams receive appropriate quality of service levels based on their requirements.</p>"},{"location":"blog/20240628/20240628/#key-components","title":"Key Components","text":"<ul> <li>PDU Session - This is a logical connection between the UE and the data network, which can carry one or more QoS flows.</li> <li>QoS Flow - A QoS flow is a logical channel with specific QoS characteristics that guarantee certain service levels for the data transported within it.</li> <li>Data Radio Bearer (DRB) - This is used to transport the QoS flows between the UE and gNB.</li> <li>UP Tunnel - It represents the path that QoS flows take between the gNB and the UPF.</li> </ul>"},{"location":"blog/20240628/20240628/#explained-with-the-diagram","title":"Explained with the Diagram","text":"<ul> <li>Internet PDU Session - Includes an Internet DRB and associated QoS flow marked with QFI (QoS Flow Identifier) for internet services.</li> <li>IMS Voice PDU Session - Contains multiple DRBs for SIP, RCS, Voice, and Video services, each with its own QoS flow and QFI, such as QFI SIP for SIP services, and QFI RTP/RTCP for voice.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-flow-overview","title":"QoS Flow Overview","text":"<p>In 5G networks, QoS Flows are crucial for ensuring the quality of data transmission. According to 3GPP standards, QoS Flows are categorized into two types:</p>"},{"location":"blog/20240628/20240628/#types-of-qos-flow","title":"Types of QoS Flow","text":"<ul> <li>GBR QoS Flows - Require a guaranteed flow bit rate.</li> <li>Non-GBR QoS Flows - Do not require a guaranteed flow bit rate.</li> </ul>"},{"location":"blog/20240628/20240628/#qfi-qos-flow-identifier","title":"QFI (QoS Flow Identifier)","text":"<p>Each QoS Flow is identified by a unique QoS Flow ID (QFI), which is unique within the scope of a PDU session and visible in the GTP-U header of 5G user-plane packets. The lifecycle of a QoS Flow is managed by the SMF, including its establishment, modification, and deletion. SMF creates a default QoS Flow for each PDU session, associated with a default QoS Rule installed in the UE for mapping uplink packets.</p>"},{"location":"blog/20240628/20240628/#qos-flow-management","title":"QoS Flow Management","text":"<p>The management of QoS Flows is controlled by the SMF, including the creation, modification, and deletion of QoS Flows. Whenever any PDU session is established, the SMF creates a default Non-GBR QoS Flow associated with a default QoS Rule that allows all uplink packets to pass.</p>"},{"location":"blog/20240628/20240628/#components-of-qos-flow-instantiation","title":"Components of QoS Flow instantiation","text":"<ul> <li>QoS Profile - Can be distributed by SMF to the gNB or predefined on the gNB. Each QoS Profile contains a series of QoS parameters corresponding to a QFI.</li> <li>QoS Rule - Sent to the UE via NAS message by SMF, including a series of QoS parameters and Packet Filters.</li> <li>PDR(s) - Sent to the UPF via PFCP messages by SMF, containing rules and parameters related to QoS.</li> </ul>"},{"location":"blog/20240628/20240628/#default-qos-flow-vs-gbr-qos-flow","title":"Default QoS Flow vs GBR QoS Flow","text":"<p> The diagram illustrates the architecture of QoS Flows in a 5G network, highlighting the two main types: Default QoS Flow and GBR QoS Flow.</p> <ul> <li>Default QoS Flow (Non-Guaranteed Bit Rate, Non-GBR) </li> <li> <p>As shown by the green tunnel in the diagram, each PDU Session has a default QoS Flow, with a QFI of 102, classified as Non-GBR. This indicates that the flow does not guarantee a fixed data transfer rate. The default QoS Flow typically has the lowest priority, and all uplink or downlink data flows use this default QoS Flow when no higher priority service data flows (SDF) are matched.</p> </li> <li> <p>GBR QoS Flow (Guaranteed Bit Rate) </p> </li> <li>The pink tunnel in the diagram exemplifies a GBR QoS Flow, with a QFI of 101. This type of flow guarantees a fixed data transfer rate, suitable for applications requiring high quality of service assurance, such as voice and video calls. This GBR QoS Flow contains two SDFs, indicating that two business data flows meet this QoS Flow, enjoying the same QoS forwarding treatment.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-profile","title":"QoS Profile","text":""},{"location":"blog/20240628/20240628/#parameters-for-every-qos-flow","title":"Parameters for Every QoS Flow","text":"<ul> <li>5G QoS Identifier (5QI) - Defines the type of QoS Flow (GBR, Non-GBR, or Delay Critical GBR).</li> <li>Allocation and Retention Priority (ARP) - Priority for resource allocation and retention.</li> </ul>"},{"location":"blog/20240628/20240628/#parameters-for-non-gbr-qos-flow","title":"Parameters for Non-GBR QoS Flow","text":"<ul> <li>Reflective QoS Attribute (RQA) - Reflective QoS attribute used for dynamic adjustment of QoS settings.</li> </ul>"},{"location":"blog/20240628/20240628/#parameters-for-gbr-qos-flow","title":"Parameters for GBR QoS Flow","text":"<ul> <li>Guaranteed Flow Bit Rate (GFBR) - Guaranteed bitrate applicable to uplink and downlink.</li> <li>Maximum Flow Bit Rate (MFBR) - Maximum bitrate applicable to uplink and downlink.</li> </ul>"},{"location":"blog/20240628/20240628/#additional-important-parameters-for-gbr-qos-flow","title":"Additional important parameters for GBR QoS Flow","text":"<ul> <li>Notification Control - Controls the notifications.</li> <li>Maximum Packet Loss Rate - Maximum allowable packet loss rate for uplink and downlink.</li> </ul>"},{"location":"blog/20240628/20240628/#5qi","title":"5QI","text":"<p>In 5G networks, the 5G QoS Identifier (5QI) defines the specific Quality of Service characteristics for a QoS Flow. Below is a detailed description of the key QoS characteristics associated with different types of 5QI.</p> QoS Characteristic Description Resource Type Specifies whether the QoS Flow is GBR, Delay Critical GBR, or Non-GBR. Priority Level Indicates the priority level of the QoS Flow, which impacts the allocation and retention of resources. Packet Delay Budget (PDB) The maximum allowable delay for packets within the QoS Flow, crucial for maintaining the latency requirements. Packet Error Rate (PER) Defines the acceptable error rate for packets within the QoS Flow, ensuring data integrity. Averaging Window Applies only to GBR and Delay-critical GBR resources, determining the time period over which the guaranteed bit rates are calculated. Maximum Data Burst Volume (MDBV) Relevant only for Delay-critical GBR resources, specifies the maximum amount of data transmitted in a burst."},{"location":"blog/20240628/20240628/#qos-rule","title":"QoS Rule","text":"<p>In 5G networks, QoS Rules are crucial configurations that guide how user-plane data flows are handled. QoS Rules determine which packets should be allocated to specific QoS flows to ensure the quality of data transmission.</p> <ul> <li>Definition of QoS Rules</li> <li> <p>A QoS Rule includes the associated QoS flow's QFI (QoS Flow Identifier), a set of packet filters, and a priority. Packet filters determine which packets should be forwarded to a specific QoS flow.</p> </li> <li> <p>Configuration of QoS Rules</p> </li> <li> <p>QoS Rules can be explicitly provided to the UE during PDU session establishment or modification through signaling. They can also be pre-configured on the UE or implicitly derived through the UE's use of reflective QoS mechanisms.</p> </li> <li> <p>Default QoS Rules</p> </li> <li> <p>Each PDU session is configured with a default QoS rule, which is associated with a QoS flow. For IP or Ethernet type PDU sessions, the default QoS rule is the only packet filter set, typically configured to allow all uplink packets.</p> </li> <li> <p>Application of Packet Filters</p> </li> <li>If the UE does not find a matching QoS rule, it will discard the uplink packet. This ensures that only data meeting specific QoS criteria are sent.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-flow-mapping","title":"QoS Flow Mapping","text":"<p>QoS mapping is crucial in 5G networks, ensuring that data packets are correctly mapped to corresponding QoS flows and network resources. Here is an introduction to the process and implementation of QoS mapping:</p> <ol> <li>Process of QoS Mapping</li> <li>Role of SMF: The SMF binds SDFs to specific QoS flows based on QoS and service requirements, assigning a QFI and exporting related QoS configuration profiles for each new QoS flow.</li> <li> <p>Data Flow and QoS Flows: As shown in the diagram, UL (uplink) and DL (downlink) data packets are processed through appropriate QoS rules and mapped to corresponding QoS flows.</p> </li> <li> <p>Mapping of QoS Rules to QoS Flows</p> </li> <li>SMF to (R)AN: SMF indirectly influences resource allocation in the RAN through the coordination with the AMF, which relays necessary QoS information, including QFIs and QoS profiles, to ensure proper resource management.</li> <li> <p>SMF to UPF: SMF instructs the UPF on packet classification, bandwidth execution, and marking, including setting up DL PDR / UL PDR and providing QoS related information (such as MBR, GFBR, and MFBR).</p> </li> <li> <p>Packet Handling</p> </li> <li>Downlink Data Handling: The UPF classifies packets based on PDRs, ensuring that packets are appropriately downlinked according to their QoS needs.</li> <li> <p>Uplink Data Handling: The UE classifies and marks uplink packets according to QoS rules and uploads them through the designated QoS flows.</p> </li> <li> <p>Exception Handling</p> </li> <li>If a packet does not match a DL PDR or a QoS rule (for uplink), it will be discarded by the UPF or UE.</li> </ol>"},{"location":"blog/20240628/20240628/#how-nfs-achieve-the-qos-in-the-5g-system","title":"How NFs Achieve the QoS in the 5G System","text":""},{"location":"blog/20240628/20240628/#nfs-involved-in-qos","title":"NFs involved in QoS","text":"<ul> <li>AMF (Access and Mobility Management Function) - Located within the Control Plane, the AMF handles all control functions related to access and mobility. This includes managing UE registration and area tracking based on QoS requirements.</li> <li>SMF (Session Management Function) - A core component in the Control Plane, the SMF is responsible for session management, including the negotiation and assurance of QoS. The SMF configures user plane data flows and ensures these flows meet their required QoS.</li> <li>PCF (Policy Control Function) - The PCF provides policy rules in the Control Plane to regulate network behavior, including decisions and applications of QoS policies. It determines which QoS rules apply to specific data flows and conveys these rules to the SMF for enforcement.</li> <li>UPF (User Plane Function) - The primary component of the User Plane, the UPF handles data forwarding and processing. It enforces QoS rules received from the SMF to ensure the quality of service for different data streams. The UPF ensures that data is correctly tagged and handled within the network to meet its QoS requirements.</li> </ul>"},{"location":"blog/20240628/20240628/#interaction","title":"Interaction","text":""},{"location":"blog/20240628/20240628/#downlink-direction-upf-to-ue","title":"Downlink Direction (UPF to UE)","text":"<ul> <li>The IP flows created by application layers and received from DN are mapped to SDFs (Service Data Flow) and then to QoS flows using PDRs (Packet Detection Rules).</li> <li>The QoS flows are then carried through N3 GPRS tunnels using GTPv1-U protocol.</li> <li>The QoS flows received from N3 tunnels are then mapped by the SDAP layer in the gNB to the DRBs using the QoS profiles prepared by the SMF as well as the parameters configured by the operator.</li> </ul>"},{"location":"blog/20240628/20240628/#uplink-direction-ue-to-upf","title":"Uplink Direction (UE to UPF)","text":"<ul> <li>To map IP flows received from the application layer to QoS flows, QoS rules are prepared by SMF. </li> <li>To map the QoS flows to the DRBs, the 5G device is configured through RRC Reconfiguration or by using SDAP header in the case of Reflective QOS.</li> </ul>"},{"location":"blog/20240628/20240628/#core-network","title":"Core Network","text":"<ul> <li>When UE send PDU establishment request to AMF, SMF will get Nsmf_PDUSession_CreateSMContext from AMF, then SMF need to: </li> <li>send Npcf_SMPolicyControl_Get to PCF</li> <li>PCF respond with policy rules (PCC Rules) back to SMF via HTTP/2 protocol.</li> <li>SMF Constructs NAS-5GSM Message Based on Policy Rules:<ul> <li>The SMF constructs a NAS-5GSM message to inform the UE about the specific QoS policies that it should apply for mapping uplink (UL) packets to QoS flows and for applying QoS flow marking.</li> </ul> </li> <li>SMF Sends QoS Profiles to the AMF via N1N2MessageTransfer Request Call Flow:<ul> <li>The SMF uses the N1N2MessageTransfer to send QoS profiles to the AMF. This transfer includes not only the delivery of QoS profiles to the gNB via NGAP messages but also the transmission of NAS messages to the UE. This step aids the gNB in mapping the QoS flows to the Data Radio Bearers (DRBs) and applies QoS rule to UE.</li> </ul> </li> <li>SMF Sends PFCP Message to Instruct the UPF to Apply PDR:<ul> <li>The SMF sends a PFCP (Packet Forwarding Control Protocol) message to the UPF to guide the UPF on applying the predefined PDRs (Packet Detection Rules).</li> </ul> </li> </ul>"},{"location":"blog/20240628/20240628/#conclusion","title":"Conclusion","text":"<p>In conclusion, 5G Quality of Service (QoS) represents a cornerstone in the evolution of mobile networks, enabling a diverse array of applications to operate with the requisite service quality, ranging from high-speed data services to low-latency critical communications and massive IoT deployments. This article has explored the key functions and mechanisms through which 5G networks manage and enforce QoS, emphasizing the roles of various network functions such as the AMF, SMF, PCF, and UPF.</p> <p>We delved into the intricacies of QoS flows, illustrating how different data streams are handled within the network to ensure that each meets its specific quality requirements. The discussion on QoS flow management, including the differentiation between GBR and Non-GBR flows, highlights the adaptability and precision of 5G QoS capabilities.</p> <p>Furthermore, the process of QoS mapping and the roles of QoS rules in directing traffic within the network infrastructure were clarified. This ensures that data is not only efficiently managed but also adheres to the stringent quality standards required by modern applications.</p> <p>Overall, the effective implementation of QoS in 5G networks is fundamental to maximizing network resource utilization and enhancing user experience, establishing a robust framework for the future of telecommunications.</p>"},{"location":"blog/20240628/20240628/#reference","title":"Reference","text":"<ul> <li>TS 23.501</li> <li>TS 23.502</li> <li>TS 23.502</li> <li>TS 24.501</li> </ul>"},{"location":"blog/20240628/20240628/#about-me","title":"About me","text":"<p>Hi, I am Ting-Yuan Chou, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240628/20240628/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/TYuan0816</li> </ul>"},{"location":"blog/20240918/20240918/","title":"How L25GC+ achieved the low-latency communication","text":"<p>Note</p> <p>Author: Chun-Ting Lin Date: 2024/09/18</p>"},{"location":"blog/20240918/20240918/#introduction","title":"Introduction","text":"<p>Cloud-native applications are undergoing a rapid transformation from monolithic architectures to modular architectures, offering enhanced flexibility, modularity, and scalability. However, the decoupling of modules introduces communication overhead, particularly when multiple modules need to collaborate to accomplish a task. A prime example of this is the 5G core network, where multiple modules work together to complete the registration process of a user device. Within this collaboration, two main modes of communication exist: synchronous and asynchronous. Traditional network communication methods can lead to significant overhead between modules, including data replication and protocol processing.</p>"},{"location":"blog/20240918/20240918/#x-io","title":"X-IO","text":"<p>X-IO is implemented using shared memory processing and unlocked producer/consumer rings between callers on the same nodes as the \"X-IO stack\". This approach is a much simpler alternative to kernel network stacking, enabling zero-copy packet transfers and providing a substantial improvement in data plane performance.</p>"},{"location":"blog/20240918/20240918/#unlocked-shared-memory-communication","title":"Unlocked Shared Memory Communication","text":"<p>Two key elements are required to support shared memory communication: - Shared memory buffer pool - Packet descriptor delivery mechanism The shared memory pool provides a shareable backend to store the payload for module access. Packet descriptor delivery delivers pointers to payloads in shared memory between different modules, rather than moving payloads.</p> <p></p>"},{"location":"blog/20240918/20240918/#shared-memory-pools","title":"Shared Memory Pools","text":"<p>X-IO utilizes the X-IO Manager to manage the initialization of shared memory pools. These pools contain a specific number of shared memory buffers. The X-IO Manager runs as the DPDK master process, which grants it the privilege to create memory pools in the Linux file system.</p>"},{"location":"blog/20240918/20240918/#unlocked-packet-descriptor-transfer","title":"Unlocked Packet Descriptor Transfer","text":"<p>To efficiently transfer packet descriptors between caller' X-IO stacks, X-IO utilizes DPDK's RTE RING as a high-speed IPC channel. To minimize latency and overhead, X-IO implements a non-locked producer/consumer ring design. Each X-IO stack has a pair of RTE RINGs for receiving and transmitting, which are shared with the XIO manager. This eliminates the need for locks and allows the X-IO Manager to facilitate descriptor transfer between different X-IO stacks.</p>"},{"location":"blog/20240918/20240918/#raw-io-primitives-in-x-io-zero-copy-interfaces","title":"Raw I/O primitives in X-IO: zero-copy interfaces","text":"<p>X-IO offers raw I/O primitives that enable zero-copy communication between caller. These primitives are implemented using DPDK's RTE RING and Mempool APIs.</p> <p> The image demonstrates zero-copy and shared memory communication in X-IO using the original I/O primitive. It involves the source module writing the payload to a memory buffer and adding the descriptor to the caller's TX ring. The X-IO manager retrieves these descriptors from the caller's TX ring, parses the routing information, and places the descriptors into the target module's RX ring. This design eliminates message duplication, reduces overhead, and improves efficiency compared to core-based networks.</p> <p>X-IO provides a high-performance interface for 5GC functions, utilizing lock-free shared memory processing. This improves the performance of the control plane, especially in achieving low latency.</p> <p>L25GC+ is a 3GPP-compliant, modified 5GC designed for low-latency control plane operations, utilizing X-IO technology. Compared to the existing core-based SBI in free5GC, X-IO provides a superior, high-performance interface between 5GC functionalities and the underlying unlocked shared memory processing.</p> <p>3GPP-compliant commercial testbed - UEs: laptops with 5G dongles (from Apal) - RU: from Alpha Networks Inc. - CU/DU: from AEWIN Technologies - UE Registration &amp; PDU Session</p> <p>Here are the improvements of L25GC+ with a commercial testbed: - Contribution to latency by the 5GC: L25GC+ demonstrates 1.5\u00d7 lower \"CN\" (Core Network) latency for a single UE and 1.3\u00d7 lower \"CN\" latency for 5 UEs during UE registration. - PDU session establishment: L25GC+ achieves 2\u00d7 lower \"CN\" latency for a single UE and 1.6\u00d7 lower \"CN\" latency for 5 UEs. </p>"},{"location":"blog/20240918/20240918/#reference","title":"Reference","text":"<ul> <li>Yu-Sheng Liu, Shixiong Qi, Po-Yi Lin, Han-Sing Tsai, K. K. Ramakrishnan, Jyh-Cheng Chen, \u201cL25GC+ is an improved, 3GPP-compliant 5GC designed for low-latency control plane operations\u201d in 2023 IEEE 12th International Conference on Cloud Networking</li> <li>Shixiong Qi, Han-Sing Tsai, Yu-Sheng Liu, K. K. Ramakrishnan, Jyh-Cheng Chen, \u201cX-IO: A High-performance Unified I/O Interface using Lock-free Shared Memory Processing\u201d in 2023 IEEE 9th International Conference on Network Softwarization</li> <li>Vivek Jain, Hao-Tse Chu, Shixiong Qi, et al., \u201cL25GC: a low latency 5G core network based on high-performance NFV platforms\u201d in Proceedings of the ACM SIGCOMM 2023 Conference</li> </ul>"},{"location":"blog/20240918/20240918/#about","title":"About","text":"<p>Hi, I am Chun-Ting Lin, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240918/20240918/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: www.linkedin.com/in/tim-lin-a285bb282/</li> <li>GitHub: https://github.com/tim1207</li> </ul>"},{"location":"blog/20241108/20241108/","title":"Modeling Digital Twins in 5G Networks: A Glimpse into the Future of Intelligent Network Management","text":"<p>Note</p> <p>Author: Yu-Chun Wang Date: 2024/11/08</p> <p>In the ever-evolving landscape of 5G, digital twins are emerging as one of the most promising innovations. By creating a virtual model of physical network components, digital twins in 5G enable real-time monitoring, predictive maintenance, and proactive management. For network providers, this shift promises a powerful way to optimize resource allocation and performance, handle dynamic data traffic demands, and unlock a new level of efficiency. Here\u2019s a look at how digital twin modeling works, its applications in 5G network, and how it\u2019s transforming network management.</p>"},{"location":"blog/20241108/20241108/#what-is-a-digital-twin","title":"What is a Digital Twin?","text":"<p>A digital twin is a virtual model of a physical object, process, or system that uses real-time data to mirror its real-world counterpart. Originally developed in the manufacturing and industrial sectors, digital twins have since expanded into a wide range of fields, including healthcare, urban planning, and telecommunications. By continuously updating with data from sensors, devices, and network infrastructure, digital twins offer a detailed, dynamic representation of physical assets and systems. This environment allows for rapid analysis and supports real-time decision-making with precise, data-driven insights.</p> <p></p>"},{"location":"blog/20241108/20241108/#an-overview-for-network-digital-twin-modeling","title":"An overview for Network Digital Twin Modeling","text":"<p>As 5G technology continues to transform network capabilities, digital twin technology has emerged as a cornerstone for managing these complex, high-performance networks. The research paper \"Digital Twins for 5G Networks: A Modeling and Deployment Methodology\" by Rodrigo et al. [1] offers a detailed framework that guides the development of digital twins in 5G environments, enabling real-time monitoring, predictive analytics, and adaptive management across network elements.</p>"},{"location":"blog/20241108/20241108/#the-building-blocks-of-a-network-digital-twin-model","title":"The Building Blocks of a Network Digital Twin Model","text":"<p>Creating an effective digital twin for 5G involves integrating real-time data, predictive AI models, and secure communications to form a comprehensive, continuously updating network representation. Rodrigo et al. [1] outline a seven-phase methodology to establish a digital twin model that aligns with NFV (Network Function Virtualization) standards, ensuring interoperability and efficient performance in complex 5G ecosystems. Here is a breakdown of these phases:</p> <p></p> <ol> <li> <p>Data Acquisition: This phase begins with collecting data from physical network components, including topologies, hardware configurations, and performance metrics. Automated agents gather this information to form the foundation of the digital twin.</p> </li> <li> <p>Modeling: Using the acquired data, the network\u2019s structure and behavior are modeled. This phase simplifies the network\u2019s complexity to enable efficient and realistic simulations.</p> </li> <li> <p>Adaptation: The digital model is then adapted to fit virtualization standards, transforming data to compatible templates. This ensures it can be integrated seamlessly with Network Function Virtualization (NFV) systems.</p> </li> <li> <p>NFV Deployment: In this phase, the adapted digital model is deployed on an NFV platform, utilizing software such as OpenStack or Kubernetes to host and manage the virtual elements of the network.</p> </li> <li> <p>Provisioning: This step customizes the virtual network by aligning it with specific operational characteristics of the physical network. Tools like Ansible automate deployment, ensuring the digital twin operates similarly to its physical counterpart.</p> </li> <li> <p>Interconnection: Secure, real-time communication between the digital twin and its physical network is established, enabling the two to synchronize and share data. Messaging protocols like MQTT and Kafka are used to support continuous information flow.</p> </li> <li> <p>Feedback Loop: In the final phase, a feedback loop is created, allowing the digital and physical networks to communicate constantly. This supports real-time monitoring, predictive maintenance, and dynamic adjustments for optimal performance\u200b.</p> </li> </ol>"},{"location":"blog/20241108/20241108/#challenges-of-digital-twin-modeling-in-5g-network","title":"Challenges of Digital Twin Modeling in 5G Network","text":"<p>Creating and deploying digital twins in 5G networks is no small feat. Some of the challenges include:</p> <ul> <li> <p>High Data Processing Requirements: Digital twins require massive data streams to accurately reflect the state of network functions. This means that 5G networks need powerful processing capabilities and efficient data management strategies to support the continuous operation of digital twins.</p> </li> <li> <p>Data Privacy and Security: With vast amounts of data flowing between physical network functions and their digital counterparts, maintaining robust security protocols is crucial to prevent data breaches and unauthorized access.</p> </li> <li> <p>Computational Load: Running real-time digital twin models can require significant computational resources.</p> </li> </ul>"},{"location":"blog/20241108/20241108/#the-future-of-digital-twins-in-5g-and-beyond","title":"The Future of Digital Twins in 5G and Beyond","text":"<p>As 5G advances and the next generation of networks\u20146G\u2014emerges, digital twin technology will likely expand to support applications such as autonomous vehicles, augmented reality, and the industrial Internet of Things (IoT). With advances in AI and machine learning, digital twins will become more predictive and adaptive, enabling smarter decision-making in network management. Additionally, with the anticipated rollout of 6G, digital twins will play a pivotal role in managing an even more complex network ecosystem.</p>"},{"location":"blog/20241108/20241108/#conclusion","title":"Conclusion","text":"<p>Modeling digital twins in 5G represents a critical leap towards intelligent, proactive network management. As Rodrigo et al. [1] illustrate, these virtual models allow for unprecedented levels of control, visibility, and agility, transforming network operations. As 5G networks evolve and demand for efficient management grows, digital twin technology will be essential for network operators, ensuring they remain at the forefront of telecommunications innovation.</p>"},{"location":"blog/20241108/20241108/#reference","title":"Reference","text":"<p>[1] M. Sanz Rodrigo, D. Rivera, J. I. Moreno, M. \u00c0lvarez-Campana and D. R. L\u00f3pez, \"Digital Twins for 5G Networks: A Modeling and Deployment Methodology,\" in IEEE Access, vol. 11, pp. 38112-38126, 2023, doi: 10.1109/ACCESS.2023.3267548. [2] A. Fuller, Z. Fan, C. Day and C. Barlow, \"Digital Twin: Enabling Technologies, Challenges and Open Research,\" in IEEE Access, vol. 8, pp. 108952-108971, 2020, doi: 10.1109/ACCESS.2020.2998358.</p>"},{"location":"blog/20241108/20241108/#about","title":"About","text":"<p>Hi, I'm Yu-Chun! As a newcomer to 5G and the free5GC community, I'm diving into innovative 5G applications and tackling TNGF-related issues. My focus is on digital twin applications within the 5G space, where I\u2019m passionate about pushing network capabilities to new levels.</p>"},{"location":"blog/20241108/20241108/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/blackcat-118</li> </ul>"},{"location":"blog/20241113/20241113/","title":"Mapping PCC Rules into Session Rules: Policy Application in 5G Networks","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2024/11/13</p>"},{"location":"blog/20241113/20241113/#roles-of-pcc-rules-and-session-rules","title":"Roles of PCC Rules and Session Rules","text":"<p>In 5G networks, managing service quality for diverse applications is critical to providing users with a consistent experience. PCC, which stands for Policy and Charging Control, rules play a central role in regulating traffic flows, enforcing quality standards, and adapting network resources according to real-time conditions.</p> <p>Session Rules serve as the operational framework for implementing PCC decisions at the user session level. They are responsible for managing session establishment, maintenance, and termination while ensuring proper resource allocation and QoS enforcement. These rules translate high-level policy decisions into concrete network behaviors, coordinating between different network functions to maintain service quality and optimize resource utilization throughout the session lifecycle.</p>"},{"location":"blog/20241113/20241113/#abstract-of-network-functions","title":"Abstract of Network Functions","text":"<ul> <li>PCF(Policy Control Function): The PCF is responsible for generating PCC rules based on the service requirements and network conditions.</li> <li>SMF(Session Management Function): The SMF is responsible for translating PCC rules received from the PCF into actionable configurations on the user plane.</li> <li>UPF(User Plane Function): The UPF enforces the PDRs based on the rules set by SMF.</li> <li>UE(User Equipment): The UE is the terminal equipment that connects to the network and communicates with the core network.</li> </ul>"},{"location":"blog/20241113/20241113/#process-of-mapping-pcc-rules-into-session-rules","title":"Process of Mapping PCC Rules into Session Rules","text":"<ul> <li> <p>PCF transmits PCC rules to SMF.</p> <ul> <li>PCF transmits SmPolicyDecision to SMF, which contains:<ul> <li>PCC rules: PCC rules specify how traffic should be handled based on various conditions, including data volume, priority, and the quality of service (QoS) requirements.</li> <li>QoS decision: The Quality of Service (QoS) decision specifies the level of service quality that should be applied to a particular network session. This includes parameters like latency, data rate, and packet loss, which collectively determine how reliably and quickly data is transmitted.</li> <li>Flow control decision: Flow control decisions determine how network traffic is regulated to prevent congestion, ensuring a smooth flow of data. It is essential to maintaining overall network stability and user experience.</li> <li>Charging decision: The charging decision outlines how usage fees are calculated for the services consumed by the user. It specifies which traffic should be charged and under what conditions, as well as the applicable rates.</li> </ul> </li> </ul> </li> <li> <p>SMF processes PCC rules.</p> <ul> <li>After receiving the SmPolicyDecision, SMF will use <code>ApplyPccRules()</code> to translate PCC rules into session rules.</li> <li>It includes three main steps:<ul> <li>Create or update the data path for each PCC rule.</li> <li>Process relative QoS, flow control, and charging rules' parameters.</li> </ul> </li> </ul> </li> <li> <p>Data path establishment.</p> <ul> <li>In the beginning of <code>CreatePccRuleDataPath()</code>, it will get routing position message from tcData(i.e., traffic control data), including DNAI(i.e., data network access identifier).</li> <li>Next, SMF will configure the UPF selection parameters which contains DNN, network slice and DNAI information and use these parameters to create the user plane data path.</li> <li>Then, check whether it is no default path and PCC priority is 255, if so, it will set this path as the default data path.</li> <li>Also, it will set if this flow is GBR(i.e., guaranteed bit rate) flow or not, as well as activate the tunnel and PDR according to the priority.</li> <li>Before returning, it will setup the PCC parameters, add charging rule(including <code>chgLevel</code> and <code>chgData</code>) and configure the QoS(including <code>QFI</code> and <code>qosData</code>) for later use.</li> </ul> </li> <li> <p>QoS configuration.</p> <ul> <li>In this step, SMF will assign a unique QFI via <code>AssignQFI()</code> to each PCC rule and use this QFI to configure the QoS flow and data path according to the QoS data.</li> <li>In <code>AddQoS()</code>, it is designed to add Quality of Service (QoS) configurations for a given session, based on the QoS parameters and a specific QoS Flow Identifier (QFI). Here\u2019s a breakdown of what this function does:<ul> <li>Default QFI check: If the QoS parameter is nil and the QFI is not 1 (which is treated as the default QFI), the function will return immediately, implying that no additional QoS setup is required for non-default QFIs when QoS is missing.</li> <li>Iterate Over Data Path Nodes: The function iterates through each data path node, starting from <code>FirstDPNode</code> and moving through each node in sequence.</li> <li>QER(QoS Enforcement Rule) Management: For each node, it fetches the UUID of the UPF (User Plane Function) node and creates a unique QoS ID based on the UUID and qfi. If a QER entry does not already exist for the given QoS ID in the session context (<code>smContext.QerUpfMap</code>), a new QER is created and configured.</li> <li>QER Setup: The QER includes the QFI value and opens both uplink and downlink gates to allow traffic in both directions.</li> <li>QER Linking: Once the QER is configured, the function links it to the PDRs (Packet Detection Rules) in the uplink and downlink tunnels of the node, if they exist. This ensures that the QER settings are applied to data packets as they traverse the UPF.</li> </ul> </li> </ul> </li> <li> <p>Flow control setup.</p> <ul> <li>In <code>ActivateTunnelAndPDR()</code>, we will use tunnel and PDR to setup the flow forward rule through these steps:<ul> <li>Activating Tunnels: It iterates through all DP Nodes(Data Path Nodes) in the given DataPath and activates both uplink and downlink tunnels for each node.</li> <li>Setting Up URR (Optional): Depending on the configuration in <code>smContext</code>, it may add a URR(Usage Reporting Rule) to monitor traffic and usage on the data path.</li> <li>Activating PDR: It then configures PDRs for each DP Node. For each node, the function:</li> <li>Sets up QERs for managing data rates.</li> <li>Configures FARs(Forwarding Action Rules) for traffic forwarding, including outer header creation where necessary.</li> <li>Configures Uplink and Downlink PDRs: For each DP Node, it establishes the uplink and downlink PDRs, defining parameters such as interface information, IP addresses, and header removal options.</li> </ul> </li> </ul> </li> <li> <p>Charging rule generation.</p> <ul> <li>Before we add the actual charging rule, we need to call <code>IdentifyChargingLevel()</code> to identify the charging level is PDU session level or flow level. Then, we will add charging rule via <code>AddChargingRules()</code>:<ul> <li>Iterating through DP Nodes: For each node in the DataPath, if the node is an anchor UPF, the function proceeds with setting up charging rules.</li> <li>Charging Info and URR ID Allocation:<ul> <li>Creates a ChargingInfo structure containing the rating group, charging level, and UPF ID.</li> <li>Allocates a unique URR ID using UrrIDGenerator. If this allocation fails, an error is logged and the function returns.</li> </ul> </li> <li>URR Setup:<ul> <li>It builds an ID key to map this URR to the UPF node.</li> <li>Checks if the URR already exists in smContext.UrrUpfMap:<ul> <li>Online Charging:<ul> <li>Creates a URR with a start trigger to detect the beginning of the Service Data Flow (SDF).</li> <li>Sets the ChargingMethod to ONLINE_CHARGING.</li> </ul> </li> <li>Offline Charging:<ul> <li>Configures URR reporting based on a volume threshold (e.g., data usage).</li> <li>Sets the ChargingMethod to OFFLINE_CHARGING.</li> </ul> </li> </ul> </li> <li>If the URR is new, it is added to smContext.UrrUpfMap.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Session rule generation.</p> <ul> <li>After finishing the above steps, SMF will generate the session rule by calling <code>ApplySessiongRules()</code>.</li> </ul> </li> </ul>"},{"location":"blog/20241113/20241113/#conclusion","title":"Conclusion","text":"<p>The mapping of PCC rules into session rules is a critical process in 5G networks, ensuring that high-level policy decisions are effectively translated into concrete network behaviors. This process involves collaboration between the PCF, SMF, UPF, and UE, coordinating between different network functions to maintain service quality and optimize resource utilization throughout the session lifecycle.</p>"},{"location":"blog/20241113/20241113/#reference","title":"Reference","text":"<ul> <li>TS 23.502</li> <li>TS 23.503</li> <li>TechSpec 23.501 5.7 QoS Model</li> <li>Introduction to 5G Quality of Service (QoS)</li> <li>\u6838\u5fc3\u7db2\u8def\u7684\u7b56\u7565\u8207\u8a08\u8cbb</li> </ul>"},{"location":"blog/20241113/20241113/#about","title":"About","text":"<p>Hello, I'm Alonza. This autumn, I\u2019m excited to be joining the free5GC project with a lot of enthusiasm. I look forward to diving into the technical aspects of the 5G core network and growing my expertise in this cutting-edge field. My goal is to learn alongside the team, contribute meaningfully, and help advance the development of 5G technology together.</p>"},{"location":"blog/20241113/20241113/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/Alonza0314</li> <li>Website: Alonza0314</li> </ul>"},{"location":"blog/20241127/20241127/","title":"NWDAF introduction","text":"<p>Note</p> <p>Author: Liu Hsiang Kuan Date: 2024/11/27</p>"},{"location":"blog/20241127/20241127/#roles-of-nwdaf","title":"Roles of NWDAF","text":"<ul> <li>The Network Data Analytics Function (NWDAF) is a key component of the 5G core network responsible for collecting and analyzing network data to provide insights and predictions for network optimization and management. Think of it as the \"brain\" of the 5G network that helps make intelligent decisions based on data analysis. </li> </ul>"},{"location":"blog/20241127/20241127/#analytics-mechanisms","title":"Analytics Mechanisms","text":"<ul> <li>NWDAF operates through three main functional aspects that work together to deliver network analytics:</li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-data-collection","title":"1. Data Collection","text":""},{"location":"blog/20241127/20241127/#mechanisms","title":"Mechanisms","text":"<p>The NWDAF begins its operation by gathering data from various sources within the 5G network. Imagine this as a network monitoring system that:</p> <ul> <li>Collects real-time performance data from network functions</li> <li>Gathers historical data for trend analysis</li> <li>Coordinates data collection to avoid redundancy</li> </ul>"},{"location":"blog/20241127/20241127/#execute-architecture","title":"Execute architecture","text":"<ul> <li> <p>Basic Collection Through Nnf Interface     The NWDAF's data collection process starts with its basic interface - Nnf, which allows NWDAF to collect data from various Network Functions (NFs) in the 5G core network. Through this interface, NWDAF can subscribe to the data it needs, such as network performance metrics, user behavior data, or service quality indicators.</p> <p></p> </li> <li> <p>Enhanced Collection with DCCF     To improve the efficiency of data collection, DCCF acts as a central coordinator between data sources and NWDAF. Think of DCCF as a smart traffic controller - when multiple NWDAFs need the same data from an NF, instead of each NWDAF making separate requests, DCCF manages these requests centrally. It collects the data once and distributes it to all interested NWDAFs, significantly reducing the network's signaling load. </p> </li> <li> <p>Management Data Through OAM     For network management information, NWDAF also connects to the Operation, Administration and Maintenance (OAM) system. This connection provides NWDAF with essential network configuration and management data, helping it understand the broader context of network operations.</p> </li> </ul>"},{"location":"blog/20241127/20241127/#2-analytics-processing","title":"2. Analytics Processing","text":""},{"location":"blog/20241127/20241127/#mechanisms_1","title":"Mechanisms","text":"<ul> <li>At the heart of NWDAF lies its analytics capabilities:</li> <li>Uses advanced algorithms to process network data</li> <li>Employs AI/ML models for predictive analytics</li> <li>Supports distributed learning across multiple NWDAF instances</li> <li>Manages and updates analytics models</li> </ul>"},{"location":"blog/20241127/20241127/#execute-architecture_1","title":"Execute Architecture","text":"<ul> <li>Analytics Processing with AnLF &amp; MTLF<ul> <li>AnLF: processes the incoming data streams and generates real-time insights about network conditions in NWDAF</li> <li>MTLF: providing trained machine learning models and help predict network behavior</li> <li> <p>Analytics Model     The interaction between AnLF and MTLF creates a dynamic analytics environment. AnLF uses the models provided by MTLF to process current data, while MTLF uses the results to refine its models. </p> <ul> <li>These two core components will discuss in next section</li> </ul> </li> </ul> </li> </ul>"},{"location":"blog/20241127/20241127/#3-analytics-exposure","title":"3. Analytics Exposure","text":""},{"location":"blog/20241127/20241127/#mechanisms_2","title":"Mechanisms","text":"<p>NWDAF shares its insights through:</p> <ul> <li>Subscription-based analytics services</li> <li>Real-time analytics delivery</li> <li>Historical data analysis</li> <li>ML model provisioning</li> </ul>"},{"location":"blog/20241127/20241127/#architecture","title":"Architecture","text":"<ul> <li> <p>Analytics Distribution through Nnwdaf     The Nnwdaf interface serves as the primary channel for sharing analytics results. Network functions can subscribe to specific types of analytics and receive regular updates or request specific information when needed. </p> </li> <li> <p>Coordinated Analytics Delivery     Similar to data collection, DCCF can help optimize analytics distribution by managing multiple subscriptions and ensuring efficient delivery of analytics results to various consumers. </p> </li> </ul>"},{"location":"blog/20241127/20241127/#details-for-analytics-processing","title":"Details for Analytics Processing","text":""},{"location":"blog/20241127/20241127/#core-components","title":"Core Components","text":"<ul> <li> <p>Analytics Logical Function (AnLF)     AnLF is the primary analytics engine in NWDAF that processes data             and generates insights.      Its responsibilities include:</p> <ul> <li>Performing inference on collected network data</li> <li>Generating statistical information about past events</li> <li>Providing predictive analytics for future network behavior</li> <li>Exposing analytics through Nnwdaf_AnalyticsSubscription/Info services</li> </ul> <p>AnLF can work with both statistical models and ML models provided by MTLF, allowing it to handle different types of analytics requirements. While AnLF processes the analytics requests, it remains unaware of whether the ML models it uses were trained through federated learning or traditional methods.</p> </li> <li> <p>Model Training Logical Function (MTLF)     MTLF specializes in training and managing ML models. In Release 18, MTLF introduced significant enhancements, particularly in federated learning capabilities. Its main functions include:</p> <ul> <li>Training ML models using collected network data</li> <li>Supporting federated learning among multiple NWDAFs</li> <li>Managing ML model updates and provisioning</li> <li>Providing trained models to AnLF and other network functions</li> </ul> <p>MTLF can operate in two modes within federated learning:</p> <pre><code>1. As an FL Server: Coordinating model training across multiple NWDAFs\n2. As an FL Client: Training models locally using its own data\n</code></pre> </li> <li> <p>The interaction between AnLF and MTLF creates a complete analytics pipeline where:</p> <ul> <li>AnLF handles the analytics processing and service exposure</li> <li>MTLF manages the underlying ML models and training</li> </ul> </li> <li> <p>This separation of concerns allows for specialized optimization of both analytics processing and model training while maintaining flexibility in deployment options.This continuous feedback loop ensures that NWDAF's analytics capabilities keep improving over time. </p> </li> </ul>"},{"location":"blog/20241127/20241127/#nwdaf-important-analytics-services","title":"NWDAF Important Analytics Services","text":"<ul> <li>Here are some key situations that need the assistance of NWDAF </li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-network-performance-analytics","title":"1. Network Performance Analytics","text":""},{"location":"blog/20241127/20241127/#slice-load-level-analytics-section-63","title":"Slice Load Level Analytics (Section 6.3)","text":"<ul> <li>In modern 5G networks, different services run on separate network slices. NWDAF continuously monitors each slice's resource usage and provides essential information for slice selection. </li> <li>For example, when a gaming service slice approaches high load, NWDAF can trigger resource reallocation or guide new users to less congested slices, ensuring consistent service quality.</li> </ul>"},{"location":"blog/20241127/20241127/#nf-load-analytics-section-65","title":"NF Load Analytics (Section 6.5)","text":"<ul> <li>Network Functions like AMF and SMF are critical components in 5G. NWDAF analyzes their load status to enable intelligent load balancing. </li> <li>When NWDAF detects an overloaded AMF, it can inform the system to redirect new connections to other AMFs, maintaining optimal network operation.</li> </ul>"},{"location":"blog/20241127/20241127/#2-user-experience-analytics","title":"2. User Experience Analytics","text":""},{"location":"blog/20241127/20241127/#service-experience-analytics-section-64","title":"Service Experience Analytics (Section 6.4)","text":"<ul> <li>NWDAF monitors real-time service quality by analyzing metrics like latency and throughput. </li> <li>For instance, if video streaming users in a specific area experience degraded quality, NWDAF can identify the issue and trigger necessary adjustments to maintain service standards.</li> </ul>"},{"location":"blog/20241127/20241127/#ue-behavior-analytics-section-67","title":"UE Behavior Analytics (Section 6.7)","text":"<ul> <li>By analyzing user movement patterns, NWDAF can predict future locations and behaviors. This enables proactive resource allocation </li> <li>If NWDAF predicts a large crowd gathering for an event, the network can prepare additional resources in that area beforehand.</li> </ul>"},{"location":"blog/20241127/20241127/#3-resource-optimization","title":"3. Resource Optimization","text":""},{"location":"blog/20241127/20241127/#qos-sustainability-analytics-section-69","title":"QoS Sustainability Analytics (Section 6.9)","text":"<ul> <li>NWDAF helps maintain consistent service quality by predicting potential QoS changes. If it detects that video call quality might degrade in a busy area, it can initiate preemptive measures to maintain service levels.</li> </ul>"},{"location":"blog/20241127/20241127/#user-data-congestion-analytics-section-68","title":"User Data Congestion Analytics (Section 6.8)","text":"<ul> <li>Through traffic pattern analysis, NWDAF can identify potential congestion before it impacts users. </li> <li>For example, it can detect emerging congestion patterns during peak hours and recommend traffic redistribution to prevent service degradation.</li> </ul>"},{"location":"blog/20241127/20241127/#a-complete-example-of-nwdaf-analytics","title":"A Complete Example of NWDAF Analytics","text":"<ul> <li>Let's review the NWDAF by real-world scenario, imagine a high-priority gaming service slice experiencing increasing load during peak gaming hours:</li> <li> </li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-data-collection-process","title":"1. Data Collection Process","text":"<p>First, NWDAF collects data from various network functions:</p> <ul> <li>Gets real-time resource utilization data from network slices</li> <li>Receives user connection information from AMF</li> <li>Obtains QoS flow statistics from SMF</li> <li>Gathers historical load patterns from OAM</li> </ul>"},{"location":"blog/20241127/20241127/#2-analytics-processing_1","title":"2. Analytics Processing","text":"<pre><code>NWDAF then processes this data using its two core components:\n</code></pre> <ul> <li> <p>AnLF (Analytics Logical Function):</p> <ul> <li>Analyses current slice load trends</li> <li>Compares with historical patterns</li> <li>Identifies potential overload risks</li> </ul> </li> <li> <p>MTLF (Model Training Logical Function):</p> <ul> <li>Uses collected data to train prediction models</li> <li>Updates models based on new patterns</li> <li>Provides refined models to AnLF for better predictions</li> </ul> </li> </ul>"},{"location":"blog/20241127/20241127/#3-analytics-results-and-actions","title":"3. Analytics Results and Actions","text":"<pre><code>NWDAF generates actionable insights:\n</code></pre> <ul> <li>Predicts slice load for the next few hours</li> <li>Identifies potential capacity issues</li> <li>Recommends preventive measures</li> </ul>"},{"location":"blog/20241127/20241127/#4-network-optimization","title":"4. Network Optimization","text":"<pre><code>The system responds to NWDAF's analytics:\n</code></pre> <ul> <li>NSSF adjusts slice selection strategy</li> <li>AMF redirects new gaming users to less loaded slices</li> <li>OAM allocates additional resources if available</li> </ul>"},{"location":"blog/20241127/20241127/#references","title":"References","text":"<ul> <li>3GPP TS 23.288</li> <li>https://blog.csdn.net/qq_31985307/article/details/139897023</li> <li>https://www.5gamericas.org/wp-content/uploads/2021/10/5G-Edge-and-Automation-PPT.pdf</li> <li>https://www.aarna.ml/post/nwdaf-rel-17-explained-architecture-features-and-use-cases</li> </ul>"},{"location":"blog/20241203/20241203/","title":"Loxilb eBPF","text":"<p>In the evolving landscape of networking, the demand for high-performance, flexible, and efficient solutions has never been greater. Traditional approaches to packet processing often struggle to keep up with the scale and complexity of modern cloud-native environments and 5G networks. Enter Loxilb, an innovative networking solution leveraging the power of eBPF (Extended Berkeley Packet Filter). eBPF, a game-changing technology in the Linux kernel, allows developers to customize packet processing directly in the kernel with unparalleled speed and flexibility, all while maintaining safety and stability.</p> <p>A practical application of LoxiLB's capabilities is demonstrated in the 5G core networks, where effectively managing signaling traffic is crucial for performance and reliability. For example, deploying a load balancer to distribute traffic across multiple Access and Mobility Management Function (AMF) instances enhances both scalability and fault tolerance. This approach is detailed in the article \"5G SCTP LoadBalancer Using LoxiLB Applying on free5GC\", which illustrates how LoxiLB can distribute SCTP traffic among multiple AMF instances within a free5GC environment.</p> <p>In this document, I will provide a comprehensive exploration of Loxilb's architecture, its efficient use of eBPF, and the dual-pipeline design that makes it a robust choice for scenarios requiring high-performance networking and advanced load balancing. Whether you're an enthusiast, developer, or systems architect, this guide will equip you with a deep understanding of how Loxilb utilizes eBPF to revolutionize packet processing and load balancing in modern networks.</p>"},{"location":"blog/20241203/20241203/#introduction","title":"Introduction","text":"<p>Loxilb is a networking solution that utilizes eBPF, leverage eBPF to modify the packet processing rules as they traverse the network stack in the Linux kernel. This can be particularly useful for network behavior without altering existing applications or the operating system itself.</p>"},{"location":"blog/20241203/20241203/#core-components","title":"Core Components","text":""},{"location":"blog/20241203/20241203/#object-files","title":"Object Files","text":"<p>loxilb generates two primary object files during build: <pre><code>/opt/loxilb/llb_ebpf_main.o  # TC layer processing (305KB)\n/opt/loxilb/llb_xdp_main.o   # XDP layer processing (95KB)\n</code></pre></p>"},{"location":"blog/20241203/20241203/#hook-points","title":"Hook Points","text":"Feature TC eBPF XDP Packet Format Socket Buffer (skb) XDP Frame Format Processing Level L2-L7 Primarily L2 <ol> <li>TC eBPF Layer</li> <li>Handles majority of L4+ processing</li> <li>Optimized for complex operations</li> <li>Supports TCP checksum offload</li> <li>Handles connection tracking</li> <li>XDP Layer</li> <li>Performs quick L2 operations</li> <li>Handles packet mirroring</li> <li>Used for operations requiring multiple packet copies</li> </ol>"},{"location":"blog/20241203/20241203/#loxilb-ebpf-maps","title":"loxilb eBPF Maps","text":"<p>eBPF (extended Berkeley Packet Filter) maps are essential data structures within the Linux kernel that facilitate efficient storage and sharing of data between eBPF programs and user-space applications.</p> <p>They function as key-value stores, enabling eBPF programs to maintain state across multiple invocations and allowing communication between the kernel and user space. * State Preservation * Kernel-User Space Communication * Data Sharing Among eBPF Programs</p> <p>LoxiLB utilizes eBPF maps to store and manage various data structures essential for packet processing. These maps are pinned to the filesystem, allowing for persistent storage and easy access. Commonly used maps include: * Interface Maps: Store information about network interfaces.</p> <ul> <li> <p>Connection Tracking Maps: Maintain state information for active connections.</p> </li> <li> <p>NAT Maps: Handle Network Address Translation entries.</p> </li> <li> <p>Policy Maps: Store security and routing policies.</p> </li> </ul>"},{"location":"blog/20241203/20241203/#loxilb-ebpf-pipeline","title":"loxilb eBPF pipeline","text":"<p>Then I will detail analysis of loxilb's end-to-end packet processing pipeline and Load Balancer based on this architecture diagram.</p>"},{"location":"blog/20241203/20241203/#what-is-ebpf-tail-call","title":"What is eBPF Tail Call?","text":"<p>An eBPF tail call is a mechanism that allows one eBPF program to call another eBPF program without returning to the original program. It's like a \"jump\" instruction that transfers control completely to another program and have benefit in: * Modular code structure * Efficient processing pipeline * Compliance with eBPF verifier limits * The Linux kernel limits the number of consecutive tail calls allowed to 32</p>"},{"location":"blog/20241203/20241203/#pipeline-selection","title":"Pipeline Selection","text":"<p>Fast Path (pipe1)and Slow Path (pipe2), these two pipelines address the need for optimizing different types of packet processing tasks based on their complexity and requirements. <pre><code>[Incoming Packet]\n      \u2193\n[Parse Packet Headers]\n      \u2193\n[Connection Lookup]\u2500\u2500\u2500\u2500\u2500Yes\u2500\u2500\u2510\n      \u2193                      \u2193\n[Is Established?]     [Process &amp; Forward (Fast Path)]\n      \u2193                      \u2502\n      No                     \u2502\n      \u2193                      \u2502\n[Tail Call to Slow Path]     \u2502\n      \u2502                      \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"blog/20241203/20241203/#tcp-and-udp-example","title":"TCP and UDP example","text":"<pre><code>### TCP Example:\nCLOSED \u2192 SYN_SENT \u2192 SYN_RECEIVED \u2192 ESTABLISHED\n   \u2502                                    \u2502\n   \u2502                                    \u25bc\n[Slow Path Processing]            [Move to Fast Path]\n\n\n### UDP Example:\nNEW \u2192 SEEN \u2192 ESTABLISHED\n \u2502              \u2502\n \u2502              \u25bc\n[Slow Path] [Move to Fast Path]\n</code></pre>"},{"location":"blog/20241203/20241203/#1-initial-packet-reception-and-parsing","title":"1. Initial Packet Reception and Parsing","text":"<p><code>kernel/llb_kern_entry.c</code> <pre><code>[Incoming Packet] \u2192 [packet parsing]\n  \u2193\n[intf map] - Interface configuration lookup\n  - Interface index\n  - VLAN information\n  - Zone information\n  - Policy parameters\n</code></pre> * When a packet arrives(parsing happens in <code>dp_parse_d0</code>), the packet parsing module extracts key metadata such as:     * Source/destination MAC addresses     * IP addresses     * Layer 4 ports (if applicable) * Metadata is stored in the <code>xfi</code> structure, which guides further processing. * Interface-specific rules and properties are checked using <code>intf_map</code>.</p>"},{"location":"blog/20241203/20241203/#2-qos-processing","title":"2. QoS Processing","text":"<p><code>kernel/llb_kern_policer.c</code> <pre><code>[QoS Stage]\n  \u2193\n[pol map] - Policy lookup\n  - Traffic policing rules\n  - Rate limiting\n  - Traffic shaping\n  \u2193\n[qos map] - QoS parameters\n  - Priority queues\n  - Bandwidth allocation\n</code></pre> * Traffic policies (e.g., rate-limiting, prioritization) are applied based on:     * Policy map <code>pol_map</code>: Defines access control and prioritization policies.     * QoS map <code>qos_map</code>: Ensures compliance with Quality of Service requirements (e.g., rate shaping). * Packets violating policies may be dropped or delayed.</p>"},{"location":"blog/20241203/20241203/#3-layer-2-forwarding","title":"3. Layer 2 Forwarding","text":"<p><code>kernel/llb_kern_l2fwd.c</code></p>"},{"location":"blog/20241203/20241203/#key-components","title":"Key Components","text":"<ul> <li><code>l2fwd</code> (Layer 2 forwarding)</li> <li><code>l2tunfwd</code> (Layer 2 tunneling forwarding)</li> </ul>"},{"location":"blog/20241203/20241203/#maps-used","title":"Maps Used:","text":"<ul> <li><code>smac_map</code>: Source MAC address</li> <li><code>dmac_map</code>: Destination MAC address</li> <li><code>rmac_map</code>: Router MAC address</li> </ul>"},{"location":"blog/20241203/20241203/#l2fwd-mac-based-forwarding","title":"<code>l2fwd</code> (MAC-based forwarding)","text":"<pre><code>[l2fwd Stage]\n  \u2193\n[smac map] - Source MAC processing\n  - MAC learning\n  - Source validation\n  \u2193\n[dmac map] - Destination MAC processing\n  - MAC lookup\n  - L2 forwarding decision\n</code></pre>"},{"location":"blog/20241203/20241203/#l2tunfwd-tunneling-at-layer-2","title":"<code>l2tunfwd</code> (tunneling at Layer 2)","text":"<pre><code>[l2tunfwd Stage]\n  - VXLAN processing\n  - NVGRE processing\n  - Other L2 tunnel protocols\n</code></pre>"},{"location":"blog/20241203/20241203/#4-layer-3-forwarding","title":"4. Layer 3 Forwarding","text":"<p><code>kernel/llb_kern_l3fwd.c</code></p>"},{"location":"blog/20241203/20241203/#key-functions","title":"Key Functions","text":"<ul> <li><code>dp_ing_l3()</code>: Entry point for L3 ingress processing.</li> <li><code>dp_l3_fwd()</code>: Main function for Layer 3 forwarding.</li> <li><code>dp_do_rtv4()</code> and <code>dp_do_rtv6()</code>: Handle IPv4 and IPv6 route lookups and apply forwarding actions.</li> <li><code>dp_do_ctops()</code>: Handles connection tracking and NAT for packets.</li> </ul>"},{"location":"blog/20241203/20241203/#maps-used_1","title":"Maps Used:","text":"<ul> <li><code>ct_map</code>: Connection tracking table for stateful flow handling.</li> <li><code>rt_v4_map</code>: IPv4 routing table.</li> <li><code>rt_v6_map</code>: IPv6 routing table.</li> <li><code>LL_DP_RTV4_STATS_MAP</code> and <code>LL_DP_RTV6_STATS_MAP</code>: Statistics for routes.</li> </ul>"},{"location":"blog/20241203/20241203/#5-load-balancer-layer-4-forwarding","title":"5. Load Balancer / Layer 4 Forwarding","text":""},{"location":"blog/20241203/20241203/#kernelllb_kern_ctc","title":"<code>kernel/llb_kern_ct.c</code>","text":"<p>Provides connection tracking infrastructure</p>"},{"location":"blog/20241203/20241203/#key-components_1","title":"Key Components","text":"<ul> <li>Connection State Tracking:</li> <li>Maintains connection states for all protocols (TCP/UDP/SCTP/ICMP)</li> <li> <p>Required for stateful operation in both load balancing and L4 forwarding</p> </li> <li> <p>NAT Support Infrastructure:</p> </li> <li>Tracks NAT translations</li> <li>Maintains original and translated addresses/ports</li> <li>Essential for load balancer backend selection</li> </ul>"},{"location":"blog/20241203/20241203/#kernelllb_kern_natlbfwdc","title":"<code>kernel/llb_kern_natlbfwd.c</code>:","text":"<p>Network Address Translation (NAT) and Load Balancer forwarding implementation</p>"},{"location":"blog/20241203/20241203/#multiple-load-balancing-algorithms","title":"Multiple load balancing algorithms:","text":"<ul> <li>Round Robin <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_RR) {\n    bpf_spin_lock(&amp;act-&gt;lock);\n    i = act-&gt;sel_hint; \n\n    // Iterate through endpoints\n    while (n &lt; LLB_MAX_NXFRMS) {\n        if (nxfrm_act-&gt;inactive == 0) {\n            // Select next backend in rotation\n            act-&gt;sel_hint = (i + 1) % LLB_MAX_NXFRMS;\n            sel = i;\n            break;\n        }\n    }\n}\n</code></pre></li> <li>Hash-based <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_HASH) {\n    // Hash packet for backend selection\n    sel = dp_get_pkt_hash(ctx) % act-&gt;nxfrm;\n\n    // Fallback if selected backend is inactive\n    if (act-&gt;nxfrms[sel].inactive) {\n        for (i = 0; i &lt; LLB_MAX_NXFRMS; i++) {\n            if (act-&gt;nxfrms[i].inactive == 0) {\n                sel = i;\n                break;\n            }\n        }\n    }\n}\n</code></pre></li> <li>Least Connections <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_LC) {\n    struct dp_nat_epacts *epa;\n    __u32 lc = 0;\n\n    // Find backend with least active connections\n    for (i = 0; i &lt; LLB_MAX_NXFRMS; i++) {\n        if (nxfrm_act-&gt;inactive == 0) {\n            __u32 as = epa-&gt;active_sess[i];\n            if (lc &gt; as || sel &lt; 0) {\n                sel = i;\n                lc = as;\n            }\n        }\n    }\n}\n</code></pre></li> <li>Persistent RR</li> <li>N3 (GTP tunnel) based</li> </ul>"},{"location":"blog/20241203/20241203/#conclusion-about-loxilbs-effective-use-of-ebpf","title":"Conclusion about loxilb's effective use of eBPF","text":""},{"location":"blog/20241203/20241203/#smart-pipeline-design","title":"Smart Pipeline Design","text":"<ul> <li>Dual pipeline architecture (Fast/Slow) optimizes performance</li> <li>Fast path for established connections</li> <li>Slow path for new connections and complex processing</li> </ul>"},{"location":"blog/20241203/20241203/#effective-use-of-ebpf-features","title":"Effective Use of eBPF Features","text":"<ul> <li>Tail calls to overcome program size limits</li> <li>Maps for state management</li> <li>TC and XDP hooks for different processing needs</li> </ul>"},{"location":"blog/20241203/20241203/#loxilb-particularly-suitable-for","title":"loxilb particularly suitable for","text":"<ul> <li>Modern cloud-native environments</li> <li>High-performance networking</li> <li>Complex load balancing scenarios</li> <li>Situations requiring efficient packet processing</li> </ul>"},{"location":"blog/20241203/20241203/#references","title":"references","text":"<ul> <li>What is eBPF ??</li> <li>loxilb eBPF implementation details</li> <li>State synchronization of eBPF Maps using Go - A tale of two frameworks !</li> <li>\u5b66\u4e60 loxilb\uff081\uff09\uff1a\u672c\u5730\u6784\u5efa\u4e0e\u6d4b\u8bd5</li> <li>5G SCTP LoadBalancer Using LoxiLB Applying on free5GC</li> </ul>"},{"location":"blog/20241203/20241203/#about","title":"About","text":"<p>Hello, I'm William Lin. I'd like to share my excitement about being a member of the free5gc project, which is a part of the Linux Foundation. I'm always eager to discuss any aspects of core network development or related technologies.</p>"},{"location":"blog/20241203/20241203/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: williamlin0518</li> <li>Linkedin: Cheng Wei Lin</li> </ul>"},{"location":"blog/20241204/20241204/","title":"Paging in 5G Network","text":"<p>Note</p> <p>Author: Yung-Hsuan, Tsao Date: 2024/12/04</p> <p>In the 5G network, when a UE(User Equipment) is not actively involved in data transfer, it will turn into idle mode to conserve the battery. In this state, the network requires a mechanism to alert the UE when receiving an incoming call, a data packet waiting to be delivered, or a network request to re-establish connectivity with a UE. Paging is the procedure used to notify a UE in an idle or low-power state about such events.</p>"},{"location":"blog/20241204/20241204/#overview-of-paging-in-5g","title":"Overview of Paging in 5G","text":"<p>The paging process involves several key steps to ensure efficient and reliable communication between the network and the UE:</p> <p></p>"},{"location":"blog/20241204/20241204/#1-triggering-the-paging-request","title":"1. Triggering the Paging Request","text":"<p>When there is incoming data or a call request for the idle UE, the network needs to notify the UE. The trigger typically comes from the AMF(Access and Mobility Management Function), which manages mobility and session information for devices in the 5G Core Network. The AMF typically triggers paging for reasons such as:</p> <ul> <li>Downlink Data Notification: SMF(Session Management Function), primarily responsible for interacting with the decoupled data plane, informs the AMF of incoming data for the UE. </li> <li>Mobile-Terminated Call: The network receives a signaling request to connect a voice or video call to UE.</li> <li>Network Events: For example, updates or emergency notifications.</li> </ul>"},{"location":"blog/20241204/20241204/#2-generating-the-paging-message","title":"2. Generating the Paging Message","text":"<p>After receiving a paging trigger, AMF needs to determine the UE's location and reachability. It uses the UE's Registration Area(RA) or Tracking Area(TA) information stored in the AMF context to narrow down the list of gNBs or cells where the UE is likely present. The AMF uses the NG Application Protocol(NGAP) to send the paging request to these gNBs, which broadcast it over their radio interfaces.</p>"},{"location":"blog/20241204/20241204/#3-ue-response","title":"3. UE Response","text":"<p>The UE in idle mode periodically wakes up to monitor for paging messages and goes back to sleep mode if it is not intended for it, this is also known as the Discontinuous Reception(DRX) cycle. Upon recognizing its identifier in the paging message, the UE responds by initiating a Service Request procedure. This allows the UE to transition from idle mode to connected mode.</p>"},{"location":"blog/20241204/20241204/#4-re-establishing-connectivity","title":"4. Re-establishing Connectivity","text":"<p>After receiving the Service Request, the AMF: 1. Validates the Paging Context: Confirms that the UE responded to the Service Request matches the UE that the paging is triggered. 2. Retrieves UE Context: Loads the UE's mobility context and session information and also validates the request against the subscription and policy rules. 3. Manages Session Continuity: If the Service Request is for data, AMF needs to ensure the relevant PDU session is active.</p> <p>The gNB establishes a Radio Resource Control (RRC) connection with the UE, enabling the necessary radio bearers for data transfer or signaling. If the request involves downlink data, packets buffered in the User Plane Function (UPF) are delivered to the UE.</p>"},{"location":"blog/20241204/20241204/#paging-message","title":"Paging Message","text":"<p>The following is a further introduction to the paging message transmitted by the AMF via the NG-RAN(gNB) to the UE, which contains essential information to identify the UE and specify the paging cause.</p> <p>Here are some critical fields in the paging message:</p> <ul> <li>UE Paging Identity: A temporary identifier uniquely identifying the UE.</li> <li>TAI List for Paging: Specifies the areas where the paging should be broadcast.</li> <li>Paging Priority: Specifies the priority of the paging request, ensuring time-critical services(e.g. emergency calls) are handled promptly.</li> <li>Paging Origin: The source or entity in the network that initiates the paging procedure.</li> </ul>"},{"location":"blog/20241204/20241204/#error-handling-and-paging-retries","title":"Error Handling and Paging Retries","text":"<p>Error handling and retries are also critical in the paging process to ensure reliable communication with the UE(s), especially in scenarios like network congestion, UE mobility, or poor radio conditions. Following is a simple introduction to the mechanisms and strategies for handling errors and performing retries during paging in 5G networks.</p> <p>Errors in the paging process can occur under various conditions, for example:</p> <ul> <li>UE Non-Response: The UE does not respond to a paging message due to poor coverage, signal interference, or power-saving mode misalignment.</li> <li>Incorrect Paging Area: The UE is no longer present in the area where it was last registered.</li> <li>Network Congestion: The gNB experiences a high traffic load, leading to delayed or dropped paging messages.</li> </ul> <p>To address these errors, AMF employs retry mechanisms to successfully reach the UE by applying further paging according to any applicable paging strategy. These strategies include, </p> <ul> <li>a paging retransmission scheme (e.g., how frequently the paging is repeated or with what time interval)</li> <li>determining whether to send the paging message to the (R)AN nodes during certain AMF high load conditions</li> <li>apply sub-area based paging (e.g., the first page in the last known cell-id and retransmission in all registered TAs).</li> </ul> <p>If retries fail after multiple attempts, AMF may initiate additional procedures to recover the UE's context, such as requesting its current location through network-level signaling.</p> <p>Paging errors can also result from UE mobility across the registration area. In this case, the AMF coordinates with neighboring AMFs to forward the paging result if the UE is likely to have moved to a different registration area. The previous AMF forwards the paging message to the new AMF to retry paging in the updated area.</p> <p>In cases where paging errors persist after retries, the network uses fallback mechanisms to ensure continuity.</p>"},{"location":"blog/20241204/20241204/#conclusion","title":"Conclusion","text":"<p>Paging is a fundamental procedure in the 5G network, enabling seamless communication with UEs in idle or low-power states. By combining efficient paging strategies with robust error handling, the AMF ensures reliable delivery of services while minimizing resource use. This process reflects the advanced capabilities of 5G in balancing network efficiency, battery conservation, and quality of service. Paging's intelligent design ensures that the 5G network remains responsive and adaptive to the dynamic needs of modern connectivity.</p>"},{"location":"blog/20241204/20241204/#reference","title":"Reference","text":"<ul> <li>TS 23.501</li> <li>TS 23.502: Describes the overall paging and service request procedures</li> <li>TS 38.413: About NGAP messages used between AMF and gNB</li> <li>Idle Mode DRX in 5G NR</li> </ul>"},{"location":"blog/20241204/20241204/#about","title":"About","text":"<p>Hi, I'm Yung-Hsuan!  A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20241204/20241204/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/reki9185</li> </ul>"},{"location":"blog/20241224/","title":"Debug gtp5g kernel module using stacktrace and eBPF","text":"<p>Note</p> <p>Author: Ian Chen Date: 2024/12/24</p>"},{"location":"blog/20241224/#case-study-kernel-panic-caused-by-the-online-charging-pdu-session","title":"Case Study - kernel panic caused by the online charging PDU Session","text":"<p>free5GC is highly rely on the infrastructures provided by the Linux Kernel, especially the gtp5g kernel module.</p> <p>@andy89923 found a reproducible kernel panic issue. Follow the actions below can always produce the kernel panic:</p> <ul> <li>Create online charging PDU Session</li> <li>Ping the Data Network (should match the ip filter of the charging configuration)</li> </ul> <p>Please also note that, the case of kernel panic will only happens if the version of gtp5g greater than v0.8.x.</p>"},{"location":"blog/20241224/#figure-out-the-problem","title":"Figure out the problem","text":"<p>Although we can get the panic log by using the dmesg. However, the stack dumps are not useful enough for kernel debugging at all.</p> <p>However, we can use the decode_stacktrace.sh can find the specific line in source code by leveraging the vmlinux.</p> <p>The original panic logs: <pre><code>[  +0.004968] ------------[ cut here ]------------\n[  +0.000002] kernel BUG at mm/slub.c:307!\n[  +0.000109] invalid opcode: 0000 [#1] SMP PTI\n[  +0.000056] CPU: 3 PID: 191301 Comm: nrf Tainted: G           OE     5.4.0-131-generic #147-Ubuntu\n[  +0.000068] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[  +0.000047] RIP: 0010:kfree+0x236/0x250\n[  +0.000048] Code: e7 e8 9e 71 fd ff e9 ef fe ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da 4c 89 e6 4c 89 ef e8 6f fa ff ff e9 d0 fe ff ff &lt;0f&gt; 0b 48 8b 05 d1 51 77 01 e9 ff fd ff ff 66 66 2e 0f 1f 84 00 00\n[  +0.000108] RSP: 0000:ffffa104c015c7f0 EFLAGS: 00010246\n[  +0.000018] RAX: ffff93e58bc98000 RBX: ffff93e58bc98000 RCX: ffff93e58bc98000\n[  +0.000017] RDX: 0000000000039962 RSI: bdd6aff4c23d967a RDI: ffff93e58bc98000\n[  +0.000017] RBP: ffffa104c015c810 R08: ffff93e58bc98000 R09: ffffa104c015c8d8\n[  +0.000018] R10: ffff93e5d302c680 R11: 0000000000000001 R12: fffffc7d8c2f2600\n[  +0.000018] R13: ffff93e6adc06bc0 R14: ffffffff99edcf25 R15: ffff93e565a70600\n[  +0.000017] FS:  000000c000580090(0000) GS:ffff93e6afac0000(0000) knlGS:0000000000000000\n[  +0.000020] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000014] CR2: 00007fac6fecf160 CR3: 000000034857c001 CR4: 0000000000760ee0\n[  +0.000026] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  +0.000018] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  +0.000021] PKRU: 55555554\n[  +0.000007] Call Trace:\n[  +0.000014]  &lt;IRQ&gt;\n[  +0.000031]  skb_free_head+0x25/0x30\n[  +0.000018]  skb_release_data+0x11d/0x180\n[  +0.000015]  skb_release_all+0x26/0x30\n[  +0.000015]  consume_skb+0x2c/0xb0\n[  +0.000046]  gtp5g_dev_xmit+0xc3/0x170 [gtp5g]\n[  +0.000016]  ? update_load_avg+0x7c/0x670\n[  +0.000017]  dev_hard_start_xmit+0x91/0x1f0\n[  +0.000019]  __dev_queue_xmit+0x75f/0x990\n[  +0.000016]  ? nfnetlink_has_listeners+0x15/0x20 [nfnetlink]\n[  +0.000016]  dev_queue_xmit+0x10/0x20\n[  +0.000014]  neigh_direct_output+0x11/0x20\n[  +0.000019]  ip_finish_output2+0x17e/0x580\n[  +0.000016]  __ip_finish_output+0xf3/0x270\n[  +0.000017]  ip_finish_output+0x2d/0xb0\n[  +0.000018]  ip_output+0x75/0xf0\n[  +0.000010]  ? __ip_finish_output+0x270/0x270\n[  +0.000013]  ip_forward_finish+0x58/0x90\n[  +0.000012]  ip_forward+0x3b9/0x4c0\n[  +0.000010]  ? ip4_key_hashfn+0xb0/0xb0\n[  +0.000012]  ip_sublist_rcv_finish+0x3d/0x50\n[  +0.000021]  ip_sublist_rcv+0x1c5/0x270\n[  +0.000956]  ? ip_rcv_finish_core.isra.0+0x3c0/0x3c0\n[  +0.000637]  ip_list_rcv+0x10b/0x130\n[  +0.000678]  __netif_receive_skb_list_core+0x228/0x250\n[  +0.000576]  netif_receive_skb_list_internal+0x1a1/0x2b0\n[  +0.000572]  gro_normal_list.part.0+0x1e/0x40\n[  +0.000524]  napi_complete_done+0x91/0x130\n[  +0.000557]  virtnet_poll+0x30d/0x450 [virtio_net]\n[  +0.000558]  net_rx_action+0x142/0x390\n[  +0.000598]  __do_softirq+0xd1/0x2c1\n[  +0.000559]  irq_exit+0xae/0xb0\n[  +0.000500]  do_IRQ+0x5a/0xf0\n[  +0.000504]  common_interrupt+0xf/0xf\n[  +0.000488]  &lt;/IRQ&gt;\n[  +0.000467] RIP: 0033:0x423172\n[  +0.000467] Code: 23 4c 89 44 24 38 e8 8d 46 ff ff 48 85 f6 0f 84 a0 00 00 00 48 8b 94 24 88 00 00 00 49 89 f1 48 8b 74 24 48 4d 89 c8 4d 8b 09 &lt;49&gt; 29 d0 4d 85 c9 74 b0 4d 89 ca 49 29 d1 4c 39 ce 77 a5 4c 89 44\n[  +0.001066] RSP: 002b:000000c000593e90 EFLAGS: 00000202 ORIG_RAX: ffffffffffffffdb\n[  +0.000517] RAX: 000000c000387200 RBX: 0000000000018e00 RCX: 5000000000000000\n[  +0.000461] RDX: 000000c000380000 RSI: 0000000000020000 RDI: 0000000000000040\n[  +0.000590] RBP: 000000c000593f08 R08: 000000c0003873d0 R09: 0000000000d17b82\n[  +0.000601] R10: 0000000000d1ce8e R11: 0000000000018e00 R12: 0000000000000001\n[  +0.000619] R13: 13679e0f6eacd19f R14: 000000c0005821a0 R15: 0000000000000000\n[  +0.000461] Modules linked in: sctp vxlan xt_multiport xt_set ipt_rpfilter iptable_raw ip_set_hash_ip ip_set_hash_net ip_set wireguard ip6_udp_tunnel veth xfrm_user xfrm_algo nf_conntrack_netlink xt_addrtype xt_nat xt_tcpudp xt_MASQUERADE xt_mark xt_conntrack iptable_mangle ip6table_filter ip6table_mangle ip6table_nat ip6_tables iptable_nat nf_nat br_netfilter bridge stp llc nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nft_counter nft_compat nf_tables nfnetlink iptable_filter xt_comment bpfilter aufs overlay dummy dm_multipath scsi_dh_rdac scsi_dh_emc scsi_dh_alua binfmt_misc intel_rapl_msr intel_rapl_common isst_if_common nfit kvm_intel kvm rapl joydev input_leds serio_raw mac_hid qemu_fw_cfg sch_fq_codel gtp5g(OE) sunrpc ramoops udp_tunnel reed_solomon efi_pstore ip_tables x_tables autofs4 btrfs zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear hid_generic usbhid hid bochs_drm drm_vram_helper ttm\n[  +0.000189]  drm_kms_helper crct10dif_pclmul crc32_pclmul syscopyarea sysfillrect ghash_clmulni_intel sysimgblt aesni_intel crypto_simd cryptd glue_helper fb_sys_fops virtio_net psmouse net_failover drm failover virtio_scsi i2c_piix4 pata_acpi floppy\n[  +0.005947] ---[ end trace e017af78fce65824 ]---\n</code></pre></p> <p>You can follow the commands below to make the panic logs more human-friendly: <pre><code>$ sudo apt install linux-source-5.4.0\n$ cd /usr/src/linux-source-5.4.0\n$ sudo make -j$(nproc) vmlinux // if you don't have vmlinux file\n$ sudo ./scripts/decode_stacktrace.sh ./vmlinux ./ ~/gtp5g/ &lt; ~/panic.log  &gt; ~/out.log\n</code></pre> The output will looks like: <pre><code>[  +0.004968] ------------[ cut here ]------------\n[  +0.000002] kernel BUG at mm/slub.c:307!\n[  +0.000109] invalid opcode: 0000 [#1] SMP PTI\n[  +0.000056] CPU: 3 PID: 191301 Comm: nrf Tainted: G           OE     5.4.0-131-generic #147-Ubuntu\n[  +0.000068] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[   +0.000047] RIP: 0010:kfree (/usr/src/linux-source-5.4.0/mm/slub.c:307 /usr/src/linux-source-5.4.0/mm/slub.c:302 /usr/src/linux-source-5.4.0/mm/slub.c:3035 /usr/src/linux-source-5.4.0/mm/slub.c:3060 /usr/src/linux-source-5.4.0/mm/slub.c:4027)\n[ +0.000048] Code: e7 e8 9e 71 fd ff e9 ef fe ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da 4c 89 e6 4c 89 ef e8 6f fa ff ff e9 d0 fe ff ff &lt;0f&gt; 0b 48 8b 05 d1 51 77 01 e9 ff fd ff ff 66 66 2e 0f 1f 84 00 00\nAll code\n========\n   0:   e7 e8                   out    %eax,$0xe8\n   2:   9e                      sahf\n   3:   71 fd                   jno    0x2\n   5:   ff                      (bad)\n   6:   e9 ef fe ff ff          jmpq   0xfffffffffffffefa\n   b:   4d 89 f1                mov    %r14,%r9\n   e:   41 b8 01 00 00 00       mov    $0x1,%r8d\n  14:   48 89 d9                mov    %rbx,%rcx\n  17:   48 89 da                mov    %rbx,%rdx\n  1a:   4c 89 e6                mov    %r12,%rsi\n  1d:   4c 89 ef                mov    %r13,%rdi\n  20:   e8 6f fa ff ff          callq  0xfffffffffffffa94\n  25:   e9 d0 fe ff ff          jmpq   0xfffffffffffffefa\n  2a:*  0f 0b                   ud2         &lt;-- trapping instruction\n  2c:   48 8b 05 d1 51 77 01    mov    0x17751d1(%rip),%rax        # 0x1775204\n  33:   e9 ff fd ff ff          jmpq   0xfffffffffffffe37\n  38:   66                      data16\n  39:   66                      data16\n  3a:   2e                      cs\n  3b:   0f                      .byte 0xf\n  3c:   1f                      (bad)\n  3d:   84 00                   test   %al,(%rax)\n    ...\n\nCode starting with the faulting instruction\n===========================================\n   0:   0f 0b                   ud2\n   2:   48 8b 05 d1 51 77 01    mov    0x17751d1(%rip),%rax        # 0x17751da\n   9:   e9 ff fd ff ff          jmpq   0xfffffffffffffe0d\n   e:   66                      data16\n   f:   66                      data16\n  10:   2e                      cs\n  11:   0f                      .byte 0xf\n  12:   1f                      (bad)\n  13:   84 00                   test   %al,(%rax)\n    ...\n[  +0.000108] RSP: 0000:ffffa104c015c7f0 EFLAGS: 00010246\n[  +0.000018] RAX: ffff93e58bc98000 RBX: ffff93e58bc98000 RCX: ffff93e58bc98000\n[  +0.000017] RDX: 0000000000039962 RSI: bdd6aff4c23d967a RDI: ffff93e58bc98000\n[  +0.000017] RBP: ffffa104c015c810 R08: ffff93e58bc98000 R09: ffffa104c015c8d8\n[  +0.000018] R10: ffff93e5d302c680 R11: 0000000000000001 R12: fffffc7d8c2f2600\n[  +0.000018] R13: ffff93e6adc06bc0 R14: ffffffff99edcf25 R15: ffff93e565a70600\n[  +0.000017] FS:  000000c000580090(0000) GS:ffff93e6afac0000(0000) knlGS:0000000000000000\n[  +0.000020] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000014] CR2: 00007fac6fecf160 CR3: 000000034857c001 CR4: 0000000000760ee0\n[  +0.000026] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  +0.000018] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  +0.000021] PKRU: 55555554\n[  +0.000007] Call Trace:\n[  +0.000014]  &lt;IRQ&gt;\n[   +0.000031] skb_free_head (/usr/src/linux-source-5.4.0/net/core/skbuff.c:602)\n[   +0.000018] skb_release_data (/usr/src/linux-source-5.4.0/net/core/skbuff.c:622)\n[   +0.000015] skb_release_all (/usr/src/linux-source-5.4.0/net/core/skbuff.c:676)\n[   +0.000015] consume_skb (/usr/src/linux-source-5.4.0/net/core/skbuff.c:690 /usr/src/linux-source-5.4.0/net/core/skbuff.c:848)\n[   +0.000046] gtp5g_dev_xmit (/home/ianchen0119/gtp5g/src/gtpu/dev.c:136) gtp5g\n[   +0.000016] ? update_load_avg (/usr/src/linux-source-5.4.0/kernel/sched/fair.c:3388 /usr/src/linux-source-5.4.0/kernel/sched/fair.c:3602)\n[   +0.000017] dev_hard_start_xmit (/usr/src/linux-source-5.4.0/./include/linux/prandom.h:58 /usr/src/linux-source-5.4.0/net/core/dev.c:3216 /usr/src/linux-source-5.4.0/net/core/dev.c:3234)\n[   +0.000019] __dev_queue_xmit (/usr/src/linux-source-5.4.0/./include/net/sch_generic.h:179 /usr/src/linux-source-5.4.0/net/core/dev.c:3453 /usr/src/linux-source-5.4.0/net/core/dev.c:3765)\n[   +0.000016] ? nfnetlink_has_listeners+0x15/0x20 nfnetlink\n[   +0.000016] dev_queue_xmit (/usr/src/linux-source-5.4.0/net/core/dev.c:3834)\n[   +0.000014] neigh_direct_output (/usr/src/linux-source-5.4.0/net/core/neighbour.c:1548)\n[   +0.000019] ip_finish_output2 (/usr/src/linux-source-5.4.0/./include/net/neighbour.h:510 /usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:236)\n[   +0.000016] __ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:317)\n[   +0.000017] ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:326)\n[   +0.000018] ip_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:444)\n[   +0.000010] ? __ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:320)\n[   +0.000013] ip_forward_finish (/usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:84)\n[   +0.000012] ip_forward (/usr/src/linux-source-5.4.0/./include/linux/netfilter.h:300 /usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:157)\n[   +0.000010] ? ip4_key_hashfn (/usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:66)\n[   +0.000012] ip_sublist_rcv_finish (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:539)\n[   +0.000021] ip_sublist_rcv (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:588)\n[   +0.000956] ? ip_rcv_finish_core.isra.0 (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:407)\n[   +0.000637] ip_list_rcv (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:622)\n[   +0.000678] __netif_receive_skb_list_core (/usr/src/linux-source-5.4.0/net/core/dev.c:5014 /usr/src/linux-source-5.4.0/net/core/dev.c:5062)\n[   +0.000576] netif_receive_skb_list_internal (/usr/src/linux-source-5.4.0/net/core/dev.c:5116 /usr/src/linux-source-5.4.0/net/core/dev.c:5209)\n[   +0.000572] gro_normal_list.part.0 (/usr/src/linux-source-5.4.0/./include/linux/compiler.h:295 /usr/src/linux-source-5.4.0/./include/linux/list.h:28 /usr/src/linux-source-5.4.0/net/core/dev.c:5321)\n[   +0.000524] napi_complete_done (/usr/src/linux-source-5.4.0/net/core/dev.c:6063 (discriminator 1) /usr/src/linux-source-5.4.0/net/core/dev.c:6051 (discriminator 1))\n[   +0.000557] virtnet_poll+0x30d/0x450 virtio_net\n[   +0.000558] net_rx_action (/usr/src/linux-source-5.4.0/net/core/dev.c:6366 /usr/src/linux-source-5.4.0/net/core/dev.c:6436)\n[   +0.000598] __do_softirq (/usr/src/linux-source-5.4.0/./arch/x86/include/asm/jump_label.h:25 /usr/src/linux-source-5.4.0/./include/linux/jump_label.h:200 /usr/src/linux-source-5.4.0/./include/trace/events/irq.h:142 /usr/src/linux-source-5.4.0/kernel/softirq.c:293)\n[   +0.000559] irq_exit (/usr/src/linux-source-5.4.0/kernel/softirq.c:373 /usr/src/linux-source-5.4.0/kernel/softirq.c:413)\n[   +0.000500] do_IRQ (/usr/src/linux-source-5.4.0/arch/x86/kernel/irq.c:267 (discriminator 42))\n[   +0.000504] common_interrupt (/usr/src/linux-source-5.4.0/arch/x86/entry/entry_64.S:613)\n[  +0.000488]  &lt;/IRQ&gt;\n[  +0.000467] RIP: 0033:0x423172\n[ +0.000467] Code: 23 4c 89 44 24 38 e8 8d 46 ff ff 48 85 f6 0f 84 a0 00 00 00 48 8b 94 24 88 00 00 00 49 89 f1 48 8b 74 24 48 4d 89 c8 4d 8b 09 &lt;49&gt; 29 d0 4d 85 c9 74 b0 4d 89 ca 49 29 d1 4c 39 ce 77 a5 4c 89 44\nAll code\n========\n   0:   23 4c 89 44             and    0x44(%rcx,%rcx,4),%ecx\n   4:   24 38                   and    $0x38,%al\n   6:   e8 8d 46 ff ff          callq  0xffffffffffff4698\n   b:   48 85 f6                test   %rsi,%rsi\n   e:   0f 84 a0 00 00 00       je     0xb4\n  14:   48 8b 94 24 88 00 00    mov    0x88(%rsp),%rdx\n  1b:   00\n  1c:   49 89 f1                mov    %rsi,%r9\n  1f:   48 8b 74 24 48          mov    0x48(%rsp),%rsi\n  24:   4d 89 c8                mov    %r9,%r8\n  27:   4d 8b 09                mov    (%r9),%r9\n  2a:*  49 29 d0                sub    %rdx,%r8     &lt;-- trapping instruction\n  2d:   4d 85 c9                test   %r9,%r9\n  30:   74 b0                   je     0xffffffffffffffe2\n  32:   4d 89 ca                mov    %r9,%r10\n  35:   49 29 d1                sub    %rdx,%r9\n  38:   4c 39 ce                cmp    %r9,%rsi\n  3b:   77 a5                   ja     0xffffffffffffffe2\n  3d:   4c                      rex.WR\n  3e:   89                      .byte 0x89\n  3f:   44                      rex.R\n\nCode starting with the faulting instruction\n===========================================\n   0:   49 29 d0                sub    %rdx,%r8\n   3:   4d 85 c9                test   %r9,%r9\n   6:   74 b0                   je     0xffffffffffffffb8\n   8:   4d 89 ca                mov    %r9,%r10\n   b:   49 29 d1                sub    %rdx,%r9\n   e:   4c 39 ce                cmp    %r9,%rsi\n  11:   77 a5                   ja     0xffffffffffffffb8\n  13:   4c                      rex.WR\n  14:   89                      .byte 0x89\n  15:   44                      rex.R\n[  +0.001066] RSP: 002b:000000c000593e90 EFLAGS: 00000202 ORIG_RAX: ffffffffffffffdb\n[  +0.000517] RAX: 000000c000387200 RBX: 0000000000018e00 RCX: 5000000000000000\n[  +0.000461] RDX: 000000c000380000 RSI: 0000000000020000 RDI: 0000000000000040\n[  +0.000590] RBP: 000000c000593f08 R08: 000000c0003873d0 R09: 0000000000d17b82\n[  +0.000601] R10: 0000000000d1ce8e R11: 0000000000018e00 R12: 0000000000000001\n[  +0.000619] R13: 13679e0f6eacd19f R14: 000000c0005821a0 R15: 0000000000000000\n[  +0.000461] Modules linked in: sctp vxlan xt_multiport xt_set ipt_rpfilter iptable_raw ip_set_hash_ip ip_set_hash_net ip_set wireguard ip6_udp_tunnel veth xfrm_user xfrm_algo nf_conntrack_netlink xt_addrtype xt_nat xt_tcpudp xt_MASQUERADE xt_mark xt_conntrack iptable_mangle ip6table_filter ip6table_mangle ip6table_nat ip6_tables iptable_nat nf_nat br_netfilter bridge stp llc nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nft_counter nft_compat nf_tables nfnetlink iptable_filter xt_comment bpfilter aufs overlay dummy dm_multipath scsi_dh_rdac scsi_dh_emc scsi_dh_alua binfmt_misc intel_rapl_msr intel_rapl_common isst_if_common nfit kvm_intel kvm rapl joydev input_leds serio_raw mac_hid qemu_fw_cfg sch_fq_codel gtp5g(OE) sunrpc ramoops udp_tunnel reed_solomon efi_pstore ip_tables x_tables autofs4 btrfs zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear hid_generic usbhid hid bochs_drm drm_vram_helper ttm\n[  +0.000189]  drm_kms_helper crct10dif_pclmul crc32_pclmul syscopyarea sysfillrect ghash_clmulni_intel sysimgblt aesni_intel crypto_simd cryptd glue_helper fb_sys_fops virtio_net psmouse net_failover drm failover virtio_scsi i2c_piix4 pata_acpi floppy\n[  +0.005947] ---[ end trace e017af78fce65824 ]---\n</code></pre></p> <p>The kernel panic is caused by the kfree function, I believe that the root cause is the socket buffer double-free. Moreover, <code>gtp5g_dev_xmit</code> is the dowlink entry function in GTP5G, So I can narrow down the scope of the problem.</p> <p>For the online charging session, the FAR (Forwarding Action Rule) action will be changed to PKT_DROP after the first uplink packet be sent to data network til the UPF get the quota from SMF. So the downlink packet for responding the first uplink packet will be freed twice before UPF het the new quota.</p> <p>The deatils of the charging system design can be found at CHF design document.</p> <p>The interesting thing is that the panic won't happens til the we upgrade the gtp5g to v0.9.0^. I believe that the issue started to be visible is effected by #101, because of it gives the more accurate packet counting (timing issue).</p>"},{"location":"blog/20241224/#the-potentials-of-the-ebpf-for-kernel-debugging","title":"The potentials of the eBPF for kernel debugging","text":"<p>The article: Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module, posted by CloudFlare, has well explained how they leverage the eBPF to detect critical events in the kernel, even make the kernel more secured!</p> <p>It inspires me started thinking: is it possible to use eBPF to troubleshoot our own kernel module?</p>"},{"location":"blog/20241224/#optional-compile-the-kernel-with-btf-enabled","title":"[Optional] Compile the kernel with BTF enabled","text":"<p>In our testing environment, we build the kernel v6.12.4: <pre><code>$ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.4.tar.xz\n$ tar xvf linux-6.12.4.tar.xz\n</code></pre> Once you have downloaded the kernel source, you can started building the kernel by following the steps described in the article: Building the Linux kernel with BTF.</p>"},{"location":"blog/20241224/#what-is-btf","title":"What is BTF?","text":"<p>The Extended Berkeley Packet Filter (eBPF) is esteemed for its portability, a primary attribute of which is due to the BPF Type Format (BTF). More details about BTF can be discovered in this comprehensive guide.</p> <p>Before the advent of Compile Once-Run Everywhere (CO-RE), developers working with eBPF had to compile an individual eBPF object for each kernel version they intended to support. This stipulation led toolkits, such as iovisor/bcc, to depend on runtime compilations to handle different kernel versions.</p> <p>However, the introduction of CO-RE facilitated a significant shift in eBPF portability, allowing a single eBPF object to be loaded into multiple differing kernels. This is achieved by the libbpf loader, a component within the eBPF's loader and verification architecture. The libbpf loader arranges the necessary infrastructure for an eBPF object, including eBPF map creation, code relocation, setting up eBPF probes, managing links, handling their attachments, among others.</p> <p>Here's the technical insight: both the eBPF object and the target kernel contain BTF information, generally embedded within their respective ELF (Executable and Linkable Format) files. The libbpf loader leverages this embedded BTF information to calculate the requisite changes such as relocations, map creations, probe attachments, and more for an eBPF object. As a result, this eBPF object can be loaded and have its programs executed across any kernel without the need for object modification, thus enhancing portability. -- aquasecurity/btfhub</p>"},{"location":"blog/20241224/#generate-btf-for-gtp5g","title":"Generate BTF for GTP5G","text":"<p>Add the btf target in the Makefile like this:</p> <pre><code>diff --git a/Makefile b/Makefile\nindex bec4880..bab04d4 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -98,3 +98,6 @@ uninstall:\n        $(DEPMOD)\n        rm -f /etc/modules-load.d/gtp5g.conf\n        rmmod -f  $(MODULE_NAME)\n+\n+btf:\n+       pahole --btf_encode gtp5g.ko\n+       pahole --btf_encode gtp5g.o\n</code></pre> <p>And run the commands below:</p> <pre><code>$ make\n$ make btf\n$ readelf -S gtp5g.ko | grep BTF\n$ sudo make install\n</code></pre> <p>In this way, you will able to see the gtp5g btf by using btftool:</p> <pre><code>$ sudo bpftool btf list | grep gtp5g\n410: name [gtp5g]  size 243774B\n</code></pre> <p>use the command below to dump gtp5g BTF to C file: <pre><code>$ sudo bpftool btf dump file /sys/kernel/btf/gtp5g format c\n</code></pre></p>"},{"location":"blog/20241224/#trace-the-function-calls-in-gtp5g","title":"Trace the function calls in GTP5G","text":"<p>The eBPF program type <code>BPF_PROG_TYPE_TRACING</code> are a newer alternative to kprobes and tracepoints since Linux Kernel v5.5, which provides practically zero overhead by leveraging the BPF trampoline.</p> <p>The command below can be used to list all of available functions for tracing purpose: <pre><code>$ sudo cat /sys/kernel/tracing/available_filter_functions | grep gtp5g\n// ...\ngtp5g_dbg_read [gtp5g]\nproc_qos_write [gtp5g]\ngtp5g_qos_read [gtp5g]\ngtp5g_far_read [gtp5g]\nproc_pdr_write [gtp5g]\nproc_dbg_write [gtp5g]\ngtp5g_pdr_read [gtp5g]\nproc_qer_write [gtp5g]\nproc_far_write [gtp5g]\nproc_urr_write [gtp5g]\nget_proc_gtp5g_dev_list_head [gtp5g]\ninit_proc_gtp5g_dev_list [gtp5g]\ncreate_proc [gtp5g]\nremove_proc [gtp5g]\n</code></pre></p> <p>If we want to trace the function entry of gtp5g_encap_recv, we can write a program like below:</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf_tracing.h&gt;\n#include &lt;bpf_helpers.h&gt;\n\nSEC(\"fentry/gtp5g_encap_recv\")\nint BPF_PROG(gtp5g_recv, struct sock *sk, struct sk_buff *skb)\n{\n    if (!skb-&gt;dev) {\n        bpf_printk(\"device doesn't exist\");\n    }\n    bpf_printk(\"device name: %s\", skb-&gt;dev-&gt;name);\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n</code></pre> <ul> <li>Any program with the <code>fentry</code> prefix will be executed before the execution of target function (in this case is <code>gtp5g_encap_recv()</code>), and can be identified as the <code>BPF_PROG_TYPE_TRACING</code> type by the kernel.</li> <li>The arguments of the <code>BPF_PROG</code> follows the kernel function you want to trace. for example: <pre><code>// The definition in the gtp5g, the BPF_PROG's args should be same with the target function\nstatic int gtp5g_encap_recv(struct sock *, struct sk_buff *);\n</code></pre></li> </ul>"},{"location":"blog/20241224/#load-and-attach-ebpf-program","title":"Load and attach eBPF program","text":"<p>Typically, we can load and attach the eBPF program into specific system hook by using bpftool. However, the bpftool does not support all of attachment types provided by the kernel.</p> <p>Therefore, I use the libbpfgo and libbpf to implement the agent program for loading eBPF program: <pre><code>package main\n\nimport (\n    \"os\"\n    \"time\"\n\n    bpf \"github.com/aquasecurity/libbpfgo\"\n)\n\nfunc main() {\n    bpfModule, err := bpf.NewModuleFromFile(\"main.o\")\n    if err != nil {\n        panic(err)\n    }\n    defer bpfModule.Close()\n\n    if err := bpfModule.BPFLoadObject(); err != nil {\n        panic(err)\n    }\n\n    prog, err := bpfModule.GetProgram(\"gtp5g_recv\")\n    if err != nil {\n        panic(err)\n    }\n\n    link, err := prog.AttachGeneric()\n    if err != nil {\n        panic(err)\n    }\n    if link.FileDescriptor() == 0 {\n        os.Exit(-1)\n    }\n\n    for {\n        time.Sleep(10 * time.Second)\n    }\n}\n</code></pre></p> <p>INFO You will need to write a Makefile for building the BPF program and its agent. If you don't know how to get started, please refer to my side project: tinyLB.</p> <p>To see the output of the attached eBPF program: <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre></p>"},{"location":"blog/20241224/#conclusion","title":"Conclusion","text":"<p>This article shows how to troubleshoot the kernel panic by using the <code>decode_stacktrace.sh</code> script and how to trace the function calls in the kernel module by using eBPF. The eBPF is a powerful tool for kernel debugging. It can be used to trace the function calls in the kernel module with low overhead and even make the kernel more secure by detecting critical events.</p>"},{"location":"blog/20241224/#references","title":"References","text":"<ul> <li>https://lwn.net/Articles/592724/</li> <li>Make linux kernel function show in ftrace available_filter_function</li> <li>https://askubuntu.com/questions/1348250/skipping-btf-generation-xxx-due-to-unavailability-of-vmlinux-on-ubuntu-21-04</li> <li>https://github.com/aquasecurity/btfhub/blob/main/docs/how-to-use-pahole.md#tools-that-generate-btf-information</li> </ul>"},{"location":"blog/20241224/#about","title":"About","text":"<p>Greetings! My name is Ian. I'm currently a Technical Steering Committee member of the free5GC project. We're focusing on delevering a fully open-source 5G core network for academic and industry usage. If you're interested in our project, the pull requests and issues are always welcome!</p>"},{"location":"blog/20241230/20241230/","title":"5G Network Slicing","text":"<p>Note</p> <p>Author: Guo-Cheng Wu Date: 2024/12/30</p> <p>Network slicing is an innovative technology introduced in the 5G network, first proposed in the 3GPP Rel-15 specification. Its primary function is to support a wide range of diverse services within a single physical network. For instance, there are three major application scenarios in the 5G network: eMBB, mMTC, and URLLC. Given the varying resource requirements of these scenarios, network slicing plays a crucial role in efficiently allocating dedicated slices for each service.</p>"},{"location":"blog/20241230/20241230/#how-to-identify-a-network-slice","title":"How to Identify a Network Slice?","text":"<p>A Single Network Slice Selection Assistance Information (S-NSSAI) is used to identify a Network Slice. Each S-NSSAI consists of two parameters:</p> <ul> <li> <p>Slice/Service Type (SST): Defines the expected behavior of the Network Slice regarding features and services.</p> <ul> <li>According to the 3GPP specification, the SST values are standardized as follows:</li> </ul> Slice/Service type SST value Characteristics eMBB 1 Slice suitable for the handling of 5G enhanced Mobile Broadband. URLLC 2 Slice suitable for the handling of ultra-reliable low latency communications. MIoT 3 Slice suitable for the handling of massive IoT. V2X 4 Slice suitable for the handling of V2X services. HMTC 5 Slice suitable for the handling of High-Performance Machine-Type Communications. HDLLC 6 Slice suitable for the handling of High Data rate and Low Latency Communications. </li> <li> <p>Slice Differentiator (SD): An optional parameter that supplements the SST to distinguish between multiple Network Slices with the same Slice/Service Type.</p> </li> </ul>"},{"location":"blog/20241230/20241230/#network-slice-selection-assistance-information-nssai","title":"Network Slice Selection Assistance Information (NSSAI)","text":"<p>The NSSAI is composed of multiple S-NSSAIs and can be categorized into the following types:</p> <ul> <li>Requested NSSAI: A set of S-NSSAIs requested by the UE during connection setup, carried in the registration request sent by the UE. The Requested NSSAI can contain up to eight S-NSSAIs.</li> <li>Allowed NSSAI: A set of S-NSSAIs approved by the core network from the Requested NSSAI, which the UE can utilize in the Serving PLMN within the current Registration Area. The Allowed NSSAI can include up to eight S-NSSAIs.</li> <li>Rejected NSSAI: A set of S-NSSAIs rejected by the core network from the Requested NSSAI, often due to reasons such as the S-NSSAI being unsupported in the current registration area or unavailable due to reaching the maximum number of UEs.</li> <li> <p>Configured NSSAI: A set of S-NSSAIs provisioned in the UE by the network, applicable to one or more PLMNs, indicating which S-NSSAIs the UE is authorized to use.</p> <p>Note: If the Configured NSSAI does not contain any S-NSSAIs, a default S-NSSAI will be applied.</p> </li> </ul>"},{"location":"blog/20241230/20241230/#network-slice-selection-function-nssf","title":"Network Slice Selection Function (NSSF)","text":"<p>Before delving into the procedure of network slice selection, it is important to understand the NSSF and its functionality. The primary role of the NSSF is to assist the AMF in selecting the appropriate network slice based on the current scenario. The NSSF provides two key services:</p> <ul> <li>Nnssf_NSSelection: This service operation facilitates Network Slice selection in the Serving PLMN and the HPLMN. It enables the NSSF to provide the AMF with the Allowed NSSAI and the Configured NSSAI for the Serving PLMN. This service may be invoked during the Registration procedure, inter-PLMN mobility, PDU Session Establishment, or UE Configuration Update procedures.</li> <li>Nnssf_NSSAIAvailability: This service allows the NSSF to update the S-NSSAIs supported by the NF service consumer (e.g., AMF) on a per tracking area basis. In addition to updating and deleting operations, it also supports operations like subscribing and notifying. </li> </ul>"},{"location":"blog/20241230/20241230/#how-does-core-network-select-a-network-slice-for-ue","title":"How does Core Network Select a Network Slice for UE?","text":"<p>The process of selecting a network slice for a UE primarily involves two key network functions:</p> <ul> <li>Access and Mobility Management function (AMF): The AMF processes the registration request from the UE and forwards the Requested NSSAI to the NSSF.</li> <li>Network Slice Selection Function (NSSF): The NSSF is responsible for selecting the appropriate set of Network Slice instances to serve the UE on behalf of the AMF. Specifically, it determines the Allowed NSSAI.</li> </ul>"},{"location":"blog/20241230/20241230/#procedure","title":"Procedure","text":"<p>This section focuses specifically on the steps involved in network slice selection. For a detailed explanation of the overall 5G registration procedure, please refer to this blog: Registration procedures</p> <ol> <li>UE to RAN: The UE initiates a Registration Request to the network through the RAN. Along with UE-specific information, the request includes the Requested NSSAI, indicating the network slices the UE intends to access.</li> <li>RAN (AMF Selection): If the UE doesn't provide 5G-S-TMSI or GUAMI in the Registration Request, the RAN will select a serving AMF based on the Requested NSSAI.</li> <li>AMF to NSSF: Upon receiving the registration request, the AMF sends a request to the NSSF to execute the network slice selection process. The AMF provides detailed information such as the Requested NSSAI, the PLMN ID of the SUPI, and the TAI.</li> <li>NSSF: The NSSF performs the Nnssf_NSSelection_Get service using the information provided by the AMF. It determines which S-NSSAIs the UE is eligible to use and aggregates them into the Allowed NSSAI. In addition, the NSSF may also identify the best AMF to serve the UE or provide a list of candidate AMFs.</li> <li>NSSF to AMF: After executing the Nnssf_NSSelection_Get service, the NSSF sends the Allowed NSSAI to the AMF.</li> <li>AMF to UE: If the registration request is successful, the AMF responds to the UE with a Registration Accept message, including the Allowed NSSAI. This enables the UE to identify the network slices available for use.</li> </ol>"},{"location":"blog/20241230/20241230/#network-slice-specific-authentication-and-authorization-nssaa","title":"Network Slice-Specific Authentication and Authorization (NSSAA)","text":"<p>NSSAA is a procedure initiated by the AMF during the Registration process when certain network slices require authentication and authorization. This procedure is triggered when the AMF identifies that NSSAA is necessary for an S-NSSAI included in the current Allowed NSSAI.</p>"},{"location":"blog/20241230/20241230/#procedure_1","title":"Procedure","text":"<p>The AMF initiates a Nnssaaf_NSSAA_Authenticate request to the Network Slice-Specific and SNPN Authentication and Authorization Function (NSSAAF). The NSSAAF then forwards the request to the Authentication, Authorization, and Accounting Server (AAA Server) for authentication or authorization. Note that free5GC currently does not support this functionality. For more detailed information about the NSSAA procedure and NSSAAF service, you can refer to TS 23.502.</p>"},{"location":"blog/20241230/20241230/#conclusion","title":"Conclusion","text":"<p>Network slicing is a fundamental capability for optimizing 5G networks, allowing them to support a diverse array of services with varying resource demands. The ability to define and manage these slices is critical to meeting the diverse needs of modern network systems. It ensures efficient resource utilization, dynamic adaptability, and end-to-end isolation, delivering guaranteed performance for a wide range of use cases.</p>"},{"location":"blog/20241230/20241230/#reference","title":"reference","text":"<ul> <li>TS 23.501 </li> <li>TS 23.502</li> <li>TS 24.501</li> <li>TS 29.531</li> <li>5G Network slice management</li> <li>5G \u901a\u7528\u8a3b\u518a\u6d41\u7a0b</li> </ul>"},{"location":"blog/20241230/20241230/#about-me","title":"About me","text":"<p>Hi, I\u2019m Guo-Cheng Wu, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20241230/20241230/#connect-with-me","title":"Connect with Me","text":"<p>Github: https://github.com/leowu0407</p>"},{"location":"doc/","title":"Documents","text":""},{"location":"doc/#design-documents","title":"Design Documents","text":"<p>We maintain the design documents to help people started contributing to the free5GC, it includes the following topics: 1. Software Architecture 2. Dedicated issue and solution 3. Domain knowledges for 5GC development</p> <ul> <li>AMF</li> <li>AUSF</li> <li>SMF</li> <li>UPF (GTP5G)</li> <li>UPF (PFCP)</li> <li>CHF</li> <li>PCF (Charging)</li> <li>OAuth2 on SBI</li> <li>N3IWUE</li> <li>Problem Details</li> </ul>"},{"location":"doc/#5gc-docsspecs","title":"5GC Docs/Specs","text":"<ul> <li>Tech-invite (3GPP Specs)<ul> <li>For beginner: TS 23.501, 23.502</li> <li>NF Service: TS 29.50X</li> </ul> </li> <li>Awesome 5G</li> <li>5GC APIs</li> </ul>"},{"location":"doc/Amf/design/","title":"AMF Design Document","text":"<p>Note</p> <p>Author: TungHao Shih Date: 2024/04/25</p>"},{"location":"doc/Amf/design/#introduction","title":"Introduction","text":"<p>The Access &amp; Mobility Management Function (AMF) plays a critical role in managing User Equipment(UE) registration, connectivity, reachability, mobility. It interacts with other network functions (NF)  such as Unified Data Management (UDM), Session Management Function (SMF), and Authentication Server Function (AUSF).</p> <p>The main purpose of writing this article is to share the software architecture of how the AMF in free5GC handles UE Context Operations in AMF Communication.</p>"},{"location":"doc/Amf/design/#description","title":"Description","text":"<p>In 5G networks, UE context refers to a collection of data maintained by the Access and Mobility Management Function (AMF) about a specific User Equipment (UE). This data is essential for managing the UE's connection to the network. Namf_Communication service enables an NF to communicate with the UE through N1 NAS messages or with the AN.</p> <p>The following diagram illustrates the flow of UE Context Operations within the AMF in the free5GC implementation: </p> <p>[1] Listen and Serve : </p> <ul> <li>The AMF monitors UE Context Operations Requests from NF Service Consumers and provides a response through the ListenandServe function.</li> </ul> <p>[2] Service-based interface handler :</p> <ol> <li> <p>[2-1] UE Context Operations   :</p> <ul> <li> <p>CreateUEContext : The CreateUEContext operation is invoked by a NF Service Consumer, like a source AMF, towards the target AMF during a handover process when the source AMF cannot serve the UE. Its purpose is to establish the UE Context in the target AMF. The NF Service Consumer sends a HTTP PUT request to the target AMF, it creates the UEContext. The payload body of the PUT request should include a UeContextCreateData structure, which contains an N2 Information Notification callback URI.</p> </li> <li> <p>RegistrationStatusUpdate : The RegistrationStatusUpdate operation is invoked by a NF Service Consumer, like a target AMF, towards the source AMF. It updates the UE registration status at the target AMF, indicating the result of the previous UE Context transfer for a given UE. The NF Service Consumer, send a HTTP POST request to invoke the \"transfer-update\" custom operation on the URI of an \"Individual ueContext\" resource, to update the source AMF with the UE registration status at the target AMF.</p> </li> <li> <p>ReleaseUEContext  : The ReleaseUEContext operation is invoked by a NF Service Consumer, like a source AMF, towards the target AMF, when the source AMF receives the Handover Cancel from the 5G-AN during the handover procedure, to release the UE Context in the target AMF. The NF Service Consumer send a HTTP POST request to release the UEContext in the target AMF. The payload body of the POST request shall contain any data that needs to be passed to the target AMF. </p> </li> <li> <p>UEContextTransfer : The UEContextTransfer operation is invoked by a NF Service Consumer, like a target AMF, towards the source AMF when the target AMF receives a Registration Request with the UE's 5G-GUTI included, and the serving AMF has changed since last registration, to retrieve the UE Context. The NF Service Consumer send a HTTP POST request to invoke \"transfer\" custom method on an \"Individual ueContext\" resource URI. The payload of the request shall be an object of \"UeContextTranferReqData\" data type.</p> </li> </ul> </li> <li> <p>[2-2] EBIAssignment : </p> <ul> <li>EBIAssignment : The EBIAssignment service operation is invoked by a NF Service Consumer(such as SMF), towards the NF Service Producer(the AMF). This request asks the AMF to assign EPS bearer IDs to EPS bearers, which are mapped from QoS flows, for an existing PDU Session associated with a specific UE.</li> </ul> </li> </ol>"},{"location":"doc/Amf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Procedures for the 5G System (5GS)</li> <li>3GPP TS 23.518: Access and Mobility Management Services (5G System)</li> </ul>"},{"location":"doc/Amf/design/#about","title":"About","text":"<p>Thank you for reading. I am a member of the free5GC team. If you come across any errors in the article or have questions about the content, please feel free to reach out. Your insights and feedback are highly appreciated.</p>"},{"location":"doc/Amf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/tunghao-shih-b8a3b323b/</li> <li>Github: https://github.com/donald1218</li> </ul>"},{"location":"doc/Ausf/design/","title":"AUSF Software Architecture","text":"<p>Note</p> <p>Author: TingYuan Chou Date: 2024/03/02</p>"},{"location":"doc/Ausf/design/#introduction","title":"Introduction","text":"<p>The Authentication Server Function (AUSF) plays a critical role in the security framework of 5G networks, particularly in handling the authentication of User Equipment (UE). It serves as a central entity that facilitates the authentication process between the UE and the network, ensuring that only authorized users gain access. This process involves the generation and verification of authentication vectors, and the implementation of the 5G AKA (Authentication and Key Agreement) protocol.</p> <p>This blog aims to shed light on the software architecture surrounding the AUSF's handling of UE authentication requests. We will explore how the AUSF operates within the 5G core network, focusing on its interactions with other network functions, such as the Unified Data Management (UDM) and the Network Repository Function (NRF). Additionally, we will delve into the flow of authentication messages, the security mechanisms in place, and how the AUSF manages sessions and security contexts.</p>"},{"location":"doc/Ausf/design/#description","title":"Description","text":"<p>When the AUSF (Authentication Server Function) is initiated within a 5G network, it activates several key functionalities crucial for managing the authentication and security of User Equipment (UE). These functionalities can be broadly categorized into three main areas: Secure Communication Setup, Authentication Protocol Handling, and Service-based Interface Management. Each of these areas plays a vital role in ensuring that the AUSF effectively secures network access and communication.</p> <p>[1] Listen and Serve : </p> <ul> <li>Once the AUSF receives an authentication request, typically from the AMF (Access and Mobility Management Function) as part of the 5G security procedures, it will be processed through a secure communication channel. The AUSF listens for incoming authentication requests through its service-based interface, ensuring secure and reliable transport, often utilizing protocols like HTTPS for secure transmission over the network.</li> </ul> <p>[2] Service-based interface handler for AUSF:</p> <ol> <li> <p>[2-1] UE Authentication:</p> <ul> <li>(1) EAP-AKA :  The EAP-AKA' authentication process, as detailed in RFC 5448 and 3GPP TS 33.501, is a sophisticated mechanism designed to ensure secure communication between the User Equipment (UE) and the network. This process involves several steps, starting with the generation of an authentication vector (AV) by the Unified Data Management/Authentication Repository and Processing Function (UDM/ARPF), and culminates in the successful establishment of a secure session between the UE and the network.</li> </ul> <p></p> <p>Authentication procedure for EAP-AKA, described in 3GPP TS 33.501 clause 6.1.3.1</p> <p>The EAP-AKA' authentication sequence unfolds as follows, correlating with the sequence diagram above which is depicted in TS33.501</p> <ul> <li>Authentication Vector (AV) Creation: Initiated by the UDM/ARPF generating a tailored AV.</li> <li>AV Transmission to AUSF: The AV is sent to the AUSF, signaling readiness for authentication.</li> <li>Challenge Issuance and UE Response: The AUSF challenges the UE, which then responds, showcasing its authenticity.</li> <li>Response Verification: The AUSF verifies the UE's response, a crucial step for security.</li> <li> <p>Secure Session Establishment: Successful verification leads to establishing a secure session.</p> </li> <li> <p>(2) 5G-AKA : The 5G AKA authentication procedure enhances the security mechanisms of previous generations (EPS AKA) by incorporating additional steps and checks to verify the identity of the UE and establish a secure session. This process, as outlined in the provided diagram, includes the generation of authentication vectors, challenge and response exchanges, and the final confirmation of a successful authentication.</p> </li> </ul> <p></p> <p>Authentication procedure for 5G AKA , described in 3GPP TS 33.501 clause 6.1.3.2</p> <p>The authentication procedure unfolds as follows, aligned with the flow above which is depicted in TS33.501</p> <ul> <li>Authentication Vector (AV) Creation: The UDM/ARPF generates a 5G AV, initiating the process.</li> <li>AV Transmission to AUSF: The AV is dispatched to the AUSF to begin the authentication challenge.</li> <li>Challenge Issuance and UE Response: The AUSF challenges the UE, which must respond accurately.</li> <li>Response Verification: The AUSF verifies the UE's response, ensuring the authentication's integrity.</li> <li> <p>Secure Session Establishment: Upon successful verification, a secure session is established with the UE.</p> </li> <li> <p>(3) Post : This function handles post-authentication requests from the UE, such as re-authentication or authentication status queries. It ensures that the UE's authentication state is correctly managed throughout its network stay, facilitating continuous security assurance.</p> </li> </ul> </li> <li> <p>[2-3] Authentication Context Management : </p> <ul> <li>An essential function for retrieving the authentication context of a specific UE. This context includes the UE's authentication status, any stored vectors or keys, and the current security context. It's used by the AUSF to fetch the latest authentication information for decision-making processes, ensuring that the UE's interactions with the network remain secure and personalized. This function is vital for operations requiring an understanding of the UE's current authentication and security state, including session updates, security policy enforcement, and during handovers or network re-entries.</li> </ul> </li> </ol>"},{"location":"doc/Ausf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.509: Authentication Server Services (5G System)</li> <li>3GPP TS 33.501: Security architecture and procedures for 5G System</li> <li>LTE Authentication Introduction: EPS-AKA</li> </ul>"},{"location":"doc/Ausf/design/#about","title":"About","text":"<p>Greetings, I'm Chou, a newcomer to free5gc. I'm excited to share my experiment for the first time. If you spot any errors or have any questions, please don't hesitate to reach out. Your feedback is greatly appreciated.</p>"},{"location":"doc/Ausf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/%E5%AE%9A%E9%81%A0-%E5%91%A8-4b3800193/</li> <li>Github: https://github.com/TYuan0816</li> </ul>"},{"location":"doc/Chf/design/","title":"CHF Design Document","text":"<p>Note</p> <p>Author: Ian Chen, Andy Chen</p> <p>If you're interested in a brief overview of the charging system, please refer to the previous tech blog: link.</p> <p>The charging functionalities have been supported since free5GC v3.4.1. We implement the converged charging system (CHF) and several changes:</p> <ul> <li>Add Billing Domain in webconsole</li> <li>PCF supports to generate charging info in SM Policy decision</li> <li>SMF supports PDU-Session level Online/Offline charging</li> </ul>"},{"location":"doc/Chf/design/#usage-report","title":"Usage Report","text":"<p>Online and Offline charging rely on the usage report(s) reported from UPF to SMF via the PFCP Session Report (defined in 3GPP TS 29.244). The feature of the usage report has been supported since v3.3.0; the key points of the design are listed below:</p> <ul> <li> <p>URR's (Usage Reporting Rules) ID in the range of 1 ~ 6 is preserved for default settings:</p> <ul> <li>ID <code>1</code> for MBQE (Measurement Before QoS Enforcement) of the single UPF.</li> <li>ID <code>2</code> for MAQE (Measurement After QoS Enforcement) of the single UPF.</li> <li>ID <code>3</code> for MBQE of the branching UPF (ULCL).</li> <li>ID <code>4</code> for MAQE of the branching UPF (ULCL).</li> <li>ID <code>5</code> for MBQE of the anchor UPF (ULCL).</li> <li>ID <code>6</code> for MAQE of the anchor UPF (ULCL).</li> </ul> </li> <li> <p>Uplink and Downlink PDRs share the same URR.</p> </li> <li> <p>The URR ID of the charging URR will be 7 or greater number.</p> </li> <li> <p>If the charging method is Online Charging:</p> <ul> <li> <p>The URR has the Start of the SDF (Service Data Flow) trigger.</p> </li> <li> <p>When the UPF receives the first packet of the data flow, then UPF will send the notification to SMF to get the transmission reservation quota/volume.</p> </li> <li> <p>Once the usage reaches the threshold (a little below quota),  UPF tries to renew the reservation quota/volume and updates the actual usage to SMF. </p> </li> <li> <p>If the SMF finds out that the session is out of quota, the UPF will not get the quota, and the UPF will drop all of the data in the flow.</p> </li> <li> <p>The related settings are in the SMF configuration file: </p> <ul> <li><code>requestedUnit</code> indicates how many byte doses one reservation is reserved. </li> </ul> <pre><code>configuration:\n    smfName: SMF\n  requestedUnit: 1000 # The unit per quota reservation \n</code></pre> </li> </ul> </li> <li> <p>If the charging method is Offline Charging:</p> <ul> <li>The URR indicates the volume threshold and time period.</li> <li>Offline charging only needs UPF to report the usage of the flow. </li> <li> <p>The related settings are in the SMF configuration file: </p> <ul> <li><code>urrPeriod</code> indicates how many seconds doses URR periods.</li> <li><code>urrThreshold</code> indicates how many bytes doses URR threshold.</li> </ul> <pre><code>configuration:\n    smfName: SMF\n    urrPeriod: 10       # default usage report period in seconds\n  urrThreshold: 1000  # default usage report threshold in bytes\n</code></pre> </li> </ul> </li> </ul> <p></p> <ul> <li>Webconsole is a Billing Domain system, that can collect the CDR files from CHF via FTP protocol.</li> <li>PCF is responsible for allocating the rating group; the rating group generator is globally unique.</li> <li>SMF is CTF (Charging Trigger Function) in our use case.<ul> <li>SMF can find the rating group by using URR ID, which helps SMF grant the new quota from CHF by triggering the charging data request.</li> </ul> </li> </ul>"},{"location":"doc/Chf/design/#main-characters-in-the-charging-system","title":"Main characters in the charging system","text":""},{"location":"doc/Chf/design/#charging-on-pdu-session","title":"Charging on PDU Session","text":"<p>Although 3GPP defined the FBC (Flow-Based Charging) and QBC (QoS Flow-Based Charging), But free5GC now only supports the FBC on the data usage of PDU Session(s), So we will focus on the FBC in this document.</p> <p>2 levels of triggers can be supplied by the CHF:</p> <ul> <li>[ ] Triggers associated with the PDU session.</li> <li>[x] Triggers associated with a rating group within the PDU session.</li> </ul> <p></p> <p>PDU session establishment, described in 3GPP TS 32.255 clause 5.2.2.2.2</p> <p>Charging on PDU Session is achieved by FBC charging, with specific rating group/service identifier:</p> <ul> <li>As we mentioned, the rating group will be allocated by PCF during the SM Policy Authorization (Step 6 in the figure above).<ul> <li>PCC Rule for charging additionally indicates the rating group, SDF template, and charging method.</li> </ul> </li> <li>After the UPF selection, SMF sends the Charging Data Request to initiate the charging session and also applies the data plane rules to UPF via N4 Session Establishment/Modification.</li> <li>When the first uplink data comes to UPF, it will trigger the Charging Data Request [Update] to update the CDR file.</li> </ul>"},{"location":"doc/Chf/design/#others","title":"Others","text":"<ul> <li>For ULCL deployment, only the data usage of the PSA-UPF will be charged (it avoids charging the same data packet twice).</li> <li>In our implementations, UPF is composed of the <code>go-upf</code> (Controller) and <code>gtp5g</code> (Executor).<ul> <li><code>gtp5g</code> sends the usage report to <code>go-upf</code> via unix socket.</li> <li><code>gtp5g</code> is able to send multiple reports at once, which reduces the communication effort in UPF.</li> </ul> </li> <li>PCF Charing Design</li> </ul>"},{"location":"doc/Gtp5g/design/","title":"UPF Design Document","text":"<p>Note</p> <p>Author: HanHung Chen Date: 2024/03/13</p>"},{"location":"doc/Gtp5g/design/#introduction","title":"Introduction","text":"<p>The User Plane Function (UPF) plays a crucial role in data transfer within the 5G network. It is interconnected with the Data Network (DN) in the 5G architecture. As a primary network function (NF) of the 5G core network (5GC), it handles the most critical aspects of data processing. It is responsible for packet routing and forwarding, packet inspections, quality of service (QoS) handling, and an anchor point for intra &amp; inter-RAT mobility, with new functions on the horizon. UPF has N3, N4, N6 and N9 four interfaces. Their usages are below:</p> <ul> <li>N3: Interface between RAN and the UPF. N3 is based on the GTP-U protocol.</li> <li>N4: Interface between Session Management Function (SMF) and the UPF. N4 is based on the PFCP protocol.</li> <li>N6: Interface between DN and UPF.</li> <li>N9: Interface between two UPFs.</li> </ul> <p>The free5GC implements UPF in two parts, which are:</p> <ul> <li>Control plane: GO-UPF (N4)</li> <li>Data plane: GTP5G (N3, N6, N9)</li> </ul> <p>GTP5G is a communication protocol essential for data transmission within the 5G core network. It operates on the user plane, which is responsible for transporting user data between user equipment and the Internet.</p> <p>This article will focus on the Data plane. Discuss how GO-UPF and GTP5G  handle packets within uplink and downlink transmission.</p>"},{"location":"doc/Gtp5g/design/#data-processing-flow","title":"Data Processing Flow","text":"<p>[1] GO-UPF configuration</p> <ul> <li> <p><code>NewDriver()</code>:</p> <ul> <li>In addition to initializing a GTP5G device for handling uplink and downlink packets, it is also necessary to configure the corresponding routes for this device.</li> </ul> </li> <li> <p><code>OpenGtp5gLink()</code>:</p> <ul> <li>The function <code>OpenGtp5gLink()</code> passes the UDP Socket representing N3, accessed through <code>f.Fd()</code>, as a parameter in the <code>IFLA_LINKINFO</code> message to the gtp5g kernel module in the kernel space. The gtp5g module then uses this socket to establish a UDP tunnel for N3.</li> </ul> </li> <li><code>RouteAdd()</code>:<ul> <li>Add the corresponding route for the N6 Downlink, it indicates all of the traffic, sent to UE, will proceed by the gtp5g network device.</li> </ul> </li> </ul> <p>[2] gtp5g_init() initializes gtp5g kernel module:</p> <ul> <li> <p><code>create_proc()</code>:</p> <ul> <li>The Proc filesystem is a virtual filesystem that allows userspace programs to access kernel data structures and state.</li> </ul> </li> <li> <p><code>register_pernet_subsys()</code>:</p> <ul> <li>The <code>register_pernet_subsys()</code> function is used to register a pernet subsystem. A pernet subsystem is a framework for managing network namespaces. This allows the gtp5g module to run in different network namespaces.</li> </ul> </li> <li> <p><code>generic family</code>:</p> <ul> <li>The gtp5g_genl_family structure is used to define a generic netlink family. A generic netlink family is a way for userspace programs to communicate with the kernel.</li> </ul> </li> <li> <p><code>rtnl_link_ops</code>:</p> <ul> <li>The rtnl_link_ops structure is used to define operations related to network devices.</li> </ul> </li> </ul> <p>[3] Uplink initialization</p> <ol> <li><code>gtp5g_newlink()</code>:<ul> <li>Used to build N3 UDP tunnel and register a new gtp5g device.</li> </ul> </li> <li><code>gtp5g_encap_enable()</code>:<ul> <li>Bind UDP socket for receiving N3 packet.</li> </ul> </li> </ol> <p>[4] Uplink transmission</p> <ol> <li><code>gtp5g_encap_recv()</code>:<ul> <li>At the end of gtp5g_encap_enable function: <code>tuncfg.encap_rcv = gtp5g_encap_recv;</code> \\   it indicates that <code>gtp5g_encap_recv()</code> function is responsible for handling the UDP tunnel receiving packet.</li> </ul> </li> <li><code>gtp1u_udp_encap_recv()</code>:<ul> <li>The function handles packets encapsulated by GTP protocol. </li> </ul> </li> <li><code>netif_rx()</code>:<ul> <li>Provided by the kernel, it sends the packets through the N6 interface.</li> </ul> </li> </ol> <p>[5] Downlink initialization</p> <ol> <li><code>gtp5g_link_setup()</code>:<ul> <li>Set up net device.</li> </ul> </li> <li><code>gtp5g_netdev_ops</code>:<ul> <li>It's a structure that defines how gtp5g deals with N6 packets.</li> </ul> </li> <li><code>gtp5g_dev_init()</code>:<ul> <li>It is called after the net device is registered and initializes some of the device's status.</li> </ul> </li> </ol> <p>[6] Downlink transmission</p> <ol> <li><code>gtp5g_dev_xmit()</code>:<ul> <li>This function is defined by <code>gtp5g_netdev_ops</code> so it is called when a packet needs to be transmitted.</li> </ul> </li> <li><code>gtp5g_handle_skb_ipv4()</code>:<ul> <li>It will query the PDR based on the destination IP. If found successfully, the FAR will then be checked to determine how to handle the packet.</li> </ul> </li> <li><code>gtp5g_xmit_skb_ipv4()</code>:<ul> <li>If FAR action is confirmed as <code>FAR_ACTION_FORW</code>, the function <code>gtp5g_xmit_skb_ipv4()</code> will be called and packets will be sent to the UDP tunnel.</li> </ul> </li> </ol>"},{"location":"doc/Gtp5g/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.501: System architecture for the 5G System</li> <li>gtp5g \u539f\u59cb\u7a0b\u5f0f\u78bc\u89e3\u8aaa https://ithelp.ithome.com.tw/articles/10302887</li> </ul>"},{"location":"doc/Gtp5g/design/#about-me","title":"About me","text":"<p>Hi, I am Han-Hong Chen, a beginner to 5G and free5gc. This is my first time writing technical article. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"doc/Gtp5g/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/HanHongChen</li> </ul>"},{"location":"doc/N3IWUE/n3iwue/","title":"N3IWUE Design Document","text":"<p>Warning</p> <p>This document doesn't include all design details about N3IWUE.</p>"},{"location":"doc/N3IWUE/n3iwue/#info","title":"Info","text":"<ul> <li>GitHub Repo https://github.com/free5gc/n3iwue</li> <li>Installation Guide</li> <li>TS23.502 Procedures for Untrusted non-3GPP access</li> <li>Netlink Go Library</li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#gre-tunnels","title":"GRE Tunnels","text":"<p>Note</p> <p>Author: Andy Chen (CTFang) Date: 2024/06/12</p>"},{"location":"doc/N3IWUE/n3iwue/#gre-tunnel-spec","title":"GRE Tunnel &amp; Spec","text":"<p>Here is part of TS24.502 Access 5GCN via non-3GPP access networks spec:</p> <p>The GRE key field must use the QFI value as its key. </p> <p>N3IWUE uses the Netlink Go library to create GRE Tunnel. Here is a segment of code for the new GRE Interface. </p> <pre><code>greKeyField = (uint32(qfi) &amp; 0x3F) &lt;&lt; 24\nnewGreIfaceName := greIfaceName + \"-\" + strconv.Itoa(int(qfi))\n\n// New GRE tunnel interface\nnewGRETunnel := &amp;netlink.Gretun{\n  LinkAttrs: netlink.LinkAttrs{\n    Name: newGreIfaceName,\n    MTU:  1438, // remain for endpoint IP header(most 40 bytes if IPv6) and ESP header (22 bytes)\n  },\n  Link:   uint32(parent.Attrs().Index), // PHYS_DEV in iproute2; IFLA_GRE_LINK in linux kernel\n  Local:  ueTunnelAddr,\n  Remote: n3iwfTunnelAddr,\n  IKey:   greKeyField,\n  OKey:   greKeyField,\n}\n</code></pre> <p>And the default rule always has QFI = 1. </p>"},{"location":"doc/N3IWUE/n3iwue/#832-generic-routing-encapsulation-gre","title":"8.3.2 Generic routing encapsulation (GRE)","text":"<p>If a user data packet message is transmitted over non-3GPP access between the UE and the N3IWF for untrusted non3GPP access, the user data packet message shall be encapsulated as a GRE user data packet.</p> <p>In the GRE encapsulated user data packet:</p> <p>\u200b b) the QFI field of the key field of the GRE header field is set to the QFI associated with the user data packet;</p>"},{"location":"doc/N3IWUE/n3iwue/#procedure","title":"Procedure","text":"<p>During the N3IWUE PDU session Establishment procedure, when UE receives PDUSessionEstablishmentAccept, N3IWUE will try to do the following things: (refer to <code>n3iwue/internal/nwucp/handler/handler.go &gt; HandleDLNASTransport()</code>)</p> <ul> <li>Get PDU Address from NAS</li> <li>Setup GRE Tunnels<ul> <li>N3IWUE create per tunnel for each QFI</li> </ul> </li> <li>Add Route for GRE Tunnels <ul> <li>N3IWUE adds routes for each tunnel</li> <li>Remote IPv4 address for each QFI retrieve from NAS message</li> </ul> </li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#example-scenario","title":"Example Scenario","text":"<ul> <li>Two QoS rules<ul> <li>QFI = 2, address = 1.1.1.1</li> <li>QFI = 3, address = 8.8.8.8</li> </ul> </li> </ul> <p>So, the N3IWUE would create 3 GRE tunnels and 3 routes.</p> <p></p> <p>After the ping test, use <code>ifconfig</code> to see the status for each GRE interfaces:</p> <p></p> <ul> <li>ens18 is the only one interface on that computer </li> <li>gretun-id-2-1 for QFI = 1, receive 5 ping reply from 9.9.9.9 and send 5 ping request with some others traffics.</li> <li>gretun-id-2-2 for QFI = 2, send 5 ping request to 8.8.8.8 and receive 5 ping reply. </li> <li>gretun-id-2-3 for QFI = 3, send 5 ping request to 1.1.1.1 and receive 5 ping reply. </li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#related-pull-request","title":"Related Pull Request","text":"<p>fix: Add multiple GRE tunnel when have multiple QFI settings #7</p>"},{"location":"doc/OAuth2/OAuth2Design/","title":"free5GC OAuth2 Design","text":"<p>Note</p> <p>Author: Andy Chen (CTFang, Tsung-Fang Chen) Date: 2024/02/22</p> <p>We release OAuth2 on SBI in free5GC v3.4.0. This article shows you how we design OAuth2 in free5GC. </p> <p>This is the OAuth2 Procedure we released in the blog.</p> <p></p>"},{"location":"doc/OAuth2/OAuth2Design/#tokenkey-management","title":"Token/Key Management","text":"<ul> <li>The NRF utilizes its private key to generate tokens.</li> <li>NF Service Producers utilize the NRF's public key to validate the tokens.</li> </ul> <p>Instead of using the NF's public key to generate tokens, we opt for a simpler key management approach.</p> <p>In this design, the NRF only needs to securely store its private key, while other NFs only need to know the location of the NRF's certificate. This simplifies key management for the NRF, as it avoids the need to manage numerous NF public keys.</p>"},{"location":"doc/OAuth2/OAuth2Design/#enable-oauth2","title":"Enable OAuth2","text":""},{"location":"doc/OAuth2/OAuth2Design/#nrf","title":"NRF","text":"<ul> <li>NRF acts as the decider on whether to use OAuth2 in the service-based interface (SBI). </li> <li>First, we should set <code>oauth</code> in the NRF configuration file. </li> </ul> <pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true\n</code></pre> <ul> <li>When NFs initiate NF_Registration, then NRF would put the <code>oauth2</code> setting in <code>customInfo</code>, an element of NFProfile, back to NFs. </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#nfs","title":"NFs","text":"<p>We use part of the SMF code, for explanation. </p> <ul> <li> <p>Service Consumer</p> <ul> <li>We define <code>GetTokenCtx()</code> in each NF. </li> </ul> <pre><code>func (c *SMFContext) GetTokenCtx(serviceName models.ServiceName, targetNF models.NfType) (\n    context.Context, *models.ProblemDetails, error,\n) {\n    if !c.OAuth2Required {\n        return context.TODO(), nil, nil\n    }\n    return oauth.GetTokenCtx(models.NfType_SMF, targetNF,\n        c.NfInstanceID, c.NrfUri, string(serviceName))\n}\n</code></pre> <ul> <li> <p><code>oauth.GetTokenCtx()</code> in openapi would use the information provided by NF to get token from NRF, and return a <code>context</code> with value (token) in HTTP header. </p> </li> <li> <p>Then NFs could use this function to easily get a context with token in the header. </p> <pre><code>ctx, pd, err := smf_context.GetSelf().GetTokenCtx(models.ServiceName_NNRF_DISC, models.NfType_NRF)\nif err != nil {\n  return pd, err\n}\n\nresult, httpResp, localErr := smf_context.GetSelf().\n  NFDiscoveryClient.\n  NFInstancesStoreApi.\n  SearchNFInstances(ctx, models.NfType_UDM, models.NfType_SMF, &amp;localVarOptionals)\n</code></pre> </li> </ul> </li> <li> <p>Service Producer</p> <ul> <li> <p>Validating the access token when there is a service request, the NF must use the NRF's public key to ensure security. So, we have to tell the NF the location of the NRF certificate. (We can retrieve the Public key from the certificate). <pre><code>configuration:\n  nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre></p> </li> <li> <p>We apply <code>AuthorizationCheck()</code> via <code>router.use()</code>. (Take the Nsmf_pdusession service, for example). </p> <pre><code>routerAuthorizationCheck := util_oauth.NewRouterAuthorizationCheck(models.ServiceName_NSMF_PDUSESSION)\ngroup.Use(func(c *gin.Context) {\n  routerAuthorizationCheck.Check(c, smf_context.GetSelf())\n})\n</code></pre> </li> </ul> </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#note","title":"Note","text":"<ul> <li>The OAM service currently does not enfore OAuth2.<ul> <li>The free5GC webconsole is not considered an NF in the 5G core network, but it utilizes the OAM service to access the necessary information.</li> <li>The NRF will not issue tokens to the unregisterd NFs.</li> </ul> </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#related-prsfiles","title":"Related PRs/Files","text":"<ul> <li>General functions used by all NF: openapi/oauth</li> <li>free5gc/NRF PR#27</li> <li>free5gc/free5gcPR#525</li> <li>There would be related Pull Request for each NF. </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#main-contributors","title":"Main Contributors","text":"<ul> <li>andy89923</li> <li>Ianchen0119</li> <li>swthorn</li> <li>eggegg31415</li> </ul>"},{"location":"doc/OAuth2/oauth2_enable/","title":"Enable OAuth2 on SBI","text":"<p>In this demo, we will practice:</p> <ul> <li>Enable OAuth2 on SBI</li> <li>Configuring NRF and NFs</li> </ul>"},{"location":"doc/OAuth2/oauth2_enable/#1-enable-oauth2-in-nrf","title":"1. Enable OAuth2 in NRF","text":"<p>In the NRF configuration file <code>nrfcfg.yaml</code>:</p> <p><pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true   # false\n</code></pre> Set <code>oauth</code> from <code>false</code> to <code>true</code>. </p>"},{"location":"doc/OAuth2/oauth2_enable/#2-set-nrf-certificate-path-in-each-nf","title":"2. Set NRF Certificate path in Each NF","text":"<p>In each NF configuration file, we need to specify the path to the NRF certificate.</p> <pre><code>configuration:\n    nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre> <p>If the OAuth is set to enable but there is no <code>nrfCertPem</code> set in NF, this would lead to the following error:</p> <p></p>"},{"location":"doc/OAuth2/oauth2_enable/#3-run-free5gc","title":"3. Run free5GC","text":"<p>Use <code>run.sh</code> to start 5GC.</p> <pre><code>./run.sh\n</code></pre> <p>For now, the free5GC SBI runs the service with OAuth2. </p>"},{"location":"doc/OAuth2/oauth2_enable/#note","title":"Note","text":"<p>Since the default certificates we provide in <code>cert/</code> are auto-generated by code which didn't signed by known authority,  we would lead to the following warning:</p> <p></p> <pre><code>2024-02-27T04:00:43.217044025Z [WARN][NRF][Token] Certificate verify: x509: certificate signed by unknown authority (possibly because of \"x509: invalid signature: parent certificate cannot sign this kind of certificate\" while trying to verify candidate authority certificate \"free5gc\")\n</code></pre>"},{"location":"doc/OAuth2/oauth2_enable/#appendix","title":"Appendix","text":"<ul> <li>Design Document</li> </ul>"},{"location":"doc/PCF/charging/","title":"PCF Charging Software Design Architecture","text":"<p>Note</p> <p>Author: Andy Chen (CTFang) Date: 2024/05/07</p> <p>PCF:  Policy Control Function</p> <p>Relative specs:</p> <ul> <li>TS 29.507 Access and Mobility Policy Control Service</li> <li>TS 23.503 Policy and Charging Control Framework for the 5G System (5GS)</li> <li>Ts 29.513 Policy and Charging Control Signalling flows and QoS parameter mapping</li> <li>Ts 23.255 Telecommunication management; Charging management; 5G data connectivity domain charging </li> </ul> <p>The 3GPP defines the FBC(Flow-Based Charging) and QBC (QoS-Based Charging). </p> <p>However, free5GC v3.4.1 supports FBC only. </p>"},{"location":"doc/PCF/charging/#ratinggroup-allocate","title":"RatingGroup Allocate","text":"<p>PDU session establishment, described in 3GPP TS 32.255 clause 5.2.2.2.2</p> <p>Charging on PDU Session is achieved by FBC charging, with specific rating group/service identifier:</p> <ul> <li> <p>The rating group would be allocated by PCF during SM Policy Authorization (Step 6).</p> <ul> <li>Get chargingData from MongoDB collection <code>policyData.ues.chargingData</code>.</li> <li>Allocate rating group to each charging rule.</li> <li>Create new chargingData with rating group in MongoDB. </li> <li>Create PCC Rule for charging with rating group, SDF template, and charging method.</li> <li>Make Decision from PCC Rule to SMF. </li> </ul> </li> <li> <p>When PCF <code>HandleDeleteSmPolicyContextRequest</code>, the new chargingData with rating group would be deleted. </p> </li> </ul>"},{"location":"doc/PCF/charging/#chf","title":"CHF","text":"<p>CHF would use rating group from MongoDB (<code>policyData.ues.chargingData</code>) to calculate the usage and grant quota. </p> <ul> <li>ABMF (Account Balance Management Function)</li> <li>Rating Function</li> </ul> <p></p>"},{"location":"doc/PCF/charging/#others","title":"Others","text":"<ul> <li>CHF design document</li> </ul>"},{"location":"doc/Smf/design/","title":"SMF PFCP Software Architecture","text":"<p>Note</p> <p>Author: MingHsien Wu Date: 2024/02/09</p>"},{"location":"doc/Smf/design/#introduction","title":"Introduction","text":"<p>Packet Forwarding Control Protocol(PFCP) is a communication protocol used in N4 interface of 5G core network. It is responsible for managing and controlling packet forwarding including functions such as traffic routing, Qos policy and session management. Typically, PFCP operates between control plane (SMF) and data plane (UPF), facilitating the exchange of control information and configuration commands.</p> <p>The main focus of this blog is to share the software architecture diagram detailing how the PFCP server handles PFCP messages within the SMF. It will commence from the activation of the Network Function. Next, we will consider how free5GC operates in the software layer when receiving PFCP messages from the UPF and when the SMF needs to send PFCP requests.</p>"},{"location":"doc/Smf/design/#description","title":"Description","text":"<p>When SMF is started, several software functionalities related to PFCP are activated. I mainly categorize them into three major directions: UDP (User Datagram Protocol) Run, N4 Interface Association, and Service-based interface handler (including PDU Session and Callback).</p> <p>[1] UDP Run : </p> <ol> <li> <p>Read UDP msg from server until process exited :</p> <ul> <li>When the PFCP Server receives a PFCP Request from the User Plane, the Server will hand over this message to the Dispatcher for processing, with the aim of generating the corresponding Response.</li> </ul> </li> <li> <p>Listen and Serve : </p> <ul> <li>Once the PFCP Server receives a PFCP Request from the Control Plane or User Plane, it will be monitored via ListenAndServe function. Depending on the circumstances, it will determine whether to pass it to the Dispatcher or the SMF\u2019s sbi for handling.</li> </ul> </li> </ol> <p>[2] N4 Interface Association : </p> <ul> <li>The N4 interface association is used to maintain and verify the connectivity between the SMF and UPF. When either the SMF or UPF is first initialized, typically one of them will initiate an N4 association setup request. Subsequently, the SMF will initiate a Heartbeat Procedure to confirm whether the UPF is operational. If the UPF has not established an association with the SMF, the SMF will not process any PFCP Requests related to this UPF.</li> </ul> <p>[3] Service-based interface handler :</p> <ol> <li> <p>[3-1] Callback :</p> <ul> <li>The SMF (Subscriber) requests the establishment of an SM Policy association with the PCF (SBI). When subscription conditions are met (such as policy updates), the PCF will actively notify the SMF. Upon receiving this information, the SMF will also update the UPF according to the new policy.</li> </ul> </li> <li> <p>[3-2] PDU Session :</p> <ul> <li> <p>(1) Release : When the Service Management Function (SMF) receives a PDU Session Release SMContext Request from the Access and Mobility Management Function (Possible scenarios include: AMF changes, an invalid SUPI from the UE, or the UE registering repetitively with the same AMF, etc.), The SMF will send an PFCP Session Deletion Request towards the User Plane Function (UPF) to release resources associated with this session.</p> </li> <li> <p>(2) Update : When the Service Management Function (SMF) receives a PDU Session Update SMContext Request from the Access and Mobility Management Function for updating N3 tunnel information (Possible scenarios include: EPS to 5GS handover TS23.502, etc.), The SMF will send an PFCP Session Modification Request towards the User Plane Function (UPF) to update resources associated with this session.</p> </li> <li> <p>(3) Post : When the Service Management Function (SMF) receives a PDU Session Create SMContext Request from the Access and Mobility Management Function (Possible scenarios include: UE Requested PDU Session Establishment), The SMF will send an PFCP Session Establishment Request towards the User Plane Function (UPF). If the SMF received Nsmf_PDUSession_CreateSMContext Request and the SMF is able to process the PDU Session establishment request, the SMF creates an SM context and responds to the AMF by providing an SM Context Identifier. TS23.502</p> </li> </ul> </li> <li> <p>[3-3] ULCL Procedure : </p> <ul> <li>The insertion of ULCL (Uplink Control Channel) in 5G networks serves the purpose of facilitating the transmission of control information during uplink data transfer. ULCL enables the network to transmit control signals and indications during uplink transmission, effectively managing and controlling the allocation and scheduling of wireless resources. This includes transmitting scheduling information, establishing and releasing connections, modulation and coding information, among others, to ensure efficient control and management of uplink data transmission from user equipment.</li> </ul> </li> </ol>"},{"location":"doc/Smf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Procedures for the 5G System (5GS)</li> <li>3GPP TS 29.244: Interface between the Control Plane and the User Plane nodes</li> </ul>"},{"location":"doc/Smf/design/#about","title":"About","text":"<p>Hello, I'm Hsien, a newcomer to free5gc. This is my first time sharing my experiment. If you find any mistakes or have any questions, please feel free to let me know. I would greatly appreciate it.</p>"},{"location":"doc/Smf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/wuminghsien/</li> <li>Github: https://github.com/ming-hsien</li> </ul>"},{"location":"doc/Upf_PFCP/design/","title":"PFCP Software Architecture within UPF","text":"<p>Note</p> <p>Author: Ian Cai Date: 2024/03/20</p>"},{"location":"doc/Upf_PFCP/design/#introduction","title":"Introduction","text":"<p>The evolution of mobile networks towards 5G introduces the concept of Control and User Plane Separation. This separation aims to improve scalability, flexibility, and performance by isolating control functions (managing network resources and connections) from user plane functions (processing and forwarding user data). However, for optimal network operation, these separated planes still need to communicate effectively.</p> <p>This communication need is addressed by the Packet Forwarding Control Protocol (PFCP). PFCP acts as a dedicated signaling protocol that sits on top of the UDP/IP transport layer, operating exclusively within the control plane. It facilitates communication between a Control Plane Node, typically the Session Management Function (SMF), and one or more User Plane Nodes, such as User Plane Function (UPF).</p> <p>PFCP empowers SMFs to establish associations with UPFs, essentially creating control paths for directing user data traffic. Following association, SMF leverage PFCP to configure Packet Data Unit (PDU) sessions within the UPF. These PDU sessions dictate how user data should be processed and forwarded across the network.</p>"},{"location":"doc/Upf_PFCP/design/#processing-procedure","title":"Processing Procedure","text":"<p>The following diagram illustrates the flow of PFCP message processing within the UPF in the free5gc implementation: </p> <p>The <code>app.Run</code> function in the free5gc UPF codebase initiates two key processes:</p> <ul> <li> <p>Data Plane Forwarder for GTP-U: This process establishes a data path for forwarding user data packets between the UPF and the UE (User Equipment) via the GTP-U (GPRS Tunneling Protocol User Plane) protocol.</p> </li> <li> <p>PFCP Server: This process establishes a control plane connection with the SMF  using the PFCP protocol.</p> </li> </ul>"},{"location":"doc/Upf_PFCP/design/#pfcp-server","title":"PFCP server","text":"<p>The <code>pfcp.Start</code> function in the free5gc UPF codebase initiates the PFCP server and establishes a listening UDP socket for receiving PFCP messages from the SMF. The <code>pfcp.main</code> function uses the golang select statement to monitor three channels: </p> <ol> <li>session report: The <code>pfcp.NotifySessReport</code> function is called by the SMF to send session report through this channel</li> <li>receive packet: The <code>pfcp.receiver</code> function parses the UDP message and then sends the data through this channel.</li> <li>transaction timeout:Any packet sent by UPF will start a timeout timer, when timer expires\uff0c<code>pfcp.NotifyTransTimeout</code> will send a signal through this channel to trigger re-transmission.</li> </ol>"},{"location":"doc/Upf_PFCP/design/#association-request","title":"Association Request","text":"<p>When the UPF  receives an association request sent by the SMF,the <code>pfcp.main</code> function calls <code>pfcp.reqDispatcher</code>. This dispatcher assigns <code>pfcp.handleAssociationSetupRequest</code> to handle it. <code>pfcp.handleAssociationSetupRequest</code> verifyies the  address in the request and adds it to the \"remote note list\"before sending response to the SMF.</p>"},{"location":"doc/Upf_PFCP/design/#pdu-session-request","title":"PDU Session Request","text":"<p>Since the procedures for PDU session modification and deletion are similar to the establishment procedure, I'll use the establishment process as an example to illustrate the overall flow.</p> <p>When the UPF  receives an PDU session extablishment request sent by the SMF,the <code>pfcp.main</code> function calls <code>pfcp.reqDispatcher</code>. This dispatcher assigns <code>pfcp.handleSessionEstablishmentRequest</code> function to handle it. The function  <code>pfcp.handleSessionEstablishmentRequest</code> first checks whether the remote node ID has been associated with UPF, then proceeds to use the F-SEID in the request to create a PDU session in UPF control plane. Afterwards, the UPF begins creating PDU session in the data plane, by transferring information elements from the PFCP message, such as QER, FAR, and PDR, to the kernel module gtp5g. Taking QER as example, UPF call <code>pfcp.CreateQER</code>, which then calls <code>forwarder.CreateQER</code> with the purpose of providing the GTP-U driver with the QER value. Subsequently, forwarder.CreateQER utilizes the <code>gtp5gnl.CreateQEROID</code> function to establish a link with the go-gtp5gnl library. The handler within go-gtp5gnl interacts with the gtp5g module in the kernel through Linux netlink to inject the QER data. This procedure enables the data plane to enforce QoS rules within the PDU session.</p>"},{"location":"doc/Upf_PFCP/design/#reference","title":"Reference","text":"<p>3GPP TS 29.244 : Interface between the Control Plane and the User Plane nodes</p>"},{"location":"doc/Upf_PFCP/design/#about-me","title":"About Me","text":"<p>I'm a graduate student at NYCU studying 5G core networks. As I'm a beginner in this field, I'd be grateful for any advice you can offer.</p> <ul> <li>GitHub: https://github.com/ian60509</li> </ul>"},{"location":"guide/","title":"Index","text":""},{"location":"guide/#user-guide","title":"User Guide","text":""},{"location":"guide/#information","title":"Information","text":"<ul> <li>Tested hardware</li> <li>Supported features</li> <li>How to contribute</li> </ul>"},{"location":"guide/#free5gc-installation-guide","title":"free5GC Installation Guide","text":"<p>Note</p> <p>If you have to develop a new feature on free5GC, please check the links below to install the free5GC. Otherwise, for normal use/test purposes, we recommend you use the free5GC Compose to launch the free5GC without complicated configuration settings.</p>"},{"location":"guide/#recommended-free5gc-compose","title":"[Recommended] free5GC compose","text":"<ul> <li>Installing free5GC Core Network with free5GC-Compose</li> </ul>"},{"location":"guide/#free5gc-helm","title":"free5GC Helm","text":"<ul> <li>free5GC Helm Installation</li> </ul>"},{"location":"guide/#advanced-build-free5gc-from-scratch","title":"[Advanced] Build free5GC from scratch","text":"<p>For people who are not familiar with virtual machines and Linux installation, here are some example demonstrations:</p> <ul> <li>Creating a Ubuntu VM using VirtualBox</li> <li>Creating and Configuring a free5GC VM</li> <li>Build and Install free5GC from source code and Test free5GC</li> <li>Installing a UE/RAN Simulator</li> <li>Installing a N3IWUE</li> <li>Installing a TNGFUE</li> <li>Enable OAuth2 on SBI</li> <li>free5GC Simple Apps</li> </ul>"},{"location":"guide/#configuration","title":"Configuration","text":"<ul> <li>Environment</li> <li>Basic</li> <li>SMF</li> <li>Webconsole</li> <li>Charging</li> <li>Set Static IP for UE</li> <li>Select UPF based on S-NSSAI</li> <li>Select nearby UPF according to the connected gNodeB</li> <li>ULCL</li> <li>Netns5g - A free5gc and UERANSIM deployment using Linux network namespaces</li> <li>Traffic Influence</li> </ul>"},{"location":"guide/#deployment","title":"Deployment","text":"<p>For Container deployment:</p> <ul> <li>free5GC Compose (Docker Compose)</li> <li>free5GC Helm (Kubernetes)</li> <li>Towards5gs-helm (Kubernetes)<ul> <li>Deploying free5GC on Kubernetes by Danilo Granados</li> <li>Deploying free5GC in a multi-cluster Environment by Danilo Granados</li> </ul> </li> </ul>"},{"location":"guide/#roadmap","title":"Roadmap","text":"<p>Here are the features on the roadmap. These items are planned to be supported in the near future:</p> <ul> <li>Kubernetes deployment (quick installation)</li> <li>SBI R17 support</li> <li>Packet Rusher CI integration</li> <li>NR-DC</li> <li>Roaming</li> <li>5G LAN</li> </ul> <p>If you're interested in more details, please visit the GitHub Dashboard</p>"},{"location":"guide/#others","title":"Others","text":"<ul> <li>Release Note</li> <li>Trouble Shooting</li> <li>Appendix</li> </ul>"},{"location":"guide/0-compose/","title":"0 compose","text":"<p>free5GC compose is a docker compose version of free5GC for stage 3. It's inspired by free5gc-docker-compose and also reference to docker-free5gc.</p>"},{"location":"guide/0-compose/#prerequisites","title":"Prerequisites","text":"<ul> <li>GTP5G kernel module: needed to run the UPF</li> <li>Docker Engine: needed to run the Free5GC containers</li> <li>Docker Compose v2: needed to bootstrap the free5GC stack</li> </ul> <p>Note: AVX for MongoDB: some HW does not support MongoDB releases above<code>4.4</code> due to use of the new AVX instructions set. To verify if your CPU is compatible you can check CPU flags by running <code>grep avx /proc/cpuinfo</code>. A workaround is suggested here.</p>"},{"location":"guide/0-compose/#start-free5gc","title":"Start free5GC","text":"<p>Because we need to create tunnel interface, we need to use privileged container with root permission.</p>"},{"location":"guide/0-compose/#pull-docker-images-from-docker-hub","title":"Pull docker images from Docker Hub","text":"<pre><code>docker compose pull\n</code></pre>"},{"location":"guide/0-compose/#optional-build-docker-images-from-local-sources","title":"[Optional] Build docker images from local sources","text":"<pre><code># Clone the project\ngit clone https://github.com/free5gc/free5gc-compose.git\ncd free5gc-compose\n\n# clone free5gc sources\ncd base\ngit clone --recursive -j `nproc` https://github.com/free5gc/free5gc.git\ncd ..\n\n# Build the images\nmake all\ndocker compose -f docker-compose-build.yaml build\n\n# Alternatively you can build specific NF image e.g.:\nmake amf\ndocker compose -f docker-compose-build.yaml build free5gc-amf\n</code></pre> <p>Note:</p> <p>Dangling images may be created during the build process. It is advised to remove them from time to time to free up disk space.</p> <pre><code>docker rmi $(docker images -f \"dangling=true\" -q)\n</code></pre>"},{"location":"guide/0-compose/#run-free5gc","title":"Run free5GC","text":"<p>You can create free5GC containers based on local images or docker hub images:</p> <pre><code># use local images\ndocker compose -f docker-compose-build.yaml up\n# use images from docker hub\ndocker compose up # add -d to run in background mode\n</code></pre> <p>Destroy the established container resource after testing:</p> <pre><code># Remove established containers (local images)\ndocker compose -f docker-compose-build.yaml rm\n# Remove established containers (remote images)\ndocker compose rm\n</code></pre>"},{"location":"guide/0-compose/#troubleshooting","title":"Troubleshooting","text":"<p>Sometimes, you need to drop data from DB:</p> <pre><code>docker exec -it mongodb mongo\n&gt; use free5gc\n&gt; db.dropDatabase()\n&gt; exit # (Or Ctrl-D)\n</code></pre> <p>You can see logs for each service using <code>docker logs</code> command. For example, to access the logs of the SMF you can use:</p> <pre><code>docker logs smf\n</code></pre> <p>Please refer to the wiki for more troubleshooting information.</p>"},{"location":"guide/0-compose/#integration-with-external-gnbue-simulators","title":"Integration with external gNB/UE simulators","text":"<p>The integration with the UERANSIM eNB/UE simulator is documented here. </p> <p>You can also refer to this issue to find out how you can configure the UPF to forward traffic between the UERANSIM to the DN (eg. internet) in a docker environment.</p> <p>This issue provides detailed steps that might be useful.</p>"},{"location":"guide/0-compose/#integration-of-webui-with-nginx-reverse-proxy","title":"Integration of WebUI with Nginx reverse proxy","text":"<p>Here you can find helpful guidelines on the integration of Nginx reverse proxy to set it in front of the WebUI: https://github.com/free5gc/free5gc-compose/issues/55#issuecomment-1146648600</p>"},{"location":"guide/0-compose/#vagrant-box-option","title":"Vagrant Box Option","text":"<p>For Linux kernel version below 5.4 you can setup a working environment using a vagrant box: https://github.com/abousselmi/vagrant-free5gc Please refer to GTP5G kernel module for more information.</p>"},{"location":"guide/0-compose/#ulcl-configuration","title":"ULCL Configuration","text":"<p>You can check the following informations below:</p> <ul> <li>ulcl-example branch, or</li> <li>patch file</li> </ul>"},{"location":"guide/0-compose/#optional-run-n3iwue","title":"[Optional] Run N3IWUE","text":"<p>If you want use N3IWUE, you need to open your web browser from your host machine, and enter the URL <code>http://localhost:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button<ul> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Make sure the following config between <code>free5gc-compose/config/n3uecfg.yaml</code> and <code>Subscriber</code> you create are the same:<ul> <li>PLMNID (ex. 208930000001234)</li> <li>K</li> <li>SQN</li> <li>OP value (choose OP instead of OPC)</li> </ul> </li> <li>Scroll all the way down and click on <code>Submit</code>.</li> </ul> </li> </ul> <p>Then you can access the N3IWUE container and run N3IWUE using the following commands: <pre><code># access N3IWUE bash\ndocker exec -it n3iwue bash\n\n# run N3IWUE\n./run.sh\n</code></pre></p>"},{"location":"guide/1-vm-en/","title":"1 vm en","text":""},{"location":"guide/1-vm-en/#ubuntu-virtual-machine-installation-demo","title":"Ubuntu Virtual Machine Installation Demo","text":"<p>In this demo, we will</p> <ul> <li>Install VirtualBox</li> <li>Create a Ubuntu Server VM using VirtualBox</li> <li>Use SSH to connect to the Ubuntu VM to install free5GC stage 3</li> <li>Update and upgrade Ubuntu</li> </ul>"},{"location":"guide/1-vm-en/#1-install-virtualbox","title":"1. Install VirtualBox","text":"<p>Search <code>virtualbox download</code>, or visit virtualbox.org to download and install VirtualBox (currently 7.0.12) for your operational system. </p> <p>Once VirtualBox is installed, launch it and see if you have something like this: </p>"},{"location":"guide/1-vm-en/#2-download-ubuntu-server","title":"2. Download Ubuntu Server","text":"<p>Search <code>ubuntu server download</code> on the web and download the latest Ubuntu Server 20.04 LTS, or visit ubuntu.com, choose Manual Installation Option to download the <code>.iso</code> file (currently 20.04.6 LTS) </p> <p>You should have downloaded a <code>.iso image</code> file with a name like <code>ubuntu-20.04.6-live-server-amd64.iso</code>, probably in your download directory. </p>"},{"location":"guide/1-vm-en/#3-create-a-ubuntu-server-vm","title":"3. Create a Ubuntu Server VM","text":"<p>Launch VirtualBox and create your first Ubuntu VM using the downloaded .iso image file. We use Ubuntu Server instead of Ubuntu Desktop because we only need a basic server machine without too many unnecessary functionalities. The resulting overhead to your host machine is smaller, and the VM starts up faster too.</p> <p>Tips</p> <ul> <li>Name the first VM using a generic name as ubuntu, <code>ubuntu-server</code>, or <code>ubuntu-20.04</code>.</li> <li>You can pick 1 or 2 (or more) CPUs, and about 2048MB memory, although you can change them later.</li> <li>In addition to the default NAT network interface, add also another \u201cHost-only\u201d network interface.</li> </ul> <p>Refer to the videos Creating VM, Setting up VM.</p>"},{"location":"guide/1-vm-en/#31-start-installing-ubuntu","title":"3.1 Start Installing Ubuntu","text":"<p>Some notes about installing Ubuntu:</p> <ul> <li>It's recommended that you choose short username and password for ease of typing later</li> <li>Not choosing LVM will make it a little bit easier later if you want to extend your disk space</li> <li>Choose to include SSH Server</li> <li>Let the security update complete</li> </ul> <p>Refer to videos Install Ubuntu 1, Install Ubuntu 2.</p>"},{"location":"guide/1-vm-en/#32-log-in-to-ubuntu","title":"3.2 Log in to Ubuntu","text":"<p>Reboot after Ubuntu installation is finished then wait a little bit for some initialization steps to complete. Then log in with your username and password. </p> <p>First try the <code>ifconfig</code> command\uff1a <pre><code>ubuntu@ubuntu:~$ ifconfig\nCommand 'ifconfig' not found, but can be installed with:\nsudo apt install net-tools\nubuntu@ubuntu:~$\n</code></pre></p> <p>If some messages like above show, it means <code>ifconfig</code> has not been installed yet. (<code>ifconfig</code> is no longer installed by defaults in newer Ubuntu, and is replaced by more versatile ip command, but we will use it here for simplicity).</p> <p>Follow its suggestion and install <code>ifconfig</code>: <pre><code>ubuntu@ubuntu:~$ sudo apt install net-tools\n</code></pre> The image below shows the installation result: </p> <p>Run <code>ifconfig</code> again to check the network interfaces: </p> <p>Your display may look different, but take notes about the IP address of the Host-only interface card. The example above shows <code>192.168.56.101</code>. You can SSH from your host machine into this Ubuntu VM using the IP later. (The other IP address, <code>10.0.2.15</code> is the IP address of the NAT interface card, which means that the apps in your host machine cannot access it).</p> <p>Finally, check if the VM has internet access using: <pre><code>ubuntu@ubuntu:~$ ping google.com\n</code></pre></p> <p></p> <p>Refer to the first part of the video Ping, SSH, and Upgrade.</p>"},{"location":"guide/1-vm-en/#4-connect-to-the-ubuntu-vm-using-ssh","title":"4. Connect to the Ubuntu VM using SSH","text":"<p>Launch your favorite SSH client from the host machine. Some operational systems (Mac, Ubuntu, some Windows) have SSH clients preinstalled. If you are using Windows, you can also download third-party SSH clients, by for example, searching \u201cwindows ssh download\u201d on the web.</p> <p>The benefit of using SSH is that you can easily copy and paste commands from your machine to Ubuntu VM for execution, and vice versa. You can also create multiple SSH connections with the Ubuntu VM for control and monitoring at the same time.</p> <p>Below it's possible to see some examples on a Mac host machine. Suppose the Host-only network IP is <code>192.168.56.101</code>, and the username is <code>ubuntu</code>: <pre><code>ssh 192.168.56.101 -l ubuntu\n</code></pre> The first time you connect to the VM, your SSH client may show some message asking you for confirmation. Enter yes: </p> <p>Tips</p> <p>If somehow SSH shows some warning messages telling you the machine has potential security risk, you may have to remove an entry in the file <code>&lt;your home directory&gt;/.ssh/known_hosts</code> related the the IP address.</p> <p>If you log in successfully, you will enter a command line interface: </p> <p>Repeat the basic commands such as <code>ping</code>, <code>ifconfig</code> to see if the VM is working properly. If so, we can access the Ubuntu VM \u201cremotely\u201d from now on.</p> <p> </p>"},{"location":"guide/1-vm-en/#5-update-and-upgrade-your-ubuntu","title":"5. Update and Upgrade your Ubuntu","text":"<p>Let also update and upgrade the Ubuntu VM right now to make sure it is up-to-date with proper security updates. <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre></p>"},{"location":"guide/2-config-vm-en/","title":"2 config vm en","text":""},{"location":"guide/2-config-vm-en/#creating-a-free5gc-vm-and-setting-up-network","title":"Creating a free5GC VM and Setting up Network","text":"<p>In this demo we will exercise:</p> <ul> <li>Cloning an existing VM, and install free5GC on it</li> <li>Setting up the networking for the free5GC VM</li> </ul> <p>Tips</p> <p>Refer to video Clone VM and Change IP.</p>"},{"location":"guide/2-config-vm-en/#1-check-up-an-existing-vm-for-cloning","title":"1. Check up an existing VM for Cloning","text":"<p>Launch VirtualBox, and make sure the Ubuntu VM (ubuntu) we created before can boot up, then:</p> <ul> <li>Log in into the VM using SSH from the host machine, and check if the VM has internet access</li> <li>Make sure you have done <code>sudo apt update</code> and <code>sudo apt upgrade</code> (or you can do it again)</li> <li>Shutdown the VM. You can:</li> <li>use command <code>sudo shutdown -P now</code>, or</li> <li>click the \u201cClose Window\u201d of the Ubuntu VM terminal and choose the middle option (better not force to turn off the machine power)</li> <li>later if you just want to reboot, enter <code>sudo shutdown -r now</code></li> </ul>"},{"location":"guide/2-config-vm-en/#2-create-a-free5gc-vm","title":"2. Create a free5GC VM","text":"<p>First let\u2019s clone a new VM:</p> <ul> <li>Select an existing VM (ubuntu) and click the buttons on the right: / Snapshopts / Clone.</li> <li>Name the new VM <code>free5gc</code>.</li> <li>The MAC address rule: Create new MAC addresses for all network cards.</li> <li>Choose the Link cloning option (or you can also choose to complete clone the VM if you like).</li> </ul> <p>After the new VM is created:</p> <ul> <li>Start up the new free5gc VM, and use the same username and password to log in.</li> <li>In the Ubuntu terminal, issue <code>ping</code> and <code>ifconfig</code> again to make sure it has internet access, and also make note of the IP address of the Host-only network interface.<ul> <li>for example the IP could still be <code>192.168.56.101</code>, and the interface name is <code>enp0s8</code>.</li> </ul> </li> <li>Log in into free5gc VM using SSH, and make sure all things working properly.</li> </ul>"},{"location":"guide/2-config-vm-en/#3-change-hostname","title":"3. Change hostname","text":"<p>The cloned free5gc VM still has host name <code>ubuntu</code> (or the name you gave it in the original VM). Let\u2019s rename the VM to <code>free5gc</code>. You can do this by editing the file <code>/etc/hostname</code> (using <code>vi</code> or <code>nano</code>): <pre><code>sudo nano /etc/hostname\n# or \nsudo vi /etc/hostname\n</code></pre> In the file, change ubuntu into <code>free5gc</code>. If you are using nano \uff0cyou can press <code>Ctrl-O</code> to save the file, then <code>Ctrl-X</code> to exit.</p> <p>Let\u2019s also change the file <code>/etc/hosts</code> by replacing the ubuntu inside into <code>free5gc</code>: <pre><code>sudo nano /etc/hosts\n</code></pre></p> <p>New content of the file <code>/etc/hosts</code> looks like this: <pre><code>127.0.0.1 localhost\n127.0.1.1 free5gc\n...\n</code></pre></p> <p>The changes will take effect after next reboot.</p>"},{"location":"guide/2-config-vm-en/#4-setting-static-ip-address","title":"4. Setting Static IP Address","text":"<p>The Host-only network interface, by default, gets its IP address through DHCP. The cloned free5gc VM seems to have trouble obtaining new IP address. We can change the host-only interface to use static IP address instead, which can save a lot of trouble later.</p> <p>Here let\u2019s fix the static IP address as <code>192.168.56.101</code>: <pre><code>$ cd /etc/netplan\n$ ls\n00-installer-config.yaml\n$ cat 00-installer-config.yaml\n</code></pre> The original content of the file <code>00-installer-config.yaml</code> looks like: <pre><code># This is the network config written by 'subiquity'\nnetwork:\n  ethernets:\n    enp0s3:\n      dhcp4: true\n    enp0s8:\n      dhcp4: true\n  version: 2\n</code></pre> meaning the VM has two network interfaces. Using <code>ifconfig</code> we know that <code>enp0s8</code> is the name of the Host-only network interface. We can edit the file: <pre><code>sudo nano 00-installer-config.yaml\n</code></pre> and change it into: <pre><code># This is the network config written by 'subiquity'\nnetwork:\n  ethernets:\n    enp0s3:\n      dhcp4: true\n    enp0s8:\n      dhcp4: no\n      addresses: [192.168.56.101/24]\n  version: 2\n</code></pre> First check if the new content is correct: <pre><code>sudo netplan try\n</code></pre> Press enter to exit, if successful. The apply tne new interface setting: <pre><code>sudo netplan apply\n</code></pre> Run <code>ifconfig</code> to see if the network setting has been changed correctly: <pre><code>enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255\n        inet6 fe80::a00:27ff:fec4:254f  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:c4:25:4f  txqueuelen 1000  (Ethernet)\n        RX packets 2  bytes 1180 (1.1 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 18  bytes 1894 (1.8 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nenp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 192.168.56.101  netmask 255.255.255.0  broadcast 192.168.56.255\n        inet6 fe80::a00:27ff:fe7e:ada6  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:7e:ad:a6  txqueuelen 1000  (Ethernet)\n        RX packets 8420  bytes 531867 (531.8 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 10887  bytes 823487 (823.4 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 6621  bytes 596035 (596.0 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 6621  bytes 596035 (596.0 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> We can also check the routing table, just to have a grasp of what is going on regarding the network setting: <pre><code>$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.2.2        0.0.0.0         UG    100    0        0 enp0s3\n10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 enp0s3\n10.0.2.2        0.0.0.0         255.255.255.255 UH    100    0        0 enp0s3\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre></p> <p>For the display above, we learn that the Host-only network <code>192.168.56.0/24</code> does not have internet access by itself (even though we can access it using SSH from the host machine). Internet access is through the NAT network <code>10.0.2.0/24</code>, with the gateway being <code>10.0.2.2</code> (provided by VirtualBox). Now we can SSH into free5gc VM using <code>192.168.56.101</code>: <pre><code>ssh 192.168.56.101 -l ubuntu\n</code></pre> This is also how we interact with free5gc VM from now on.</p>"},{"location":"guide/3-install-free5gc/","title":"3 install free5gc","text":""},{"location":"guide/3-install-free5gc/#installation","title":"Installation","text":""},{"location":"guide/3-install-free5gc/#a-prerequisites","title":"A. Prerequisites","text":"<p>1. Linux Kernel Version</p> <ul> <li>In order to use the UPF element, you must use the <code>5.0.0-23-generic</code> or <code>5.4.x</code> version of the Linux kernel.  free5gc uses the gtp5g kernel module, which has been tested and compiled against that kernel versions only. If you installed Ubuntu 20.04, the version should be like 5.4.x. To determine the version of the Linux kernel you are using:</li> </ul> <pre><code>$ uname -r\n5.4.0-65-generic\n</code></pre> <p>You will not be able to run most of the tests in Test page unless you deploy a UPF.</p> <p>2. Golang Version</p> <ul> <li>As noted above, free5gc is built and tested with Go 1.21.8</li> <li> <p>To check the version of Go on your system, from a command prompt: <pre><code>go version\n</code></pre></p> </li> <li> <p>If another version of Go is installed, remove the existing version and install Go 1.21.8:</p> </li> </ul> <pre><code># this assumes your current version of Go is in the default location:\nsudo rm -rf /usr/local/go\nwget https://dl.google.com/go/go1.21.8.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.21.8.linux-amd64.tar.gz\n</code></pre> <ul> <li>If Go is not installed on your system:</li> </ul> <pre><code>wget https://dl.google.com/go/go1.21.8.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.21.8.linux-amd64.tar.gz\nmkdir -p ~/go/{bin,pkg,src}\n# The following assume that your shell is bash:\necho 'export GOPATH=$HOME/go' &gt;&gt; ~/.bashrc\necho 'export GOROOT=/usr/local/go' &gt;&gt; ~/.bashrc\necho 'export PATH=$PATH:$GOPATH/bin:$GOROOT/bin' &gt;&gt; ~/.bashrc\necho 'export GO111MODULE=auto' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <ul> <li>Further information and installation instructions for <code>golang</code> are available at the official golang site.</li> </ul> <p>3. Control-plane Supporting Packages</p> <pre><code>sudo apt -y update\nsudo apt -y install wget git\n</code></pre> <ul> <li>To check whether AVX is supported by the CPU, you can use the command: <pre><code>lscpu | grep avx\n</code></pre></li> <li>Install MongoDB Community Edition (check this appendix section for more information)<ol> <li>Import the public key used by the package management system <pre><code>sudo apt install -y gnupg curl\ncurl -fsSL https://www.mongodb.org/static/pgp/server-7.0.asc | \\\nsudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg --dearmor\n</code></pre></li> <li>Create a list file for MongoDB <pre><code># Ubuntu 22.04 (Jammy)\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n# Ubuntu 20.04 (Focal)\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n</code></pre><ul> <li>you can determine the release by running <code>cat /etc/lsb-release</code></li> </ul> </li> <li>Reload local package database &amp; Install the MongoDB packages <pre><code>sudo apt update\nsudo apt install -y mongodb-org\n</code></pre></li> <li>Run MongoDB Community Edition <pre><code># using systemd\nsudo systemctl start mongod\nsudo systemctl status mongod\nsudo systemctl enable mongod    # optional\n# using init\nsudo service mongod start\nsudo service mongod status\n</code></pre></li> </ol> </li> <li>WARNING: MongoDB 5.0+ requires a CPU with AVX support. Or downgrade your MongoDB to 4.4<ul> <li>see this post on MongoDB's official forum</li> <li>see also docker-library/mongo#485 (comment)</li> <li>When you are using <code>Ubuntu 20.04</code> and a CPU without AVX support, you can use the <code>mongodb</code> package provided by Ubuntu.  <pre><code>sudo apt install mongodb # MongoDB Server v3.6.8\n</code></pre></li> </ul> </li> </ul> <p>4. User-plane Supporting Packages</p> <pre><code>sudo apt -y update\nsudo apt -y install git gcc g++ cmake autoconf libtool pkg-config libmnl-dev libyaml-dev\n</code></pre> <p>5. Linux Host Network Settings</p> <pre><code>sudo sysctl -w net.ipv4.ip_forward=1\nsudo iptables -t nat -A POSTROUTING -o &lt;dn_interface&gt; -j MASQUERADE\nsudo iptables -A FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1400\nsudo systemctl stop ufw\nsudo systemctl disable ufw # prevents the firewall to wake up after a OS reboot\n</code></pre> <p>Or use <code>reload_host_config.sh</code> from free5GC <pre><code>sudo ./&lt;PATH-TO-free5GC&gt;/reload_host_config.sh &lt;dn_interface&gt;\n# Example\nsudo ./free5gc/reload_host_config.sh enp0s3\n</code></pre></p> <p>Note: For more information regarding the reload script, please, check this appendix section</p>"},{"location":"guide/3-install-free5gc/#b-install-control-plane-elements","title":"B. Install Control Plane Elements","text":"<ol> <li> <p>Clone the free5GC repository</p> <ul> <li> <p>To install the latest stable build (v3.4.4):</p> <pre><code>cd ~\ngit clone --recursive -b v3.4.4 -j `nproc` https://github.com/free5gc/free5gc.git\ncd free5gc\n</code></pre> </li> <li> <p>(Alternatively) to install the latest nightly build:</p> <pre><code>cd ~/free5gc\ngit checkout main\ngit submodule sync\ngit submodule update --init --jobs `nproc`\ngit submodule foreach git checkout main\ngit submodule foreach git pull --jobs `nproc`\n</code></pre> </li> </ul> </li> <li> <p>Compile network function services in <code>free5gc</code></p> <ul> <li> <p>To do so individually (e.g., AMF only):</p> <pre><code>cd ~/free5gc\nmake amf\n</code></pre> </li> <li> <p>To build all network functions:</p> <pre><code>cd ~/free5gc\nmake\n</code></pre> </li> </ul> </li> </ol>"},{"location":"guide/3-install-free5gc/#c-install-user-plane-function-upf","title":"C. Install User Plane Function (UPF)","text":"<ol> <li> <p>As noted above, the GTP kernel module used by the UPF requires that you use Linux kernel version <code>5.0.0-23-generic</code> or <code>5.4.x</code>.  To verify your version:</p> <pre><code>uname -r\n</code></pre> </li> <li> <p>Retrieve the 5G GTP-U kernel module using <code>git</code> and build it</p> <pre><code>git clone -b v0.9.5 https://github.com/free5gc/gtp5g.git\ncd gtp5g\nmake\nsudo make install\n</code></pre> </li> <li> <p>Build the UPF (you may skip this step if you built all network functions above):</p> <ul> <li> <p>to build using make:</p> <pre><code>cd ~/free5gc\nmake upf\n</code></pre> </li> </ul> </li> <li> <p>Customize the UPF as desired. The UPF configuration file in <code>run.sh</code> is <code>free5gc/config/upfcfg.yaml</code>.</p> </li> </ol>"},{"location":"guide/3-install-free5gc/#d-install-webconsole","title":"D. Install WebConsole","text":"<ol> <li> <p>Before building WebConsole, install nodejs first:</p> <pre><code>curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - \nsudo apt update\nsudo apt install -y nodejs\ncorepack enable # setup yarn automatically\n</code></pre> </li> <li> <p>Build WebConsole</p> <ul> <li> <p>to build using make:</p> <pre><code>cd ~/free5gc\nmake webconsole\n</code></pre> </li> <li> <p>(Alternatively) to build manually:</p> <pre><code>cd ~/free5gc/webconsole/frontend\nyarn install\nyarn build\nrm -rf ../public\ncp -R build ../public\ncd ..\ngo build -o bin/webconsole server.go\n</code></pre> </li> </ul> </li> </ol> <p>Note: An OS with 2GB or more of RAM is recommended. WebConsole may fail to build if available RAM is below 1GB.</p>"},{"location":"guide/4-test-free5gc/","title":"4 test free5gc","text":""},{"location":"guide/4-test-free5gc/#test-free5gc","title":"Test free5GC","text":"<p>Start a Wireshark capture on any core-connected interface, applying the filter <code>'pfcp||icmp||gtp'</code>.</p> <p>In order to run the tests, first do this:</p> <pre><code>cd ~/free5gc\nmake upf\nchmod +x ./test.sh\n</code></pre> <p>The tests are all run from within <code>~/free5gc</code>.</p> <p>a. TestRegistration</p> <pre><code>./test.sh TestRegistration\n</code></pre> <p>b. TestGUTIRegistration</p> <pre><code>./test.sh TestGUTIRegistration\n</code></pre> <p>c. TestServiceRequest</p> <pre><code>./test.sh TestServiceRequest\n</code></pre> <p>d. TestXnHandover</p> <pre><code>./test.sh TestXnHandover\n</code></pre> <p>e. TestDeregistration</p> <pre><code>./test.sh TestDeregistration\n</code></pre> <p>f. TestPDUSessionReleaseRequest</p> <pre><code>./test.sh TestPDUSessionReleaseRequest\n</code></pre> <p>g. TestPaging</p> <pre><code>./test.sh TestPaging\n</code></pre> <p>h. TestN2Handover</p> <pre><code>./test.sh TestN2Handover\n</code></pre> <p>i. TestNon3GPP</p> <pre><code>./test.sh TestNon3GPP\n</code></pre> <p>j. TestReSynchronization</p> <pre><code>./test.sh TestReSynchronization\n</code></pre> <p>k. TestULCL</p> <pre><code>./test_ulcl.sh TestRequestTwoPDUSessions\n</code></pre>"},{"location":"guide/5-install-ueransim/","title":"5 install ueransim","text":""},{"location":"guide/5-install-ueransim/#installing-ueransim-a-ueran-simulator","title":"Installing UERANSIM - a UE/RAN Simulator","text":"<p>In this demo we will practice:</p> <ul> <li>Installing UERANSIM</li> <li>Configuring free5GC and UERANSIM</li> <li>Running UERANSIM against free5GC</li> </ul>"},{"location":"guide/5-install-ueransim/#1-install-ueramsim-vm","title":"1. Install ueramsim VM","text":"<p>Repeat the steps of cloning <code>free5gc</code> VM from the base VM, create a new VM for the UERANSIM simulator:</p> <ul> <li>Name the VM <code>ueransim</code>, and create new MAC addresses for all network cards.</li> <li>Make sure the VM has internet access and can log in using SSH.</li> <li>Change the hostname to <code>ueransim</code>.</li> <li>Make the Host-only network interface have static IP address <code>192.168.56.102</code>.</li> <li>Reboot the ueransim VM, as well as the free5gc VM.</li> <li>You can ping <code>192.168.56.101</code> from the ueransim VM, and also <code>ping 192.168.56.102</code> from the free5gc VM.</li> </ul>"},{"location":"guide/5-install-ueransim/#2-install-ueransim","title":"2. Install UERANSIM","text":"<p>Search \u201cueransim\u201d on the web, and get the web site. On the web site, check what the UERANSIM open-source project is about. Then navigate to the installation page or follow the instructions below.</p> <p>To download UERANSIM: <pre><code>cd ~\ngit clone https://github.com/aligungr/UERANSIM\ncd UERANSIM\n# if using free5GC v3.3.0 or below\ngit checkout 3a96298\n# if using free5GC v3.4.0 or above\ngit checkout e4c492d\n# if using free5GC v3.4.x and to get EAP-AKA-PRIME fix\ngit checkout 85a0fbf\n</code></pre></p> <p>Update and upgrade UERANSIM VM first: <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre></p> <p>Install required tools: <pre><code>sudo apt install make\nsudo apt install g++\nsudo apt install libsctp-dev lksctp-tools\nsudo apt install iproute2\nsudo snap install cmake --classic\n</code></pre></p> <p>Build UERANSIM: <pre><code>cd ~/UERANSIM\nmake\n</code></pre></p>"},{"location":"guide/5-install-ueransim/#3-install-free5gc-webconsole","title":"3. Install free5GC WebConsole","text":"<p>free5GC provides a simple web tool WebConsole to help creating and managing UE registrations to be used by various 5G network functions (NF). </p> <p>If WebConsole isn't installed yet, please, SSH into free5gc's VM (<code>192.168.56.101</code>) and follow the instructions contained on this section here.</p>"},{"location":"guide/5-install-ueransim/#4-use-webconsole-to-add-an-ue","title":"4. Use WebConsole to Add an UE","text":"<p>First start up the WebConsole server: <pre><code>cd ~/free5gc/webconsole\n./bin/webconsole\n</code></pre></p> <p>The screen shows the port number <code>:5000</code> at the end. Open your web browser from your host machine, and enter the URL <code>http://192.168.56.101:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button<ul> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Leave the other fields unchanged. This registration data is used for ease of testing and actual use later.</li> <li>Scroll all the way down and click on <code>Submit</code>.</li> </ul> </li> <li>Once the data shows up on the \"Subscribers\" table, you can press <code>Ctrl-C</code> on the terminal to kill the WebConsole process on the free5gc VM</li> <li>You can view more tutorials through this link. </li> </ul> <p>Note</p> <p>You have to make sure that the parameters on the webconsole are consistent with the UE.</p>"},{"location":"guide/5-install-ueransim/#5-setting-free5gc-and-ueransim-parameters","title":"5. Setting free5GC and UERANSIM Parameters","text":"<p>In free5gc VM, we need to edit three files:</p> <ul> <li><code>~/free5gc/config/amfcfg.yaml</code></li> <li><code>~/free5gc/config/smfcfg.yaml</code></li> <li><code>~/free5gc/config/upfcfg.yaml</code></li> </ul> <p>First SSH into free5gc VM, and change <code>~/free5gc/config/amfcfg.yaml</code>: <pre><code>cd ~/free5gc\nnano config/amfcfg.yaml\n</code></pre></p> <p>Replace ngapIpList IP from <code>127.0.0.1</code> to <code>192.168.56.101</code>, namely from: <pre><code>...\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n  - 127.0.0.1\n</code></pre> into: <pre><code>...\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n  - 192.168.56.101  # 127.0.0.1\n</code></pre></p> <p>Next edit <code>~/free5gc/config/smfcfg.yaml</code>: <pre><code>nano config/smfcfg.yaml\n</code></pre> and in the entry inside <code>userplaneInformation / upNodes / UPF / interfaces / endpoints</code>, change the IP from <code>127.0.0.8</code> to <code>192.168.56.101</code>, namely from: <pre><code>...\n  interfaces: # Interface list for this UPF\n   - interfaceType: N3 # the type of the interface (N3 or N9)\n     endpoints: # the IP address of this N3/N9 interface on this UPF\n       - 127.0.0.8\n</code></pre> into: <pre><code>...\n  interfaces: # Interface list for this UPF\n   - interfaceType: N3 # the type of the interface (N3 or N9)\n     endpoints: # the IP address of this N3/N9 interface on this UPF\n       - 192.168.56.101  # 127.0.0.8\n</code></pre> Finally, edit <code>~/free5gc/config/upfcfg.yaml</code>\uff0cand chage gtpu IP from <code>127.0.0.8</code> into <code>192.168.56.101</code>, namely from: <pre><code>...\n  gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n      - addr: 127.0.0.8\n        type: N3\n</code></pre> into: <pre><code>...\n  gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n      - addr: 192.168.56.101  # 127.0.0.8\n        type: N3\n</code></pre></p>"},{"location":"guide/5-install-ueransim/#6-setting-ueransim","title":"6. Setting UERANSIM","text":"<p>In the ueransim VM, there are two files related to free5GC\uff1a</p> <ul> <li><code>~/UERANSIM/config/free5gc-gnb.yaml</code></li> <li><code>~/UERANSIM/config/free5gc-ue.yaml</code></li> </ul> <p>The second file is for UE, which we don\u2019t have to change if the data inside is consistent with the (default) registration data we set using WebConsole previously.</p> <p>First SSH into ueransim, and edit the file <code>~/UERANSIM/config/free5gc-gnb.yaml</code>, and change the ngapIp IP, as well as the gtpIp IP, from <code>127.0.0.1</code> to <code>192.168.56.102</code>\uff0cand also change the IP in amfConfigs into <code>192.168.56.101</code>, that is, from: <pre><code>...\n  ngapIp: 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\n  gtpIp: 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n  # List of AMF address information\n  amfConfigs:\n    - address: 127.0.0.1\n</code></pre> into: <pre><code>...\n  ngapIp: 192.168.56.102  # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\n  gtpIp: 192.168.56.102  # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n  # List of AMF address information\n  amfConfigs:\n    - address: 192.168.56.101  # 127.0.0.1\n</code></pre> Next we examine the file <code>~/UERANSIM/config/free5gc-ue.yaml</code>\uff0cand see if the settings is consistent with those in free5GC (via WebConsole), for example: <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000003'\n# Mobile Country Code value\nmcc: '208'\n# Mobile Network Code value (2 or 3 digits)\nmnc: '93'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OP'\n\n...\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n\n# List of requested S-NSSAIs by this UE\nslices:\n  - sst: 0x01\n    sd: 0x010203\n\n...\n</code></pre> The data appear to be the same as what we set in WebConsole.</p>"},{"location":"guide/5-install-ueransim/#7-testing-ueransim-against-free5gc","title":"7. Testing UERANSIM against free5GC","text":"<p>SSH into free5gc. If you have rebooted free5gc, remember to run: <pre><code>sudo sysctl -w net.ipv4.ip_forward=1\nsudo iptables -t nat -A POSTROUTING -o &lt;dn_interface&gt; -j MASQUERADE\nsudo systemctl stop ufw\n</code></pre></p> <p>Note: In Ubuntu Server 20.04 and 22.04 the dn_interface may be called <code>enp0s3</code> or <code>enp0s4</code> by default. Use the command <code>ip a</code> to help to figure it out</p> <p>In addition, execute the following command: <pre><code>sudo iptables -I FORWARD 1 -j ACCEPT\n</code></pre></p> <p>Tip: As per the information on the appendix page, it's possible to use a script to reload the config above automatically after reboot</p> <p>Also, make sure you have make proper changes to the free5GC configuration files, then run <code>./run.sh</code>: <pre><code>cd ~/free5gc\n./run.sh\n</code></pre></p> <p>At this time free5GC has been started.</p> <p>Next, prepare three additional SSH terminals from your host machine (if you know how to use <code>tmux</code>, you can use just one).</p> <p>In terminal 1: SSH into ueransim, make sure UERANSIM is built, and configuration files have been changed correctly, then execute <code>nr-gnb</code>: <pre><code>cd ~/UERANSIM\nbuild/nr-gnb -c config/free5gc-gnb.yaml\n</code></pre></p> <p>In terminal 2, SSH into ueransim, and execute <code>nr-ue</code> with admin right: <pre><code>cd ~/UERANSIM\nsudo build/nr-ue -c config/free5gc-ue.yaml # for multiple-UEs, use -n and -t for number and delay\n</code></pre></p> <p>In terminal 3, SSH into ueransim, and ping <code>192.168.56.101</code> to see free5gc is alive. Then, use ifconfig to see if the tunnel <code>uesimtun0</code> has been created (by nr-ue): <pre><code>$ ifconfig\n\nenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255\n        inet6 fe80::a00:27ff:fe65:1472  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:65:14:72  txqueuelen 1000  (Ethernet)\n        RX packets 80  bytes 32423 (32.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 90  bytes 12860 (12.8 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nenp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 192.168.56.102  netmask 255.255.255.0  broadcast 192.168.56.255\n        inet6 fe80::a00:27ff:fe5e:be64  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:5e:be:64  txqueuelen 1000  (Ethernet)\n        RX packets 1515  bytes 130490 (130.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1010  bytes 206670 (206.6 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 3445  bytes 174416 (174.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 3445  bytes 174416 (174.4 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nuesimtun0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500\n        inet 60.60.0.1  netmask 255.255.255.255  destination 60.60.0.1\n        inet6 fe80::2034:d00:a76:84b7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)\n        RX packets 3  bytes 252 (252.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 13  bytes 732 (732.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre></p> <p>Now use <code>ping</code>: <pre><code>ping -I uesimtun0 google.com\n</code></pre> If <code>ping</code> gets replies, then free5GC is running properly. Congratulations!</p>"},{"location":"guide/5-install-ueransim/#8-testing-ueransim-deregister-via-nr-cli","title":"8. Testing UERANSIM deregister via nr-cli","text":"<p>Create new terminal, use nr-cli to show the running device <pre><code>./build/nr-cli --dump\nUERANSIM-gnb-208-93-1\nimsi-208930000000001\n</code></pre></p> <p>Control <code>imsi-208930000000001</code> to send dereg normal to the free5GC <pre><code>sudo ./build/nr-cli imsi-208930000000001 --exec \"deregister normal\"\n</code></pre> And you would see the De-registration signal/logs in UE: <pre><code>[2024-05-21 08:01:57.175] [nas] [debug] De-registration required due to [NORMAL]\n[2024-05-21 08:01:57.185] [nas] [debug] Starting de-registration procedure due to [NORMAL]\n[2024-05-21 08:01:57.185] [nas] [debug] Performing local release of PDU session[1]\n[2024-05-21 08:01:57.185] [nas] [debug] Performing local release of PDU session[2]\n[2024-05-21 08:01:57.185] [nas] [info] UE switches to state [MM-DEREGISTER-INITIATED]\n</code></pre></p>"},{"location":"guide/6-simple-app/","title":"6 simple app","text":""},{"location":"guide/6-simple-app/#free5gc-simple-apps","title":"free5GC Simple Apps","text":"<p>In this demo we will use free5GC together with UERANSIM to exercise on some simple network applications:</p> <ul> <li><code>ping</code> + <code>tcpdump</code></li> <li><code>wget</code> and <code>curl</code></li> </ul>"},{"location":"guide/6-simple-app/#ping-tcpdump","title":"ping + tcpdump","text":"<p>First start up free5GC and ueransim VMs. This requires one SSH terminal for free5gc, and two for ueransim.</p> <p>Open another SSH terminal and log in into ueransim: <pre><code>ssh 192.168.56.102 -l ubuntu\n</code></pre> Use <code>ifconfig</code> to check if <code>uesimtun0</code> tunnel has been created, and use ping to check if we can <code>ping</code> through it\uff1a <pre><code>$ ping google.com\nPING google.com (172.217.27.142) 56(84) bytes of data.\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=1 ttl=63 time=3.98 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=2 ttl=63 time=3.87 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=3 ttl=63 time=4.06 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2003ms\nrtt min/avg/max/mdev = 3.872/3.970/4.060/0.076 ms\n</code></pre></p> <pre><code>$ ping -I uesimtun0 google.com\nPING google.com (172.217.27.142) from 60.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=1 ttl=61 time=5.85 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=2 ttl=61 time=4.87 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=3 ttl=61 time=4.76 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 4.760/5.160/5.847/0.487 ms\n</code></pre> <p>Also use <code>route -n</code> to observe if current routing table shows some routing rules regarding the two network interfaces <code>enp0s3</code> and <code>enp0s8</code>: <pre><code>$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.2.2        0.0.0.0         UG    100    0        0 enp0s3\n10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 enp0s3\n10.0.2.2        0.0.0.0         255.255.255.255 UH    100    0        0 enp0s3\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre></p> <p>The network <code>10.0.2.0/24</code> and its <code>enp0s3</code> interface are related to VirtualBox NAT network card. We can bring down this interface: <pre><code>$ sudo ifconfig enp0s3 down\n$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre> As shown aboe we have only Host-only network <code>192.168.56.0/24</code> left. Run <code>ping</code> again: <pre><code>$ ping 8.8.8.8\nping: connect: Network is unreachable\n</code></pre></p> <p>And see that it can not ping through, but runing: <pre><code>$ ping -I uesimtun0 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) from 60.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=61 time=7.17 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=61 time=5.41 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=61 time=5.15 ms\n^C\n--- 8.8.8.8 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2005ms\nrtt min/avg/max/mdev = 5.150/5.907/7.165/0.895 ms\n</code></pre></p> <p>shows some responses, since we ask <code>ping</code> to go through the free5GC core network. To make <code>ping 8.8.8.8</code> in addition to <code>ping -I uesimtun0 8.8.8.8</code> work, we can set the <code>uesimtun0</code> interface (IP <code>60.60.0.1</code>) as the new default gateway: <pre><code>$ sudo ip r add default dev uesimtun0\n$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 uesimtun0\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre> Now traffic not for the <code>192.168.56.0/24</code> network will go to <code>uesimtun0</code>, and <code>ping 8.8.8.8</code> works this time: <pre><code>$ ping 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=61 time=5.02 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=61 time=6.31 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=61 time=5.41 ms\n^C\n--- 8.8.8.8 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 5.017/5.581/6.312/0.541 ms\n...\n</code></pre></p> <p>Note that normally we are using ueransim to simulate \u201cterminal\u201d UE device, not as a network device or proxy, therefore the above two routing rules suffice.</p> <p>Now if we still want to run: <pre><code>$ ping google.com\nping: google.com: Temporary failure in name resolution\n</code></pre></p> <p>we will get unresolved domain name. To solve this, we can modify the file <code>/etc/resolv.conf</code>: <pre><code>sudo nano /etc/resolv.conf\n</code></pre></p> <p>and change the nameserver IP to <code>8.8.8.8</code>: <pre><code>nameserver 8.8.8.8\n</code></pre></p> <p>After the change, we can see <code>ping</code> getting responses: <pre><code>$ ping google.com\nPING google.com (216.58.200.46) 56(84) bytes of data.\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=1 ttl=61 time=5.19 ms\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=2 ttl=61 time=50.4 ms\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=3 ttl=61 time=5.66 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 5.191/20.423/50.414/21.207 ms\n</code></pre></p> <p>We can also examine the network traffic happening underneath in the scenario above. First we open another SSH terminal into ueransim, and run the following command: <pre><code>$ sudo tcpdump -n -i any host 60.60.0.1 or 192.168.56.101\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes\n</code></pre></p> <p>then run <code>ping 8.8.8.8</code> again, wait for a couple seconds, then <code>Ctrl-C</code> to exit. We see the data packets actually going in and out <code>uesimtun0</code>. <pre><code>$ sudo tcpdump -n -i any host 60.60.0.1 or 192.168.56.101\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes\n10:24:56.138729 IP 192.168.56.101.38412 &gt; 192.168.56.102.38740: sctp (1) [HB REQ]\n10:24:56.138783 IP 192.168.56.102.38740 &gt; 192.168.56.101.38412: sctp (1) [HB ACK]\n10:24:58.456532 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 1, length 64\n10:24:58.457416 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:24:58.462136 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:24:58.462324 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 1, length 64\n10:24:59.458823 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 2, length 64\n10:24:59.459031 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:24:59.464214 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:24:59.464396 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 2, length 64\n10:25:00.461293 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 3, length 64\n10:25:00.462178 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:25:00.474941 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:25:00.475561 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 3, length 64\n10:25:01.463946 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 4, length 64\n10:25:01.464523 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:25:01.469297 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:25:01.470314 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 4, length 64\n</code></pre></p>"},{"location":"guide/6-simple-app/#wget","title":"wget","text":"<p>Simply look for any web page for file download on the web. For example, if we choose Golang web site as an example, we may find the URL: <pre><code>https://golang.org/dl/go1.15.8.darwin-amd64.pkg\n</code></pre> Using the same network settings is the previous exercise, just <pre><code>wget https://golang.org/dl/go1.15.8.darwin-amd64.pkg\n</code></pre> And see if you can download a Golang 1.15.8 install file.</p>"},{"location":"guide/6-simple-app/#ptt-ssh-bbsupttcc","title":"ptt (<code>ssh bbsu@ptt.cc</code>)","text":"<p>You can actually use SSH in the ueransim VM to access remote site. For example, you can SSH to a well-known terminal-based BBS site in Taiwan: <pre><code>ssh bbsu@ppt.cc\n</code></pre></p>"},{"location":"guide/6-simple-app/#youtube","title":"Youtube","text":"<p>You can also use Youtube as an example app. To achieve this goal, you can install a desktop VM with graphical UI, such as Ubuntu Desktop, and follow the same procedure to install and start up UERANSIM, then access Youtube through <code>uesimtun0</code> and free5GC.</p> <p>To reduce resource consumption on your host machine, you may install Lubuntu (at https://lubuntu.me), a more light-weight Ubuntu desktop distro instead. But since viewing free5GC YouTube Channel requires quite sime CPU consumption, you may have to set at least 2 CPUs and 2048 MB memory for the VM.</p> <p>Refer to videos Access Youtube on Lubuntu (1, 2, 3, 4 and 5).</p>"},{"location":"guide/7-free5gc-helm/","title":"free5GC Helm Installation","text":""},{"location":"guide/7-free5gc-helm/#prerequirements","title":"Prerequirements","text":""},{"location":"guide/7-free5gc-helm/#microk8s-installation","title":"MicroK8s Installation","text":"<ul> <li>Install MicroK8s <pre><code>sudo snap install microk8s --classic --channel=1.28/stable\n</code></pre><ul> <li>Join the group <pre><code>sudo usermod -a -G microk8s $USER\nmkdir -p ~/.kube\nchmod 0700 ~/.kube\n</code></pre></li> <li>Re-enter the session <pre><code>su - $USER\n</code></pre></li> <li>Verify the Installation  <pre><code>microk8s status --wait-ready\n</code></pre></li> </ul> </li> <li>To work with local kubectl <pre><code>sudo snap install kubectl --classic\nsudo snap install helm --classic\nmicrok8s config &gt; ~/.kube/config\nsu - $USER\n</code></pre></li> <li>Create namespace for free5GC <pre><code>kubectl create ns free5gc\n</code></pre></li> </ul>"},{"location":"guide/7-free5gc-helm/#network-configuration","title":"Network configuration","text":"<ul> <li>Reference: Toward5Gs -- Network Configuration</li> <li>This Helm chart requires two network interfaces: <code>eth0</code> and <code>eth1</code><ul> <li>Both of them should have the ability to connect to the Internet</li> <li>By default, one of them (<code>eth1</code>) will be the N6 network interface</li> </ul> </li> <li>In Summary, the <code>value.yaml</code> in each configuration should be set up correctly<ul> <li>Suppose we have two NW interfaces:<ol> <li><code>eth0</code>: <code>172.19.244.39/20</code></li> <li><code>eth1</code>: <code>192.168.50.43/24</code></li> </ol> </li> <li>We take <code>eth1</code> as the interface connected to DN, the following values should be changed:<ol> <li><code>global.n6network.subnetIP</code>, <code>global.n6network.gatewayIP</code></li> <li><code>free5gc-upf.n6if.ipAddress</code></li> <li>For changing the interface, these values should be modified: <code>global.n2network.masterIf</code>, <code>global.n3network.masterIf</code>, <code>global.n4network.masterIf</code>, <code>global.n6network.masterIf</code></li> </ol> </li> <li><code>free5gc-helm/charts/free5gc/value.yaml</code> <pre><code>global:\n  n6network:\n    enabled: true\n    name: n6network\n    type: ipvlan\n    masterIf: eth1\n    subnetIP: 192.168.50.0\n    cidr: 24\n    gatewayIP: 192.168.50.1\n    excludeIP: 10.100.100.254\n</code></pre></li> <li><code>free5gc-helm/charts/free5gc/charts/free5gc-upf/values.yaml</code> <pre><code>upf:    \n    n6if:  # DN\n        ipAddress: 192.168.50.66\n</code></pre><ul> <li>When choosing \"ULCL\" architecture for the user plane, <code>n6if</code> configuration in <code>upf1</code>, <code>upf2</code>, <code>upfb</code> should also be changed to the DN interface</li> </ul> </li> <li>These values could be setup by using <code>helm install --set</code>, see helm chart installation</li> </ul> </li> </ul>"},{"location":"guide/7-free5gc-helm/#cni-plugin-configuration","title":"CNI Plugin Configuration","text":"<ul> <li>Starting from version 1.19, MicroK8s clusters use the Calico CNI by default (ref).<ul> <li>To enable IP forwarding on UPF, Calico CNI needs some necessary configurations.</li> <li>Some CNI plugin, like Flannel, kube-ovn, allow this funtionality by default</li> </ul> </li> <li>Setup Calico CNI for IP Forwarding<ol> <li><code>/var/snap/microk8s/current/args/cni-network/cni.yaml</code> <pre><code>kind: ConfigMap\ndata:\n    cni_network_config: |-\n        {\n            # ...\n            \"plugins\": [\n                {\n                    # Append IP forwarding settings\n                    \"container_settings\": {\n                        \"allow_ip_forwarding\": true\n                    },\n                }\n            ]\n        }\n</code></pre><ul> <li>Refer to the Calico CNI Docs</li> </ul> </li> <li><code>/var/snap/microk8s/current/args/kubelet</code><ul> <li>append the following line <pre><code>--allowed-unsafe-sysctls \"net.ipv4.ip_forward\"\n</code></pre></li> </ul> </li> <li>Apply settings <pre><code>kubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml\n</code></pre></li> <li>Restart MicroK8s <pre><code>microk8s stop\nmicrok8s start\n</code></pre></li> </ol> </li> <li>Otherwise, Use <code>kube-ovn</code> CNI plugin <pre><code>sudo microk8s enable kube-ovn --force\n</code></pre><ul> <li>Official doc</li> </ul> </li> </ul>"},{"location":"guide/7-free5gc-helm/#multus-cni-plugin","title":"multus-cni plugin","text":"<ul> <li>Enables attaching multiple network interfaces to pods<ul> <li>Github link</li> </ul> </li> <li>MicroK8s multus addons <pre><code>microk8s enable community\nmicrok8s enable multus\n</code></pre></li> <li>Reference Multus Guide<ol> <li>Multus - Create Network Definitions</li> <li>Multus - Tell pods to use those networks via annotations</li> </ol> </li> </ul>"},{"location":"guide/7-free5gc-helm/#installation","title":"Installation","text":""},{"location":"guide/7-free5gc-helm/#create-persistent-volumn","title":"Create Persistent Volumn","text":"<ul> <li>Use <code>kubectl apply</code> to declarative create persistent volume for mongo<ul> <li><code>kubectl apply -f persistent-vol-for-mongodb.yaml</code></li> <li><code>persistent-vol-for-mongodb.yaml</code> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: free5gc-pv-mongo\n  labels:\n    project: free5gc\nspec:\n  capacity:\n    storage: 8Gi\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: microk8s-hostpath\n  local:\n    path: &lt;/path/to/storage&gt;\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - &lt;work-node-name&gt;\n</code></pre><ul> <li>directory on <code>/path/to/storage</code> should be created previously</li> </ul> </li> </ul> </li> <li>Use <code>kubectl apply</code> to declarative create persistent volume for <code>nrf.pem</code><ul> <li><code>kubectl apply -f persistent-vol-for-cert.yaml</code></li> <li><code>persistent-vol-for-cert.yaml</code> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: free5gc-pv-cert\nlabels:\n    project: free5gc\nspec:\ncapacity:\n    storage: 2Mi\naccessModes:\n- ReadOnlyMany\npersistentVolumeReclaimPolicy: Retain\nstorageClassName: microk8s-hostpath\nlocal:\n    path: &lt;/path/to/storage&gt;\nnodeAffinity:\n    required:\n    nodeSelectorTerms:\n    - matchExpressions:\n        - key: kubernetes.io/hostname\n        operator: In\n        values:\n        - &lt;work-node-name&gt;\n</code></pre><ul> <li>directory on <code>/path/to/storage</code> should be created previously</li> </ul> </li> </ul> </li> <li>Check persistent volume <pre><code>kubectl get persistentvolume\n</code></pre></li> </ul>"},{"location":"guide/7-free5gc-helm/#helm-chart","title":"Helm Chart","text":"<ul> <li>Clone the repository <pre><code>git clone https://github.com/free5gc/free5gc-helm.git\n</code></pre></li> <li>Enter the directory: <code>free5gc-helm/charts/</code></li> <li>free5GC <pre><code>helm install -n free5gc free5gc-helm ./free5gc/ \n</code></pre><ul> <li>Install with customized interface settings <pre><code>helm install -n free5gc free5gc-helm ./free5gc/ \\\n--set global.n6network.subnetIP=\"192.168.50.0\" \\\n--set global.n6network.gatewayIP=\"192.168.50.1\" \\\n--set free5gc-upf.upf.n6if.ipAddress=\"192.168.50.66\"\n</code></pre></li> </ul> </li> <li>UERANSIM <pre><code>helm install -n free5gc ueransim ./ueransim/ \n</code></pre></li> <li>Verification<ul> <li>List installed charts <pre><code>helm ls -A\n</code></pre></li> <li>Check services, pods, repicaets, and deployments  <pre><code>kubectl get all -n free5gc \n</code></pre></li> </ul> </li> <li>Check IP forwarding is avalible in upf <pre><code>kubectl exec -it -n free5gc deployment/free5gc-helm-free5gc-upf-upf \\\n-- cat /proc/sys/net/ipv4/ip_forward\n</code></pre><ul> <li>This output should be <code>1</code></li> </ul> </li> <li>Result </li> </ul>"},{"location":"guide/7-free5gc-helm/#test","title":"Test","text":"<ul> <li>Add subscribors via webui<ol> <li>Port forwarding  <pre><code>kubectl port-forward svc/webui-service 5000:5000  --address 0.0.0.0\n</code></pre></li> <li>access <code>&lt;externel_ip&gt;:5000</code> </li> </ol> </li> <li>Ping externel network with tunnel  <pre><code>kubectl exec -it -n free5gc deployment/ueransim-ue \\\n-- ping -I uesimtun0 8.8.8.8\n</code></pre> </li> </ul>"},{"location":"guide/8-traffic-influence/","title":"Influence Traffic Routing","text":"<ul> <li>The SMF may control the data path of a PDU Session so that the PDU Session may simultaneously correspond to multiple N6 interfaces.</li> <li>We have provided some smaple scripts under the free5gc-compose, you can test the content in this note with <pre><code>sudo docker run --rm --network &lt;free5gc-nw-name&gt; \\\n    -v \"$(pwd):/mnt\" -w /mnt curlimages/curl &lt;script.sh&gt;\n</code></pre></li> </ul>"},{"location":"guide/8-traffic-influence/#influence-traffic-routing-by-udr","title":"Influence traffic routing by UDR","text":"<ul> <li>Traffic routing can be triggered by storing/updating/removing the information in UDR.</li> </ul>"},{"location":"guide/8-traffic-influence/#example-usage-of-traffic-influence","title":"Example usage of traffic influence","text":"<ul> <li>In the free5gc-compose, we have a compose file for ulcl, with two default UPFs: I-UPF and PSA-UPF.</li> <li> <p>Suppose that we want to let mec traffic go through the I-UPF, others go through the PSA-UPF.</p> Others (Default) MEC (after TI) </li> <li> <p>We could put the influence data to UDR, triggering traffic influence process and influence the traffic routing.</p> <ul> <li>Sample traffic influence data: <code>ti_data.json</code> <pre><code>{\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"interGroupId\": \"AnyUE\",\n    \"trafficFilters\": [\n    {\n        \"flowId\": 1,\n        \"flowDescriptions\": [\n            \"permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\"\n        ]\n    }\n    ],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec\"\n        }\n    ]\n}\n</code></pre></li> <li>Use curl to put the data to the UDR. <pre><code>curl -X PUT -H \"Content-Type: application/json\" --data @./ti_data.json \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData/1\n</code></pre></li> <li>To check the created influence data, use the following command. <pre><code>curl -X GET -H \"Content-Type: application/json\" \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData?dnns=internet\n</code></pre></li> <li>You can also remove the traffic influence data by the following command. <pre><code>curl -X DELETE -H \"Content-Type: application/json\" \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData/1\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#screenshots","title":"Screenshots","text":"<ul> <li>We use this sample topology to show the example usage of traffic influence </li> <li>Traffic routing before influence<ul> <li>ping <code>1.1.1.1</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> <li>ping <code>remote server</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> </ul> </li> <li>Traffic routing after influence<ul> <li>ping <code>1.1.1.1</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> <li>ping <code>remote server</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; Server) </li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#influence-traffic-routing-by-nef","title":"Influence traffic routing by NEF","text":"<ul> <li>An Application Function (AF) may send requests to influence SMF routing decisions for User Plane traffic of PDU Sessions. </li> <li>The AF requests may influence UPF (re)selection and allow routing of user traffic to a local access (identified by a DNAI) to a Data Network.</li> </ul>"},{"location":"guide/8-traffic-influence/#af-requests-targeting-a-group-of-ue","title":"AF requests targeting a group of UE","text":"<p>TS 23.502 figure 4.3.6.2-1 Processing AF requests to influence traffic routing for Sessions not identified by an an UE address</p> <ul> <li>Example usage in free5GC<ul> <li>AF send JSON data to NEF, e.g. <code>af_ti_anyUE.json</code> <pre><code>{\n    \"afServiceId\": \"Service1\",\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"anyUeInd\": true,\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficFilters\": [{\n        \"flowId\": 1,\n        \"flowDescriptions\": [\n            \"permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\"\n        ]\n    }],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec\"\n        }\n    ]\n}\n</code></pre></li> <li>Use curl to POST the data to NEF. <pre><code>curl -X POST -H \"Content-Type: application/json\" --data @./af_ti_anyUE.json \\\n    http://&lt;nef-interface&gt;:8000/3gpp-traffic-influence/v1/af001/subscriptions\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#af-requests-targeting-an-individual-ue","title":"AF requests targeting an individual UE","text":"<p>TS 23.502 figure 4.3.6.4-1 Handling an AF request targeting an individual UE address to the relevant PCF</p> <ul> <li> <p>Example usage in free5GC</p> <ul> <li> <p>Provide PFDs in <code>uerouting.yaml</code> before SMF start up <pre><code>//...\npfdDataForApp: # PFDs for an Application\n    - applicationId: app1 # Application identifier\n        pfds: # PFDs for the Application\n          - pfdID: pfd1 # PFD identifier\n            flowDescriptions: \n              - permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\n</code></pre></p> <ul> <li>Packet Flow Description (PFD): A set of information enabling the detection of application traffic provided by a 3rd party service provider. </li> </ul> </li> <li> <p>AF send JSON data to NEF, e.g. <code>af_ti_singleUE.json</code> <pre><code>{\n    \"afServiceId\": \"Service1\",\n    \"AfAppId\": \"app1\",\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"ipv4Addr\": \"10.60.0.1\",\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficRoutes\": [{\n        \"dnai\": \"mec\"\n    }],\n    \"suppFeat\": \"01\"\n}\n</code></pre></p> </li> <li>Use curl to POST the data to NEF. <pre><code>curl -X POST -H \"Content-Type: application/json\" --data @./af_ti_singleUE.json \\\n    http://&lt;nef-interface&gt;:8000/3gpp-traffic-influence/v1/af001/subscriptions\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/Appendix/","title":"Appendix","text":""},{"location":"guide/Appendix/#appendix","title":"Appendix","text":""},{"location":"guide/Appendix/#appendix-a-oam","title":"Appendix A: OAM","text":"<ol> <li>Run the OAM server <pre><code>cd webconsole\ngo run server.go\n</code></pre></li> <li>Access the OAM by <pre><code>URL: http://localhost:5000\nUsername: admin\nPassword: free5gc\n</code></pre></li> <li>Now you can see the information of currently registered UEs (e.g. Supi, connected state, etc.) in the core network at the tab \"DASHBOARD\" of free5GC webconsole</li> </ol> <p>Note: You can add the subscribers here too</p>"},{"location":"guide/Appendix/#appendix-b-orchestrator","title":"Appendix B: Orchestrator","text":"<p>Please refer to free5gmano</p>"},{"location":"guide/Appendix/#appendix-c-iptv","title":"Appendix C: IPTV","text":"<p>Please refer to free5GC/IPTV</p>"},{"location":"guide/Appendix/#appendix-d-system-environment-cleaning","title":"Appendix D: System Environment Cleaning","text":"<p>The below commands may be helpful for development purposes.</p> <ol> <li>Remove POSIX message queues<ul> <li><code>ls /dev/mqueue/</code></li> <li><code>rm /dev/mqueue/*</code></li> </ul> </li> <li>Remove gtp5g tunnels (using tools in libgtp5gnl)<ul> <li><code>cd ./src/upf/lib/libgtp5gnl/tools</code></li> <li><code>./gtp5g-tunnel list pdr</code></li> <li><code>./gtp5g-tunnel list far</code></li> </ul> </li> <li>Remove gtp5g devices (using tools in libgtp5gnl)<ul> <li><code>cd ./src/upf/lib/libgtp5gnl/tools</code></li> <li><code>sudo ./gtp5g-link del {Dev-Name}</code></li> </ul> </li> </ol>"},{"location":"guide/Appendix/#appendix-e-change-kernel-version","title":"Appendix E: Change Kernel Version","text":"<ol> <li>Check the previous kernel version: <code>uname -r</code></li> <li>Search for a specific kernel version and install (e.g. <code>5.0.0-23-generic</code>) <pre><code>sudo apt update # make sure package lists are up to date\nsudo apt search 'linux-image-5.0.0-23-generic'\n</code></pre> Example output for the command above: <pre><code>Sorting... Done\nFull Text Search... Done\nlinux-image-5.0.0-23-generic/focal-updates,focal-security 5.0.0-23.126~20.04.1 amd64\n  Signed kernel image generic\n</code></pre> Install the new kernel image: <pre><code>sudo apt install linux-image-5.0.0-23-generic linux-headers-5.0.0-23-generic\n</code></pre></li> <li>Update initramfs and GRUB <pre><code>sudo update-initramfs -u -k all\nsudo update-grub\n</code></pre></li> <li>Reboot, enter GRUB, and select the newly installed kernel version <code>5.0.0-23-generic</code> <pre><code>sudo reboot\n</code></pre></li> <li>Reinstall the GTP-U kernel module on the new kernel version</li> </ol> <p>Follow the <code>Retrieve the 5G GTP-U kernel module using git and build it</code> instructions of the install guide</p>"},{"location":"guide/Appendix/#optional-remove-kernel-image","title":"Optional: Remove Kernel Image","text":"<pre><code>sudo apt remove linux-image-5.0.0-23-generic linux-headers-5.0.0-23-generic\n</code></pre>"},{"location":"guide/Appendix/#appendix-f-program-the-sim-card","title":"Appendix F: Program the SIM Card","text":"<p>Install packages: <pre><code>sudo apt-get install pcscd pcsc-tools libccid python-dev swig python-setuptools python-pip libpcsclite-dev\nsudo pip install pycrypto\n</code></pre></p> <p>Download PySIM <pre><code>git clone git://git.osmocom.org/pysim.git\n</code></pre></p> <p>Change to pyscard folder and install <pre><code>cd &lt;pyscard-path&gt;\nsudo /usr/bin/python setup.py build_ext install\n</code></pre></p> <p>Verify your reader is ready</p> <pre><code>sudo pcsc_scan\n</code></pre> <p>Check whether your reader can read the SIM card <pre><code>cd &lt;pysim-path&gt;\n./pySim-read.py \u2013p 0\n</code></pre></p> <p>Program your SIM card information <pre><code>./pySim-prog.py -p 0 -x 208 -y 93 -t sysmoUSIM-SJS1 -i 208930000000003 --op=8e27b6af0e692e750f32667a3b14605d -k 8baf473f2f8fd09487cccbd7097c6862 -s 8988211000000088313 -a 23605945\n</code></pre></p> <p>You can get your SIM card from sysmocom.</p>"},{"location":"guide/Appendix/#appendix-g-install-mongodb-70x-on-ubuntu-server-220403","title":"Appendix G: Install MongoDB 7.0.x on Ubuntu Server 22.04.03","text":"<p>Check that the system CPU supports AVX instructions as it's required since MongoDB 5.0. If not (i.e. the command below returns empty output), use MongoDB 4.4.x (see step 3 from installation prerequisites instructions)</p> <pre><code>grep --color avx /proc/cpuinfo\n</code></pre> <p>Before you begin the installation, update the package manager database and make sure MongoDB prerequisites are installed <pre><code>sudo apt update\nsudo apt install gnupg curl\n</code></pre> Add MongoDB public GPG key <pre><code>curl -fsSL https://pgp.mongodb.com/server-7.0.asc | \\\n   sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg --dearmor\n</code></pre> Note: if you are installing a version other than 7.0, remember, change it on the command above</p> <p>Create the APT list entry file using the command below <pre><code>echo \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n</code></pre></p> <p>Refresh the package database then install MongoDB</p> <pre><code>sudo apt update\nsudo apt install -y mongodb-org\n</code></pre> <p>For detailed instructions on how to freeze the installed version or install a specific version of MongoDB, please, check the reference below or follow this direct URL</p> <p>Don't forget to load the DB service using</p> <pre><code>sudo systemctl start mongod\n</code></pre> <p>Reference: MongoDB official website</p>"},{"location":"guide/Appendix/#appendix-h-using-the-reload_host_configsh-script","title":"Appendix H: Using the <code>reload_host_config.sh</code> script","text":"<p>The script was designed to help reapplying the configurations after a VM reboot</p>"},{"location":"guide/Appendix/#usage","title":"Usage","text":"<p>Its usage is fairly simple, just run</p> <pre><code>cd ~/free5gc # go back to free5gc's main folder\nsudo reload_host_config.sh &lt;dn_interface&gt;\n</code></pre> <p>For example, if your DN interface (e.g. free5GC's VM LAN interface) is called <code>enp0s4</code>, the command above will be</p> <pre><code>sudo reload_host_config.sh enp0s4\n</code></pre> <p>Note: In Ubuntu Server 20.04 and 22.04 the dn_interface may be called <code>enp0s3</code> or <code>enp0s4</code> by default</p> <p>If you are unsure about the interface name, run <code>ip a</code> to help to figure it out (see the image below)</p> <p></p> <p>An example of the expected output is depicted above</p>"},{"location":"guide/Appendix/#reset-iptables-rules","title":"Reset iptables rules","text":"<p>There is a parameter to completely reset the firewall rules (by default, the script only appends free5gc's required rules)</p> <p>Just add <code>-reset-firewall</code> to the script input</p> <pre><code>sudo reload_host_config.sh enp0s4 -reset-firewall\n</code></pre> <p>So it will clear all rules, then apply the required rules</p>"},{"location":"guide/Configuration/","title":"Configuration","text":""},{"location":"guide/Configuration/#configuration","title":"Configuration","text":""},{"location":"guide/Configuration/#sbi-configuration","title":"SBI Configuration","text":""},{"location":"guide/Configuration/#nf-ip","title":"NF IP","text":"<p>There are registerIP and bindingIP design on every NF's sbi interface.</p> <pre><code>configuration:\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.18 # IP used to register to NRF\n    bindingIPv4: 127.0.0.18  # IP used to bind the service\n    port: 8000 # port used to bind the service\n</code></pre> <p>This is due to some orchestration, such as Kubernetes or OpenStack, has the design of service IP mapping.</p> <p></p> <p>Use Kubernetes as an example. K8s has the service type that enable users to define the service IP outside the pod. But the service IP may be different from the IP assigned inside the pod. Therefore, if we register the binding IP inside the pod to NRF, NRF cannot know which service IP outside the pod has attached. As the result, we need to separate registerIP from bindingIP in this scenario.</p> <p>If you are not sure what IP you should set, just configure it as the same IP address.</p>"},{"location":"guide/Configuration/#oauth2","title":"OAuth2","text":"<ul> <li>Enable OAuth2 setting in NRF config (nrfcfg.yaml): <pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true\n</code></pre></li> <li>Set NRF's certificate path in each NF: <pre><code>configuration:\n    nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre></li> <li>For more detailed information about OAuth2 in free5GC, please refer to the Design Document.</li> </ul>"},{"location":"guide/Configuration/#sample-configuration","title":"Sample configuration","text":"<p>We provide a sample config to connect to outer ran under <code>/sample/ran_attach_config/</code>. The architecture is as following.</p> <p></p> <p>As the result, user's RAN IP must set to 192.168.0.0/24 subnet or let the routing route to this subnet.</p> <p>Notice: If user wants to use the setting, aware to set 192.168.0.1 to your host as well.</p>"},{"location":"guide/Configuration/#smf-configuration","title":"SMF Configuration","text":""},{"location":"guide/Configuration/#a-configure-smf-with-s-nssai","title":"A. Configure SMF with S-NSSAI","text":"<ol> <li>Configure NF Registration SMF S-NSSAI in <code>smfcfg.yaml</code></li> </ol>"},{"location":"guide/Configuration/#b-configure-uplink-classifier-ulcl-information-in-smf","title":"B. Configure Uplink Classifier (ULCL) information in SMF","text":"<ol> <li>Configure UE routing path in <code>uerouting.yaml</code></li> </ol> <ul> <li>DestinationIP and DestinationPort will be the packet destination.</li> <li>UPF field will be the packet datapath when it match the destination above.</li> </ul> <p>For more detail of SMF config, please refer to here.</p>"},{"location":"guide/Environment/","title":"Environment","text":""},{"location":"guide/Environment/#recommended-environment","title":"Recommended Environment","text":"<p>free5gc has been tested against the following environment:</p> <ul> <li>Software<ul> <li>OS: Ubuntu 20.04.6 LTS</li> <li>gcc 9.4.0</li> <li>go 1.18.10 linux/amd64</li> <li>kernel version 5.4.0-169-generic</li> </ul> </li> </ul> <p>Note: The listed kernel version is required for the UPF element.</p> <ul> <li> <p>Minimum Hardware</p> <ul> <li>CPU: Intel i5 processor</li> <li>RAM: 4GB</li> <li>Hard drive: 160GB</li> <li>NIC: Any 1Gbps Ethernet card supported in the Linux kernel</li> </ul> </li> <li> <p>Recommended Hardware</p> <ul> <li>CPU: Intel i7 processor</li> <li>RAM: 8GB</li> <li>Hard drive: 160GB</li> <li>NIC: Any 10Gbps Ethernet card supported in the Linux kernel</li> </ul> </li> </ul> <p>This guide assumes that you will run all 5GC elements on a single machine.</p>"},{"location":"guide/SMF-Config/","title":"SMF Config","text":""},{"location":"guide/SMF-Config/#smf-config-ulcl-config","title":"SMF Config / ULCL Config","text":"<p>This document explains the detail of SMF config. Also provide some examples about conversion between config file and real User Plane topology</p> <p>ULCL limitation: The branching UPF now can't connect to the Internet.  It only serves as a Intranet in the UPF topology. (Please refers to the topology of example 2)</p>"},{"location":"guide/SMF-Config/#sbi","title":"SBI","text":"Field meaning scheme The protocol for SBI registerIPv4 IP used to register to NRF bindingIPv4 IP used to bind the service port SMF bind the SBI service to this port"},{"location":"guide/SMF-Config/#pfcp","title":"PFCP","text":"Field meaning addr The IP address of N4 interface on the SMF (PFCP)"},{"location":"guide/SMF-Config/#userplane-information","title":"Userplane Information","text":"Field meaning userplane_information Includes topology and information of RAN and UPFs which are controlled by this SMF up_nodes The node in the user plane topology. Includes gNodeB, I-UPF and A-UPF links The edge in the user plane topology type Indicate it is RAN or specific kind of  UPF node_id The PFCP IPv4 address for UPF <p>Note: up_resource_ip serves as default user plane IP for the UPF. In this version, UPF will determine its user plane IP by itself. So setting up_resource_ip in SMF config won't affect real config in user plane.</p>"},{"location":"guide/SMF-Config/#amf-config","title":"AMF Config","text":"<p>To understand whole PDU session config, we must take a step forward to understand the AMF config.</p> Field meaning NGAPIPList The IP list of N2 interfaces on the AMF SBI Same meaning with SMF/SBI."},{"location":"guide/SMF-Config/#example-1","title":"Example 1","text":""},{"location":"guide/SMF-Config/#smf-config","title":"SMF Config","text":"<ul> <li>sbi:<ul> <li>scheme: http</li> <li>registerIPv4: 127.0.0.2</li> <li>bindingIPv4: 127.0.0.2</li> <li>port: 8000</li> </ul> </li> <li>pfcp:<ul> <li>addr: 10.200.200.1</li> </ul> </li> <li>userplane_information:<ul> <li>up_nodes:<ul> <li>gNB1:<ul> <li>type: AN</li> </ul> </li> <li>UPF:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.102</li> </ul> </li> </ul> </li> <li>links:<ul> <li>A: gNB1</li> <li>B: UPF</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#amf-config_1","title":"AMF Config","text":"<ul> <li>ngapIpList:<ul> <li>127.0.0.1</li> </ul> </li> <li>sbi:<ul> <li>scheme: http</li> <li>registerIPv4: 127.0.0.18</li> <li>bindingIPv4: 127.0.0.18</li> <li>port: 8000</li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#representing-topology","title":"Representing Topology","text":""},{"location":"guide/SMF-Config/#example-2","title":"Example 2","text":""},{"location":"guide/SMF-Config/#smf-config_1","title":"SMF Config","text":"<ul> <li>sbi:<ul> <li>scheme: https</li> <li>registerIPv4: 127.0.0.2</li> <li>bindingIPv4: 127.0.0.2</li> <li>port: 29502</li> </ul> </li> <li>pfcp:<ul> <li>addr: 10.200.200.1</li> </ul> </li> <li>userplane_information:<ul> <li>up_nodes:<ul> <li>gNB1:<ul> <li>type: AN</li> </ul> </li> <li>BranchingUPF:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.102</li> </ul> </li> <li>AnchorUPF1:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.101</li> </ul> </li> <li>AnchorUPF2:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.103</li> </ul> </li> <li>links:</li> <li>A: gNB1     B: BranchingUPF</li> <li>A: BranchingUPF     B: AnchorUPF1</li> <li>A: BranchingUPF     B: AnchorUPF2</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#amf-config_2","title":"AMF Config","text":"<ul> <li>ngapIpList:<ul> <li>127.0.0.1</li> </ul> </li> <li>sbi:<ul> <li>scheme: https</li> <li>registerIPv4: 127.0.0.18</li> <li>bindingIPv4: 127.0.0.18</li> <li>port: 8000</li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#representing-topology_1","title":"Representing Topology","text":""},{"location":"guide/Trouble_Shooting/","title":"Trouble Shooting","text":""},{"location":"guide/Trouble_Shooting/#trouble-shooting","title":"Trouble Shooting","text":""},{"location":"guide/Trouble_Shooting/#1-error-sctp-failed-to-connect-given-amf-n3iwfngap","title":"1. <code>ERROR: [SCTP] Failed to connect given AMF    N3IWF=NGAP</code>","text":"<p>This error occured when N3IWF was started before AMF finishing initialization. This error usually appears when you run the TestNon3GPP in the first time.</p> <p>Rerun the test should be fine. If it still not be solved, larger the sleeping time in line 110 of <code>test.sh</code>.</p>"},{"location":"guide/Trouble_Shooting/#2-testnon3gpp","title":"2. TestNon3GPP","text":"<p>TestNon3GPP will modify the <code>config/amfcfg.conf</code>. So, if you had killed the TestNon3GPP test before it finished, you might need to copy <code>config/amfcfg.conf.bak</code> back to <code>config/amfcfg.conf</code> to let other tests pass.</p> <p><code>cp config/amfcfg.conf.bak config/amfcfg.conf</code></p>"},{"location":"guide/Trouble_Shooting/#3-db-on-tls-to-h2c","title":"3. DB on TLS to H2C","text":"<p>If you meet any problems about https or mogodb, it maybe couse our new version from v3.0.1 to v3.0.2 has change http to H2C verion. Try the command below.</p> <p><code>mongo --eval \"db.NfProfile.drop()\" free5gc</code></p>"},{"location":"guide/Trouble_Shooting/#4-mqcreate-error-creating-message-queue-too-many-open-files-upfutil-upf","title":"4. <code>MQCreate() Error creating message queue: Too many open files UPF=Util</code> (UPF)","text":"<p>Remove POSIX message queues</p> <pre><code>ls /dev/mqueue/\nrm /dev/mqueue/*\n</code></pre>"},{"location":"guide/Trouble_Shooting/#5-remove-gtp-devices-using-tools-in-libgtp5gnl-upf","title":"5. Remove gtp devices (using tools in libgtp5gnl) (UPF)","text":"<pre><code>cd lib/libgtp5gnl/tools\nsudo ./gtp5g-link del {Dev-Name}\n</code></pre>"},{"location":"guide/Trouble_Shooting/#6-upf-cli-run-error-open-gtp5g-open-link-create-file-exists","title":"6. <code>UPF Cli Run Error: open Gtp5g: open link: create: file exists</code>","text":"<pre><code>sudo ip link del upfgtp\n</code></pre>"},{"location":"guide/Trouble_Shooting/#7-smf-cannot-communicate-with-upf-upf-cannot-start-after-a-reboot-or-crash","title":"7. SMF cannot communicate with UPF / UPF cannot start after a reboot or crash","text":"<p>The message below shows up on the logs:</p> <pre><code>[WARN][SMF][Main] Failed to setup an association with UPF[127.0.0.8], error:Request Transaction [1]: retry-out\n</code></pre> <p>Verify on the logs if you got this message:</p> <pre><code>[ERRO][UPF][Main] UPF Cli Run Error: open Gtp5g: open link: create: operation not supported\n</code></pre> <p>If yes, then try to load the GTP module on the system:</p> <pre><code>modprobe gtp5g\n</code></pre> <p>If this outputs an error like this:</p> <pre><code>modprobe: FATAL: Module gtp5g not found in directory /lib/modules/5.4.0-xxx-generic\n</code></pre> <p>Reinstall the GTP-U kernel module (refer to these instructions)</p> <p>Then, once running the core <code>run.sh</code> script, you should obtain the message on the logs:</p> <pre><code>[INFO][SMF][Main] Received PFCP Association Setup Accepted Response from UPF[127.0.0.8]\n</code></pre> <p>and it should work as normal</p> <p>After that, if it's required to reload the module, just run <code>modprobe gtp5g</code> again</p> <p>Note: The symptoms described above may happen if the host machine updated it's kernel version recently</p> <p>References: Free5GC Forum and Install Guide</p>"},{"location":"guide/Trouble_Shooting/#8-decode-http2-packet-in-wireshark","title":"8. Decode HTTP/2 packet in Wireshark","text":"<ol> <li> <p>Run Network Function</p> <p>Check has XXFsslkey.log</p> </li> <li> <p>Edit &gt;&gt; Preference &gt;&gt; Protocols &gt;&gt; SSL (TLS)</p> <p></p> </li> <li> <p>Add keylog</p> <p></p> </li> <li> <p>Filter http2</p> <p></p> </li> </ol>"},{"location":"guide/Trouble_Shooting/#9-decode-h2c-http2-clear-text-without-tls","title":"9. Decode H2C (HTTP2 clear text without TLS)","text":"<p>The similar reason as NEA0 NAS message. Althrough H2C is clear text, wirshark still considers these packets as the normal TCP packets and does not decode them by HTTP2.</p> <p>To see the details of H2C packets, do the following configuration.</p> <ol> <li> <p>Analyze \u2192 Decode As\u2026</p> <p></p> </li> <li> <p>click Add button to add the decode rules</p> <p></p> <p>Decode the packets from the TCP ports listened by each NF as HTTP2 packets.</p> </li> </ol>"},{"location":"guide/Trouble_Shooting/#10-clear-all-iptables-rules","title":"10. Clear all iptables rules","text":"<p>If something went wrong, it's possible to reset iptables' rules back using: <pre><code>sudo iptables -P INPUT ACCEPT\nsudo iptables -P FORWARD ACCEPT\nsudo iptables -P OUTPUT ACCEPT\nsudo iptables -t nat -F\nsudo iptables -t mangle -F\nsudo iptables -F\nsudo iptables -X\n</code></pre></p> <p>Then remember to add back the rules required by the free5GC.</p> <p>Note: You may consider using the <code>reload_host_config.sh</code> script for this task (see this appendix section)</p>"},{"location":"guide/Trouble_Shooting/#11-fix-ueransims-eap-aka-behavior","title":"11. Fix UERANSIM's EAP-AKA' behavior","text":"<p>If you face issues similar to the one reported on the forum or the message <code>SEMANTICALLY_INCORRECT_MESSAGE</code> when seting up UERANSIM's UE after configuring it to use EAP-AKA-PRIME as authentication method on Webconsole, check the solution below:</p>"},{"location":"guide/Trouble_Shooting/#first-method","title":"First method","text":"<p>Clone the nightly version from commit <code>85a0fbf</code>:</p> <p>Follow the cloning instructions from this guide page here</p>"},{"location":"guide/Trouble_Shooting/#second-method","title":"Second method","text":"<p>Update your UERANSIM installation with the fix:</p> <ol> <li> <p>Enter UERANSIM's folder (the folder where the source code is already cloned): <pre><code>cd UERANSIM\n</code></pre></p> </li> <li> <p>Move the version of your source code to the commit where the fixes were merged: <pre><code>git checkout 85a0fbf\n</code></pre></p> </li> <li> <p>Rebuild UERANSIM <pre><code>make\n</code></pre></p> </li> </ol>"},{"location":"guide/Trouble_Shooting/#12-n3iwue-fails-to-connect-with-erron3ueike-not-success-message","title":"12. N3IWUE fails to connect with <code>[ERRO][N3UE][IKE] Not Success</code> message","text":"<p>As per the instructions on N3IWUE install guide, the parameters of the configuration file <code>n3ue.yaml</code> must match those on free5GC's database. </p> <p>If you get log messages like those below:</p> <pre><code># on free5GC\n[WARN][AMF][Gmm][amf_ue_ngap_id:RU:6,AU:8(Non3GPP)][supi:SUPI:imsi-208930000001234] NAS MAC verification failed(received: 0xc0c0d135, expected: 0x6f1f9365)\n[ERRO][AMF][Gmm][amf_ue_ngap_id:RU:6,AU:8(Non3GPP)][supi:SUPI:imsi-208930000001234] NAS message is ciphered, but MAC verification failed\n# on N3IWUE\n[INFO][N3UE][IKE] Get EAP\n[ERRO][N3UE][IKE] Not Success\n^C4 packets captured\n4 packets received by filter\n0 packets dropped by kernel\n[FATA][N3UE][Init] panic: runtime error: invalid memory address or nil pointer dereference\n</code></pre> <p>Double check if SQN matches. If not, update it on N3IWUE's side using:</p> <pre><code>nano n3iwue/config/n3ue.yaml # adjust this path if needed\n</code></pre> <p>Refer to the <code>Security</code> section on the file:</p> <pre><code>info:\n    version: 1.0.1\n    description: Non-3GPP UE configuration\nconfiguration:\n    N3IWFInformation:\n...\n    Security:\n                K: b73a90cbcf3afb622dba83c58a8415df\n                RAND: b120f1c1a0102a2f507dd543de68281f\n                SQN: 16f3b3f71005\n                AMF: 8000\n                OP: b672047e003bb952dca6cb8af0e5b779\n                OPC: df0c67868fa25f748b7044c6e7c245b8\n</code></pre> <p>Note that SQN is dinamically updated while N3IWUE is running, so this issue might get caused by the N3IWUE being killed during the authentication phase which may cause the value to not match (e.g. it was updated on just one side).</p> <p>Once the parameters are updated, save and close the configuration file. Now N3IWUE should work correctly.</p>"},{"location":"guide/Trouble_Shooting/#13-unable-to-find-wpa2-eap-encryption-option-in-openwrt-installation","title":"13. Unable to find WPA2-EAP encryption option in OpenWrt installation","text":"<p>According to OpenWrt Wiki, 802.1x authentication is probably missing. This is due <code>wpad-mini</code> package not having it. To solve this, install <code>wpad</code> instead: 1. Login to AP as <code>root</code> using SSH</p> <p><pre><code>ssh root@&lt;IP&gt;\n# Example:\nssh root@192.168.1.1\n</code></pre> Tip: The default IP address is 192.168.1.1, change IP in the command above if your setup requires it. 2. Update package database</p> <p><pre><code>opkg update\n</code></pre> 3. Add WPA-EAP support</p> <p>Note: Executing the steps below will remove the support for WPA3-SAE on your AP (which may be used by other wireless networks), remember to change the affected Wi-Fi networks to WPA2-PSK</p> <p>Tip: To add WPA3 support back, install <code>wpad-openssl</code> instead of <code>wpad</code></p> <p>A. First Method</p> <p>Remove <code>wpad-mini</code> and install <code>wpad</code> <pre><code>opkg remove wpad-mini\nopkg install wpad\n</code></pre></p> <p>If the commands above fail with the messages <code>No packages removed.</code> or <code>[...] Cannot install package wpad.</code>, try the second method</p> <p>B. Second Method</p> <p>Remove <code>wpad-basic-mbedtls</code> and install <code>wpad</code> <pre><code>opkg remove wpad-basic-mbedtls\nopkg install wpad\n</code></pre> 4. Reboot the AP to make sure the new configuration was applied <pre><code>reboot\n</code></pre> References: OpenWrt Wiki and OpenWrt Github Issue #3363</p>"},{"location":"guide/Trouble_Shooting/#14-troubleshooting-missing-packages-when-trying-to-build-tngfue-on-ubuntu","title":"14. Troubleshooting missing packages when trying to build TNGFUE on Ubuntu","text":"<p>First, remember to update packages source before installing packages <pre><code>sudo apt update\n</code></pre></p> <p>To install all prerequisites in one line: <pre><code>sudo apt install libssl-dev libdbus-1-dev libnl-3-dev libnl-genl-3-dev libnl-route-3-dev\n</code></pre></p> <p>(Alternatively) Error messages and their related packages:</p> <ul> <li>openssl/ssl.h: No such file or directory <pre><code>sudo apt install libssl-dev\n</code></pre></li> <li>dbus/dbus.h: No such file or directory <pre><code>sudo apt install libdbus-1-dev\n</code></pre></li> <li>netlink/netlink.h: No such file or directory <pre><code>sudo apt install libnl-3-dev\n</code></pre></li> <li>/usr/bin/ld: cannot find -lnl-genl-3 <pre><code>sudo apt install libnl-genl-3-dev\n</code></pre></li> <li>/usr/bin/ld: cannot find -lnl-route-3 <pre><code>sudo apt install libnl-route-3-dev\n</code></pre></li> </ul>"},{"location":"guide/contribute/","title":"Contribute","text":""},{"location":"guide/contribute/#how-to-contribute","title":"How to contribute","text":"<p>To contribute to free5GC project, you can consider to:</p> <p>1. Raise the GitHub issue</p> <p>You can create the Issue on the free5GC repo directly. A issue could be 1. bugs report or 2. feature request, each issue would be assigned to the free5GC commiter by project owner, then assignee will solve the problem asap.</p> <p>2. Create the Patch (Pull Request)</p> <p>The source code of the free5GC is stored at https://github.com/free5gc/free5gc. Please follow the GitHub flow for collaboration.</p> <p>Note</p> <p>Our pull request commit messages must comply with the Conventional Commit Message format. This will be checked by the pull request CI action.</p> <p>3. Become a Contributor</p> <p>Once your pull request is accepted, you will be added to the contributor list in the free5GC governance.</p>"},{"location":"guide/contribute/#recommended-articles","title":"Recommended Articles","text":"<ul> <li>How to Contribute to Open Source</li> </ul>"},{"location":"guide/contribute/#development-skills","title":"Development Skills","text":"<ul> <li>Golang<ul> <li>A tour of go</li> <li>https://github.com/uber-go/guide</li> </ul> </li> <li>Version Control<ul> <li>https://git-scm.com/</li> <li>https://docs.github.com/en/get-started/using-github/github-flow</li> </ul> </li> </ul>"},{"location":"guide/features/","title":"Features","text":""},{"location":"guide/features/#free5gc-specification","title":"free5GC Specification","text":"<ul> <li>3GPP TS 23.501/23.502-Rel-15</li> <li>5G Standalone (SA) supported</li> <li>Serviced-Based Interface (SBI) supported<ul> <li>Namf, Nsmf, Nausf, Nudm, Nudr, Nnssf, Nnrf, Npcf</li> </ul> </li> <li>N1, N2, N3, N4, N6, N9, interfaces supported</li> <li>5G SA Network Functions supported:<ul> <li>AMF: Access and Mobility Management Function<ul> <li>Registration Management, Connection Management, Reachability Management, Mobility Management, and Authentication</li> </ul> </li> <li>SMF: Session Management Function<ul> <li>Session Management, IP Assigning/Management</li> </ul> </li> <li>UPF: User Plane Function<ul> <li>Support multiple UPF and ULCL (uplink classifier)</li> <li>Session and Service Continuity (SSC) mode 1</li> <li>Packet Routing/Forwarding</li> </ul> </li> <li>CHF: Charging Function (will be supported in release v3.3.1)<ul> <li>Online/Offline Charging</li> <li>Webconsole acts as BD (Billing Domain)</li> <li>Flow-Based Charging on PDU Session</li> </ul> </li> <li>AUSF: Authentication Server Function</li> <li>NRF: NF Repository Function</li> <li>UDM: Unified Data Management</li> <li>UDR: Unified Data Repository</li> <li>PCF: Policy and Charging Function</li> <li>NSSF: Network Slice Selection Function</li> <li>N3IWF: Non-3GPP Interworking Function</li> <li>N3IWUE: Non-3GPP Interworking User Equipment</li> <li>TNGF: Trusted Non-3GPP Gateway Function</li> <li>TNGFUE: Trusted Non-3GPP Gateway Function User Equipment</li> </ul> </li> </ul>"},{"location":"guide/features/#supported-features","title":"Supported features","text":"<ul> <li>Registration<ul> <li>Initial Registration</li> <li>Periodic Registration</li> <li>Mobility Registration</li> <li>Registration without authentication, due to RAN did the AMF reselection</li> </ul> </li> <li>NAS Reroute when serving AMF can not handle UE registration with unmatch NSSAI</li> <li>Authentication<ul> <li>5G-AKA</li> <li>EAP-AKA'</li> </ul> </li> <li>NAS Security<ul> <li>Ciphering: NEA0, NEA1, NEA2, NEA3</li> <li>Integrity: NIA0, NIA1, NIA2, NIA3</li> </ul> </li> <li>Deregistration:<ul> <li>UE-initiated Deregistration</li> </ul> </li> <li>Service Request:<ul> <li>UE triggered Service Request</li> <li>Network Triggered Service Request</li> </ul> </li> <li>AN Release</li> <li>PDU Session Establishment</li> <li>PDU Session Modification (v3.3.0)</li> <li>Converged Charging<ul> <li>Billing Domain (webconsole)</li> <li>ABMF, RF, and CGF built-in CHF</li> <li>Flow-based Charging (FBC)</li> </ul> </li> <li>PDU Session Release</li> <li>Handover<ul> <li>N2 Handover (Indirect mode not supported)</li> <li>Xn Handover</li> </ul> </li> <li>QoS<ul> <li>Control Plane only:<ol> <li>5QI, ARP, GBR, MBR of QoS Flow (v3.3.0)</li> <li>Session-AMBR supported</li> </ol> </li> </ul> </li> <li>Collection and reporting of usage data over N4 interface<ul> <li>Volume measurement periodically</li> </ul> </li> <li>UP Security</li> <li>Multiple UPFs and ULCL (Uplink Classifier)</li> <li>Multiple Slice and DNN</li> <li>Dynamic/Static IPv4 address allocation</li> <li>OAuth2 on SBI <ul> <li>Design Document</li> </ul> </li> </ul>"},{"location":"guide/hardware/","title":"Hardware","text":""},{"location":"guide/hardware/#tested-hardware","title":"Tested Hardware","text":"<p>Some 5G UE and gNodeB hardware have been tested with free5GC by partners or community members:</p> <ul> <li> <p>5G UE (Support 5G SA):</p> <ul> <li>APAL 5G Dongle</li> <li>APAL 5G MiFi</li> <li>Samsung S21 5G</li> <li>Huawei P40 5G (forum link)</li> <li>Huawei Mate30 5G (forum link)</li> <li>iPhone13 mini (test link written in japanese)</li> </ul> </li> <li> <p>gNodeB:</p> <ul> <li>Alpha gNodeB</li> <li>Compal gNodeB</li> <li>FII gNodeB</li> <li>ITRI gNodeB</li> <li>Lions gNodeB</li> <li>Amarisoft gNodeB (forum link)</li> <li>Nokia gNodeB (forum link)</li> <li>Nokia (AMIA AirScale Indoor Subrack 473098A)</li> <li>OpenAirInterface</li> <li>Open Source RAN Project - srsRAN</li> </ul> </li> </ul> <p>Reports of tested hardware not listed above on Github issue or free5GC forum are welcome.</p> <p>PS: if you don't have any hardware available, we suggest to use UERANSIM to simulate.</p> <p>(Refer to Advanced environment setup section)</p>"},{"location":"guide/n3iwue-installation/","title":"N3iwue installation","text":""},{"location":"guide/n3iwue-installation/#installing-n3iwue","title":"Installing N3IWUE","text":"<p>In this demo we will practice:</p> <ul> <li>Installing N3IWUE</li> <li>Configuring free5GC and N3IWUE</li> <li>Running N3IWUE to connect free5GC</li> </ul>"},{"location":"guide/n3iwue-installation/#1-install-n3iwue-vm","title":"1. Install N3IWUE VM","text":"<p>Repeat the steps of cloning <code>free5gc</code> VM from the base VM, create a new VM for the N3IWUE:</p> <ul> <li>You can refer to Installing free5gc to install free5gc VM.</li> <li>Name the VM <code>N3IWUE</code>, and create new MAC addresses for all network cards.</li> <li>Make sure the VM has internet access and can log in using SSH.</li> <li>Change the hostname to <code>N3IWUE</code>.</li> <li>Make the Host-only network interface have static IP address <code>192.168.56.103</code>.</li> <li>Reboot the N3IWUE VM, as well as the free5gc VM.</li> <li>You can ping <code>192.168.56.101</code> from the N3IWUE VM, and also <code>ping 192.168.56.103</code> from the free5gc VM.</li> </ul>"},{"location":"guide/n3iwue-installation/#2-install-n3iwue","title":"2. Install N3IWUE","text":"<p>Go to N3IWUE GitHub Repo.</p> <p>To download N3IWUE in home directory:</p> <pre><code>cd ~\ngit clone https://github.com/free5gc/n3iwue.git\ncd n3iwue\n</code></pre> <p>Update and upgrade the VM of N3IWUE:</p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p>Install required tools:</p> <pre><code>sudo apt install make\nsudo apt install libsctp-dev lksctp-tools\nsudo apt install iproute2\n</code></pre> <p>Install Golang (use <code>1.21.6</code> version in this demonstrate):</p> <pre><code>wget https://dl.google.com/go/go1.21.6.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.21.6.linux-amd64.tar.gz\nmkdir -p ~/go/{bin,pkg,src}\necho 'export GOPATH=$HOME/go' &gt;&gt; ~/.bashrc\necho 'export GOROOT=/usr/local/go' &gt;&gt; ~/.bashrc\necho 'export PATH=$PATH:$GOPATH/bin:$GOROOT/bin' &gt;&gt; ~/.bashrc\necho 'export GO111MODULE=auto' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# check your go installation\ngo version\n</code></pre> <p>Build N3IWUE</p> <pre><code>cd ~/n3iwue\nmake\n</code></pre>"},{"location":"guide/n3iwue-installation/#3-use-webconsole-to-add-ue","title":"3. Use WebConsole to Add UE","text":"<p>Open your web browser from your host machine, and enter the URL <code>http://192.168.56.101:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button</li> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Make sure the following config between <code>n3iwue/config/n3ue.yaml</code> and the <code>Subscriber</code> you are creating are the same:<ul> <li>SUPI(IMSI) (ex. 208930000001234)</li> <li>K</li> <li>SQN</li> <li>OP value (Operator Code Value)</li> </ul> </li> <li>Scroll the page all the way down and click on <code>Create</code>.</li> </ul>"},{"location":"guide/n3iwue-installation/#4-setting-n3iwf-config","title":"4. Setting N3IWF Config","text":"<p>In free5gc VM, we need to edit N3IWF config file <code>~/free5gc/config/n3iwfcfg.yaml</code></p> <p>Replace IKEBindAddress from <code>172.16.2.100</code> to <code>192.168.56.101</code>, namely from:</p> <pre><code>  IKEBindAddress: 172.16.2.100 # Nwu interface  IP address (IKE) on this N3IWF\n</code></pre> <p>into:</p> <pre><code>  IKEBindAddress: 192.168.56.101 # Nwu interface  IP address (IKE) on this N3IWF\n</code></pre>"},{"location":"guide/n3iwue-installation/#5-setting-n3iwue","title":"5. Setting N3IWUE","text":"<p>To let N3IWUE knows where is the N3IWF is, we need to edit the UE config file <code>~/n3iwue/config/n3ue.yaml</code> in N3IWUE VM</p> <p>Replace these parameters:</p> <pre><code>N3IWFInformation:\n  IPSecIfaceAddr: 10.0.1.1 # IP address of Nwu interface (IKE) on N3IWF\n\nN3UEInformation:\n  IPSecIfaceName: ens38 # Name of Nwu interface (IKE) on this N3UE\n  IPSecIfaceAddr: 10.0.1.4 # IP address of Nwu interface (IKE) on this N3UE\n</code></pre> <p>into:</p> <pre><code>N3IWFInformation:\n  IPSecIfaceAddr: 192.168.56.101 # IP address of Nwu interface (IKE) on N3IWF\n\nN3UEInformation:\n  IPSecIfaceName: enp0s8 # Name of Nwu interface (IKE) on this N3UE (your interface name)\n  IPSecIfaceAddr: 192.168.56.103 # IP address of Nwu interface (IKE) on this N3UE\n</code></pre>"},{"location":"guide/n3iwue-installation/#6-testing-n3iwue-with-free5gc","title":"6. Testing N3IWUE with free5GC","text":"<p>SSH into free5gc. If you have rebooted free5gc, remember to run:</p> <pre><code>cd free5gc\nsudo ./reload_host_config.sh &lt;Interface Name&gt;\n\neg: sudo ./reload_host_config.sh ens18\n</code></pre> <p>Tip: Set <code>net.ipv4.ip_forward=1</code> in <code>/etc/sysctl.conf</code> to enable packet forwarding permanently</p> <p>In free5gc VM:</p> <pre><code>cd ~/free5gc\n./run.sh -n3iwf\n</code></pre> <p>In N3IWUE VM:</p> <pre><code>cd ~/n3iwue\n./run.sh\n</code></pre>"},{"location":"guide/n3iwue-installation/#7-result","title":"7. Result","text":"<p>Success: N3IWUE can ping data network through N3IWF </p>"},{"location":"guide/n3iwue-installation/#appendix","title":"Appendix","text":"<ul> <li>Design Document</li> </ul>"},{"location":"guide/Charging/setting/","title":"Setup Charing for UE","text":"<p>In this demo, we will practice:</p> <ul> <li>Set Slice-level and Flow-level Offline charging in webconsole.</li> <li>Set Slice-level and Flow-level Offline charging in webconsole.</li> <li>Test with UERANSIM </li> </ul> <p>Notice: The charging function was released in free5GC v3.4.1.</p>"},{"location":"guide/Charging/setting/#0-preface","title":"0. Preface","text":"<ul> <li>free5GC provides Converge Charging, which includes Online and Offline.  </li> <li>Support Slice-level and Flow-level Charging.</li> <li>Offline<ul> <li>After network resource usage, charging information is transmitted from the network to the Billing Domain (BD).</li> </ul> </li> <li>Online<ul> <li>Before network resource usage, the network sends an authentication request to the Online Charging System (OCS) and gets quota.</li> </ul> </li> </ul>"},{"location":"guide/Charging/setting/#1-create-subscriber","title":"1. Create Subscriber","text":"<ul> <li> <p>The basic setting for subscribers will be ignored in this article; you can refer to this if you needed. </p> </li> <li> <p>The default would create two slices, 01010203 and 01112233.</p> </li> <li> <p>Click Create.</p> </li> </ul>"},{"location":"guide/Charging/setting/#01010203","title":"01010203","text":"<ul> <li> <p>We could change the charging Method from Offline to Online if you needed. </p> <p></p> </li> <li> <p>We keep using Offline for now.</p> </li> <li> <p>By default, there would be one flow rule to 1.1.1.1/32.</p> <p></p> </li> <li> <p>Remember to use the same Charing Method as slice-level charing. </p> </li> <li> <p>For now, we will keep it Offline. </p> </li> </ul>"},{"location":"guide/Charging/setting/#01112233","title":"01112233","text":"<ul> <li> <p>We use Online Charging for this slice.</p> </li> <li> <p>Create flow rules.</p> <ul> <li>Remember to use the same charging method as Slice-level.</li> </ul> <p></p> </li> </ul>"},{"location":"guide/Charging/setting/#2-check-charging-data-in-webconsole","title":"2. Check Charging Data in Webconsole","text":"<ul> <li> <p>Click UE CHARGING in webconsole sidebar</p> <p></p> </li> <li> <p>We would see the Charging Data we set in Step 1. </p> <ul> <li>Expand</li> </ul> <p></p> <ul> <li>Fold</li> </ul> <p></p> </li> </ul> <p>\u200b    </p> <p>\u200b       </p>"},{"location":"guide/Charging/setting/#3-test-with-ueransim","title":"3. Test with UERANSIM","text":"<ul> <li> <p>Refer to this to set up your environment.</p> </li> <li> <p>Provide <code>free5gc-ue.yaml</code> I use for your reference.</p> <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 digits)\nsupi: 'imsi-208930000000001'\n# Mobile Country Code value of HPLMN\nmcc: '208'\n# Mobile Network Code value of HPLMN (2 or 3 digits)\nmnc: '93'\n# SUCI Protection Scheme : 0 for Null-scheme, 1 for Profile A and 2 for Profile B\nprotectionScheme: 0\n# Home Network Public Key for protecting with SUCI Profile A\nhomeNetworkPublicKey: '5a8d38864820197c3394b92613b20b91633cbd897119273bf8e4a6f4eec0a650'\n# Home Network Public Key ID for protecting with SUCI Profile A\nhomeNetworkPublicKeyId: 1\n# Routing Indicator\nroutingIndicator: '0000'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OPC'\n# Authentication Management Field (AMF) value\namf: '8000'\n# IMEI number of the device. It is used if no SUPI is provided\nimei: '356938035643803'\n# IMEISV number of the device. It is used if no SUPI and IMEI is provided\nimeiSv: '4370816125816151'\n\n# List of gNB IP addresses for Radio Link Simulation\ngnbSearchList:\n  - 127.0.0.1\n\n# UAC Access Identities Configuration\nuacAic:\n  mps: false\n  mcs: false\n\n# UAC Access Control Class\nuacAcc:\n  normalClass: 0\n  class11: false\n  class12: false\n  class13: false\n  class14: false\n  class15: false\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x112233\n\n# Configured NSSAI for this UE by HPLMN\nconfigured-nssai:\n  - sst: 0x01\n    sd: 0x010203\n  - sst: 0x01\n    sd: 0x112233\n\n# Default Configured NSSAI for this UE\ndefault-nssai:\n  - sst: 1\n    sd: 1\n\n# Supported integrity algorithms by this UE\nintegrity:\n  IA1: true\n  IA2: true\n  IA3: true\n\n# Supported encryption algorithms by this UE\nciphering:\n  EA0: true\n  EA1: true\n  EA2: true\n  EA3: true\n\n# Integrity protection maximum data rate for user plane\nintegrityMaxRate:\n  uplink: 'full'\n  downlink: 'full'\n</code></pre> </li> <li> <p>If you set it up successfully, you will see the UERANSIM create two tunnels, <code>uesimtun0</code>, and <code>uesimtun1</code>.</p> </li> <li> <p>The following is a Demo GIF for Charing</p> <p></p> </li> <li> <p>Result</p> <p></p> </li> <li> <p>You can try it out for the Charing Functionality now!</p> </li> </ul>"},{"location":"guide/Charging/setting/#appendix","title":"Appendix","text":"<ul> <li>CHF Design Document</li> <li>CHarging Function(CHF) Overview</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/","title":"Set Static IP for UE","text":"<p>In this demo, we will practice:</p> <ul> <li>Static IP Pool settings</li> <li>Set Static IP address for UE in webconsole</li> <li>Verify the IP address settings</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#1-static-ip-pool-settings","title":"1. Static IP pool settings","text":"<p>We first have to know the static IP pool for specific DNN. </p> <ul> <li>In <code>smfcfg.yaml</code>, the userplaneInformation is what we need now:<ul> <li>The following files remove some settings; please refer to the sample configuration file.</li> <li>We set two slices with one DNN each for this demo:<ul> <li>01010203<ul> <li>internet<ul> <li>pools: 10.60.0.0/16</li> <li>staticPools: 10.60.100.0/24</li> </ul> </li> </ul> </li> <li>01112233<ul> <li>internet<ul> <li>pools: 10.61.0.0/16</li> <li>staticPools: 10.61.100.0/24</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>configuration:\n  userplaneInformation:         # list of userplane information\n    upNodes:                     # information of user-plane node (AN or UPF)\n      UPF:                       # the name of the node\n        type: UPF                # the type of the node (AN or UPF)\n        sNssaiUpfInfos:          # S-NSSAI information list for this UPF\n          - sNssai:              # S-NSSAI(Single Network Slice Selection Assistance Information)\n              sst: 1             # Slice/Service Type (uinteger, range: 0~255)\n              sd: 010203         # Slice Differentiator(3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList:      # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.60.0.0/16\n                staticPools:\n                  - cidr: 10.60.100.0/24\n          - sNssai:\n              sst: 1\n              sd: 112233\n            dnnUpfInfoList:\n              - dnn: internet\n                pools:\n                  - cidr: 10.61.0.0/16\n                staticPools:\n                  - cidr: 10.61.100.0/24\n</code></pre>"},{"location":"guide/Static-IP/set-static-ip/#2-create-subscribers-with-static-ip","title":"2. Create Subscribers with Static-IP","text":"<p>In this step, we would go through how to set static IP addresses for subscribers and verify the settings. </p> <ul> <li>You could also refer to this for how to create subscribers.</li> <li>We would create two subscribers:<ul> <li>imsi-208930000000001</li> <li>imsi-208930000000002</li> <li>Both have slices 010203 and 112233, but have different IP address settings.</li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000001","title":"imsi-208930000000001","text":"<ul> <li> <p>010203 </p> <ul> <li>A Static IPv4 Address toggle under the slices' DNN section would be displayed. </li> </ul> <p></p> <ul> <li> <p>Turn it one, and set the IPv4 address you want to use for this UE of this DNN.</p> <ul> <li> <p>We set 10.60.100.163</p> <p></p> </li> <li> <p>Click Verify</p> <ul> <li>If the setting is OK, the webconsole will show \"OK\" in an alert box.</li> </ul> <p></p> </li> </ul> </li> </ul> </li> <li> <p>112233 </p> <ul> <li> <p>Set the IPv4 address you want for this UE of this DNN.</p> <ul> <li> <p>We set 10.60.100.150</p> <ul> <li>Note that 10.60.100.150 is not in 10.61.100.0/24 (The Static-IP pool for this DNN)</li> </ul> <p></p> </li> <li> <p>Click Verify</p> <ul> <li>Since the IP address is not in the Static-IP pool for this DNN, it would pop up \"No\" with the reason.</li> </ul> <p></p> </li> <li> <p>Correct the IP and Verify again: 10.61.100.150</p> <p></p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000002","title":"imsi-208930000000002","text":"<ul> <li> <p>010203 </p> <ul> <li> <p>Set 10.60.100.163 for this DNN and click Verify.</p> <ul> <li>Note that 10.60.100.163 was set to another UE</li> </ul> <p> - Change to  10.60.100.165</p> </li> </ul> </li> <li> <p>112233 </p> <ul> <li>Keep the Static IPv4 Address toggle off, as Dynamic IPv4 address for this DNN.</li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#test-with-ueransim","title":"Test with UERANSIM","text":"<ul> <li>You can refer to this for instructions on how to use UERANSIM.</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000001_1","title":"imsi-208930000000001","text":"<ul> <li>This UE gets 10.60.100.163 for slice 010203, which is what we assigned before.</li> <li>This UE gets 10.61.100.165 for slice 112233, which is what we assigned before</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000002_1","title":"imsi-208930000000002","text":"<ul> <li>This UE gets 10.60.100.165 for slice 010203, which is what we assigned before</li> <li>This UE gets 10.61.0.1 for slice 112233, the IP address in pools assigned by SMF.</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/","title":"Tngfue installation","text":""},{"location":"guide/TNGF/tngfue-installation/#1-free5gc-installation","title":"1. free5GC installation","text":"<p>(Optional) If you install free5GC on a VM, add a network adapter set to bridged mode, and set the card name to your AP. Some additional information on how to configure multiple network interfaces on the VM are available on the docs and on Ubuntu docs page.</p>"},{"location":"guide/TNGF/tngfue-installation/#follow-the-tutorial-in-free5gc-official-site","title":"Follow the tutorial in free5GC official site:","text":"<ul> <li>Installing free5GC and webconsole</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/#configuration-for-nfs","title":"Configuration for NFs","text":"<p>Modify <code>~/free5gc/config/tngfcfg.yaml</code> file <pre><code># --- Bind Interfaces ---\nIKEBindAddress: &lt;YOUR_FREE5GC_IP&gt; # IP address of Nwu interface (IKE) on this TNGF\nRadiusBindAddress: &lt;YOUR_FREE5GC_IP&gt; # IP address of Nwu interface (IKE) on this TNGF\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#2-use-webconsole-to-add-ue","title":"2. Use WebConsole to Add UE","text":"<ul> <li>Start your webconsole server <pre><code>cd ~/free5gc/webconsole/\nmake # If webconsole was not previously compiled\n./bin/webconsole\n</code></pre></li> <li>Open your web browser from your host machine, and enter the URL <code>http://&lt;FREE5GC_IP&gt;:5000</code></li> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code></li> <li>Go to <code>SUBSCRIBERS</code> and click on <code>CREATE</code></li> <li>Check that the <code>SUPI (IMSI)</code> field is unique and modify other fields as necessary to ensure data consistency with sec.conf file </li> <li>Then, scroll the page all the way down and click on <code>CREATE</code>.</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/#3-access-point-setup","title":"3. Access Point Setup","text":"<p>Note: The steps of this section were tested using OpenWrt as AP firmware (see screenshot below)</p>"},{"location":"guide/TNGF/tngfue-installation/#ap-information","title":"AP information","text":""},{"location":"guide/TNGF/tngfue-installation/#configuring-wi-fi-network-essid","title":"Configuring Wi-Fi Network ESSID","text":"<p>Network \u2192 Wireless \u2192 Edit \u2192 Interface Configuration \u2192 General Setup </p>"},{"location":"guide/TNGF/tngfue-installation/#configuring-wi-fi-network-security","title":"Configuring Wi-Fi Network Security","text":"<p>Interface Configuration \u2192 Wireless Security </p> <p>Note: <code>RADIUS Authentication Server</code> is free5GC's IP. <code>RADIUS Authentication Secret</code> must match the one from <code>RadiusSecret</code> parameter on tngfcfg.yaml file</p> <p>Tip: If WPA2-EAP isn't available on the OpenWrt firmware installed, check this troubleshooting section.</p>"},{"location":"guide/TNGF/tngfue-installation/#4-tngfue-installation","title":"4. TNGFUE Installation","text":"<p>Install TNGFUE in another device with a Wi-Fi interface available</p>"},{"location":"guide/TNGF/tngfue-installation/#get-source-code","title":"Get Source Code","text":"<pre><code>git clone https://github.com/free5gc/tngfue.git\ncd tngfue\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#tngfue-configuration","title":"TNGFUE Configuration","text":""},{"location":"guide/TNGF/tngfue-installation/#a-automated-setup","title":"A. Automated Setup","text":"<p>Use the <code>prepare</code> script:</p> <p>(Optional) Open the script and adjust it with the desired parameters/vars <pre><code>nano prepare.sh\n</code></pre></p> <p>Note: Confirm the Wi-Fi interface name (i.e. <code>IFACE_NAME</code>) is the same as the OS name</p> <p>Run the script to begin building TNGFUE <pre><code>./prepare.sh\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#b-advanced-manual-setup","title":"B. Advanced Manual Setup","text":"<p>(Alternatively) To configure and build manually:</p> <p>Note: The <code>prepare</code> script executed the steps below, you may skip to the next section</p>"},{"location":"guide/TNGF/tngfue-installation/#buildcompile-configuration","title":"Build/Compile Configuration","text":"<p>Make sure the flag <code>CONFIG_EAP_VENDOR_TEST</code> of the <code>.config</code> file inside <code>wpa_supplicant</code> folder is enabled as shown below: <pre><code>...\nCONFIG_EAP_VENDOR_TEST=y\n...\n</code></pre> Tip: This setting is already enabled</p>"},{"location":"guide/TNGF/tngfue-installation/#tngfue-settings","title":"TNGFUE Settings","text":"<p>Modify <code>~/tngfue/wpa_supplicant.conf</code></p> <ul> <li><code>ssid:</code> your ap/wifi name  (same as the AP setting part)</li> <li><code>identity:</code> identity information for this ue  (set whatever you want)</li> <li><code>password:</code> wifi/ap password (same as the AP setting part)</li> </ul> <pre><code>ctrl_interface=udp\nupdate_config=1\nnetwork={\n    ssid=\"&lt;YOUR_AP_NAME&gt;\"\n    key_mgmt=WPA-EAP\n    eap=VENDOR-TEST IKEV2\n    identity=\"&lt;YOUR_IDENTITY_INFO&gt;\"\n    password=\"&lt;YOUR_PASSWORD&gt;\"\n}\n</code></pre> <p>E.g. <pre><code>ctrl_interface=udp\nupdate_config=1\nnetwork={\n    ssid=\"free5gc-ap\"\n    key_mgmt=WPA-EAP\n    eap=VENDOR-TEST IKEV2\n    identity=\"tngfue\"\n    password=\"free5gctngf\"\n}\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#security-parameters","title":"Security Parameters","text":"<p>In <code>tngfue/wpa_supplicant/sec.conf</code>:</p> <ul> <li><code>wifiifname:</code> your wifi interface name  (you can find this by typing <code>ifconfig</code> in terminal)</li> </ul> <p>You can find all the parameters listed below on the Web Console subscriber page.</p> <ul> <li><code>imsi_identity:</code> SUPI(IMSI)</li> <li><code>MSIN:</code> SUPI without the PLMN part</li> </ul> <p>Format:  <pre><code>wifiifname: &lt;YOUR_WIFI_INTERFACE_NAME&gt;\nK:&lt;UE_K_IN_WEBCONSOLE&gt;\nimsi_identity:&lt;UE_SUPI_IN_WEBCONSOLE&gt;\nnai_username:type0.rid61695.schid0.userid&lt;MSIN&gt;\nSQN:&lt;UE_SQN_IN_WEBCONSOLE&gt;\nAMF:&lt;AMF_IN_WEBCONSOLE&gt;\nOPC:&lt;UE_OPCV_IN_WEBCONSOLE&gt;\n</code></pre></p> <p>E.g. <pre><code>wifiifname:wlp3s0\nK:8baf473f2f8fd09487cccbd7097c6862\nimsi_identity:208930000000007\nnai_username:type0.rid61695.schid0.userid000000000007\nSQN:16f3b3f70fe1\nAMF:8000\nOPC:8e27b6af0e692e750f32667a3b14605d\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#build-binary","title":"Build binary","text":"<p><pre><code>cd ~/tngfue/wpa_supplicant/\nmake\n</code></pre> For more information, see this troubleshooting section</p>"},{"location":"guide/TNGF/tngfue-installation/#5-testing","title":"5. Testing","text":""},{"location":"guide/TNGF/tngfue-installation/#a-run-free5gc-with-tngf","title":"A. Run free5GC with TNGF","text":"<p>On free5GC's machine: <pre><code>cd ~/free5gc\n./run.sh -tngf\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#b-run-tngfue","title":"B. Run TNGFUE","text":"<p>On TNGFUE's machine:</p>"},{"location":"guide/TNGF/tngfue-installation/#run-using-the-run-script","title":"Run using the <code>run</code> script","text":"<p><pre><code>./run.sh\n</code></pre> Then skip to the next section</p>"},{"location":"guide/TNGF/tngfue-installation/#alternatively-run-manually","title":"(Alternatively) Run manually","text":""},{"location":"guide/TNGF/tngfue-installation/#make-sure-xfrm-and-gretun0-does-not-exist","title":"Make sure xfrm and greTun0 does not exist","text":"<p>If you have not successfully connected to TNGF yet, you can skip this step</p> <p>Delete both interfaces using: <pre><code>sudo ip l del greTun0\nsudo ip l del xfrm-1\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#set-wi-fi-interface-ip-to-the-same-lan-as-free5gc","title":"Set Wi-Fi interface IP to the same LAN as free5GC","text":"<pre><code>ip a add 192.168.1.202/24 brd 192.168.1.255 dev &lt;YOUR_WIFI_INTERFACE_NAME&gt;\nip r add default via 192.168.1.202 dev &lt;YOUR_WIFI_INTERFACE_NAME&gt;\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#run","title":"Run","text":"<pre><code>cd ~/tngfue/wpa_supplicant\nsudo ./wpa_supplicant -c ../wpa_supplicant.conf -i &lt;YOUR_WIFI_INTERFACE_NAME&gt;\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#example-output","title":"Example output","text":"<p>When the session successfully connects, it will be possible to see these five interfaces established.  </p> <p>And TNGFUE will show that connection is completed. </p>"},{"location":"guide/TNGF/tngfue-installation/#c-transfer-data-over-the-gretun0-interface","title":"C. Transfer data over the greTun0 interface","text":"<p><pre><code>ping -I greTun0 8.8.8.8\n</code></pre> </p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/","title":"Create Subscriber via webconsole","text":""},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#create-subscriber-via-webconsole","title":"Create Subscriber via Webconsole","text":""},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#1-install-webconsole","title":"1. Install Webconsole","text":"<p>If Webconsole isn't installed yet, please, follow the instructions from GitHub page.</p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#2-optional-delete-mongodb-database","title":"2. (Optional) Delete MongoDB database","text":"<p>If another version of free5GC was ran before, you have to delete MongoDB. <pre><code>$ mongo --eval \"db.dropDatabase()\" free5gc\n</code></pre></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#3-run-webconsole-server","title":"3. Run Webconsole server","text":"<pre><code>$ cd ~/free5gc/webconsole\n$ go run server.go\n</code></pre>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#4-open-webconsole","title":"4. Open Webconsole","text":"<p>Enter URL: <code>&lt;Webconsole server's IP&gt;:5000</code> in browser</p> <p></p> <p>Default credential: <pre><code>Username: admin\nPassword: free5gc\n</code></pre></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#5-add-new-subscriber","title":"5. Add new subscriber","text":"<p>There are two options to add a new subscriber:</p> <ul> <li>Directly create subscriber in create subscriber page</li> <li>Create profile first, then create subscriber with the profile</li> </ul>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#51-directly-create-subscriber-in-create-subscriber-page","title":"5.1. Directly create subscriber in create subscriber page","text":"<p>Click <code>SUBSCRIBERS</code> -&gt; <code>CREATE</code></p> <p></p> <p>Edit the Subscriber's data and click <code>CREATE</code>, here you can configure the </p> <ul> <li>Network Slicing Configuration<ul> <li>SST/SD (Slice/Service Type and Slice Differentiator)</li> <li>DNN (Data Network Name) Configuration<ul> <li>AMBR (Aggregate Maximum Bit Rate)<ul> <li>Maximum total uplink/downlink bitrate limits</li> </ul> </li> <li>Default 5QI (5G QoS Identifier)<ul> <li>Default Quality of Service identifier</li> <li>GBR type (5QI values: 1-4, 65-67, 71-76)</li> <li>Non-GBR type (5QI values: 5-9, 69-70, 79-80)</li> </ul> </li> <li>Flow Configuration<ul> <li>IP Filter<ul> <li>Source/destination IP address ranges</li> <li>CIDR Format (eg: \"140.113.0.0/16\") </li> </ul> </li> <li>Precedence<ul> <li>Priority of flow rules (lower value means higher priority)</li> </ul> </li> <li>5QI (Flow-specific QoS identifier)<ul> <li>Non-GBR flows: Best effort traffic, no bandwidth guarantee</li> <li>GBR flows: Guaranteed bit rate for specific services</li> </ul> </li> <li>Uplink GBR/MBR (Guaranteed/Maximum Bit Rate)<ul> <li>Applicable for GBR 5QI flows</li> </ul> </li> <li>Downlink GBR/MBR (Guaranteed/Maximum Bit Rate)<ul> <li>Applicable for GBR 5QI flows</li> </ul> </li> <li>Flow-Based Charging Config</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p> </p> <p>Check that the new subscriber was added successfully</p> <p></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#52-create-profile-first-then-create-subscriber-with-the-profile","title":"5.2. Create profile first, then create subscriber with the profile","text":"<ul> <li>Profile is a pre-configured data, which can be used to create multiple subscribers with the same data quickly.</li> <li>For these basic subscriber information, please remember to customize them in the <code>CREATE SUBSCRIBER</code> page:</li> <li>Subscriber data number</li> <li>SUPI (IMSI)</li> <li>PLMNID</li> <li>GPSI (MSISDN)</li> <li>Authentication Management Field (AMF)</li> <li>Authentication Method</li> <li>Operator Code Type</li> <li>Operator Code Value</li> <li>SQN</li> <li>Permanent Authentication Key</li> </ul> <p>Click <code>PROFILE</code> -&gt; <code>CREATE</code></p> <p></p> <p>Edit the Profile's data and click <code>CREATE</code></p> <p> </p> <p>Check that the new profile was added successfully</p> <p></p> <p>Click <code>SUBSCRIBERS</code> -&gt; <code>CREATE</code></p> <p>Click <code>SELECT PROFILE</code> -&gt; Select the profile you just created and customize some basic subscriber information -&gt; <code>CREATE</code></p> <p></p> <p>Check that the new subscriber was added successfully</p> <p></p>"},{"location":"support/","title":"Index","text":""},{"location":"support/#technical-support","title":"Technical Support","text":"<p>If you encounter the usage problem on free5GC, please join our official forum forum.free5gc.org and initiate a new discussion.</p> <p>Otherwise, you can raise the issue on our GitHub repository for reporting the bugs/suggestions (related to vulnerability/functionality/deployment/testing), or create the pull request for contributing to our community!</p> <p>Tips</p> <p>If your problem can not be solved via the platforms listed above, please send an email directly to <code>free5GC.org@gmail.com</code>. Thanks.</p>"}]}